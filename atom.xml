<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星星杂货铺</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-15T00:15:34.710Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gustin Lau</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>古国文明-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Civilization-Of-Ancient-Country-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Civilization-Of-Ancient-Country-Ans/</id>
    <published>2021-05-14T12:00:00.000Z</published>
    <updated>2021-05-15T00:15:34.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>次声波</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>1、辨认出的文字中，“法老”对应古埃及、“婆罗多”对应古印度、“黄河”对应中国，可以联想到四大文明古国，“楔形”、“阿卡德”和“乌尔”对应古巴比伦王国之前的苏美尔王朝、阿卡德王国和乌尔王朝，由此推断老人原本推开的书应该与古巴比伦有关。</p><img src="/assets/images/crimaster/2021/05/20210514-ans-1.png" alt="图片" class="post-image half"><p>2、老人最后留下的文字是古希腊字母，根据每个字母名称开头解得”MARDUK”，即马杜克，巴比伦城邦之神，对应视频日期“2009/03/02”可联想到“马杜克神像迷案”，该案件的发生正是缘于<font style="color:#D9730D">次声波</font>。</p><p>3、老人视频中的表现符合人体受到次声波影响后表现。</p><img src="/assets/images/crimaster/2021/05/20210514-ans-2.png" alt="图片" class="post-image half"><p>马杜克神像之谜的揭秘:马杜克神像是空心结构，在神像的內侧，布满了一圈圈奇怪的水波纹线条，就好似现代镭射唱片一般，而在神像外侧，以一种奇怪的规则，分布着几个风口。当风自这些风口灌入，通过这些波纹的震荡，就会形成声波振动，达到播放唱片一般的效果</p><p>由于根本无法把握风吹入侧的规律，研究者也无法再现这尊马杜克神像所可能发出来的声音。只不过可以确定的一点就是，这些声音根本就不是放给人听的。因为人耳所能接受的声波频率为20～20000赫兹，而马杜克神像所可能发出来的声音，却属于频率低于20赫兹的次声波，而这些次声波就是引发前面一系列离奇案件的”凶器”</p><img src="/assets/images/crimaster/2021/05/20210515-1.png" alt="图片" class="post-image half">]]></content>
    
    
    <summary type="html">20210514期侦探委托《古国文明》 答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>古国文明</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Civilization-Of-Ancient-Country/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Civilization-Of-Ancient-Country/</id>
    <published>2021-05-14T00:00:00.000Z</published>
    <updated>2021-05-15T00:19:35.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>“叮咚。”电脑响了，是哥哥发来的消息。</p><p>“来找找这次的’凶器’吧。”</p><p>你的哥哥小粥是一名侦探，因为你也很热爱推理，哥哥经常会自己制作谜题发给你，来锻炼你的能力。</p><p>这次发来的谜题是视频形式，你点开全屏观察了下，看样子是装在房里的监控录制下来的，右下角的日期是<font color="#56c596">“2009/03/02”</font>，房间整体布局可以看出是一间书房，书桌上堆了一摞书，你仔细看了看，辨认出<font style="color:#D9730D">“法老”、”婆罗多”、”黄河”</font>、<font color="#5874dc">“楔形”、”阿卡德”、”乌尔”</font>、<font color="#b482c0">“古希腊文明”</font>等字眼，有一个老头在笔记本上写字，旁边还有一本推开的书，但因为那一摞书遮挡，你看不清楚。</p><p>你点击播放键，老头正在笔记本上写着什么，2、3秒后老头的手忽然颤抖起来，手里的笔也掉落在纸上，按住胸口，张开嘴呼吸急促的样子，随后老头撑着桌子起来，跌跌撞撞地奔向门口，途中摔倒了几次，看得你都担惊受怕，按了几次门把却打不开房门，随即扶着墙摇摇晃晃走到书桌，剧烈发抖的手拿起笔写了些什么，之后腿一软就倒地了。</p><p>视频到这就结束了。你反复看了几遍，发消息问哥哥:”他最后写了些什么?”</p><p>哥哥发来一张图片:</p><img src="/assets/images/crimaster/2021/05/20210514-1.png" alt="图片" class="post-image half"><p>视频中所有信息暗示着一件事件，请问该事件发生的真正原因，即哥哥所说的’凶器’!</p><p>请认真推敲剧情中的细节!</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>“凶器”的名称 三个汉字</p>]]></content>
    
    
    <summary type="html">你的哥哥小粥是一名侦探，因为你也很热爱推理，哥哥经常会自己制作谜题发给你，来锻炼你的能力。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>你是谁-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Who-Are-You-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Who-Are-You-Ans/</id>
    <published>2021-05-12T12:00:00.000Z</published>
    <updated>2021-05-15T00:08:43.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><ol><li>这个房子除了你是否有其他人居住？<br>A.有<br><font color="#56c596">B.没有</font></li></ol><ol start="2"><li>相对于以下选项，哪个最不可能是你的职业？<br>A.心理学教授<br><font color="#56c596">B.医生</font><br>C.作家  </li></ol><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>最终你选择报警，警察赶到你家中发现地下室的尸体，通过调查，确定你便是那个雨夜屠夫!</p><p>你患有DID，也就是多重人格障碍，在调查中警方发现你患有DID和你从小经历脱不开关系，你从小受到父亲的虐待，和母亲相依为命，喝醉酒的父亲常常殴打母亲，有一天暴风雨夜，你亲眼看到父亲将母亲残忍的杀害，从那天开始你的身体就慢慢有了另一个人格，但他一直在沉睡，直到三个月前开始苏醒。你不知道他的存在，但他却知道你的所有事，昨天晚上你的次人格像往常样出门开车寻找猎物下手，但由于暴雨以及晚间开车，在一个红绿灯处，一个疲劳驾驶的司机开着一辆卡车从侧面撞向了你，导致你受伤并且失忆。</p><p>第一题</p><p>从日记你被人跟踪的线索，以及被删除的录像，以及书桌的计划便签习惯都说明好像房子里的确存在另一个人，但只有仔细观察便会发现这其中的矛盾。</p><p>首先计划上的打猎，可纵观房子其中并没有任何打猎用的工具，可以猜测这里写的打猎并非真的打猎，更像是“狩猎”，也就是另一个人格雨夜屠夫的计划，他的杀人计划。</p><p>日记中那句“只有我知道密码”表明能打开电脑的只有你。</p><p>卫生间的洗漱用品也只有一个人的。</p><p>家中有一个地下室，里面有许多的尸体，而你家中十分整洁，想要做到这一切需要大量的时间，而你离职经常待在家中，家中布局也较简单，如果是有另外一个人做的这些你很难不察觉。</p><p>第二题</p><p>你最不可能的职业，从书架上来看，从上到下分别对应心理学教授、医生、作家。</p><p>手机短信表明了自己作者身份，在第一题的前提下得知自己便是雨夜屠夫，地下室的被剥了人皮的尸体线索中，每一具人皮都被精致处理，连手部、面部的表皮都完整无损，这不是一般人能够做到，且不是几日便能够熟练掌握，可以说明你可能是医生，或者曾经是一名医生，并且还是个技术高超的外科医生。从线索中可以观察到心理学书籍在书架的最上层并且并不专业，连《天オ在左疯子在右》的这种小说也有，也并没有其他线索指明你心理学教授的身份，且你长时间处于一个精神不正常的状态，但在日记中你从未怀疑自己的心理状况出现问题，且心理学家大多有细微的观察能力，而你身边的各种细节你并未很迅速的察觉到。所以，相对于选项中你最不可能的身份为心理学教授。</p>]]></content>
    
    
    <summary type="html">20210512期侦探委托《你是谁》 答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托-解答" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>你是谁</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Who-Are-You/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Who-Are-You/</id>
    <published>2021-05-12T00:00:00.000Z</published>
    <updated>2021-05-12T14:40:17.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="案件介绍"><a href="#案件介绍" class="headerlink" title="案件介绍"></a>案件介绍</h1><p>你从医院的病床上醒来，抬眼望着周围陌生的一切，脑海里充满了疑:我是谁?我为什么会来到这里?你望着身上几处被医生缠好的绷带，脑中企图开始回忆，但一阵尖锐的疼痛不得不让你停止思考医生和你身边自称是你朋友的人见状走来，询问了你的状况并向你解释了你来到医院的原因。据医生所说，你是昨晚因为出车祸被送到医院的，但车祸并不严重，除了你的脑部受到了撞击，身体的其它部位都只是轻伤，既然醒来应该就已无大碍，再做几项检查观察一下便可出院。你对医生所说的车祸经过没有一点印象，对所有事情都失去记忆的恐惧慢慢压迫着你，你不等检查便匆匆离开了医院，想要找回记忆，你的朋友来不及劝阻，只能带着你回到你的家里，你望着这栋有些熟悉但又很陌生的房子内的种种，试图从这个地方找到一点关于自己的信息。</p><h1 id="现场侦测"><a href="#现场侦测" class="headerlink" title="现场侦测"></a>现场侦测</h1><p>你望着镜子中的自己，一张陌生的脸庞，笔直又挺拔的身材，体型中等偏瘦，戴着一副黑色眼镜，你尝试着拿下眼镜，发现这并不影响你的视力，你望着身上已经包扎过的伤口，脑海中似是有些记忆，画面忽然闪现在你的脑海，画面中是一辆汽车，你坐在汽车的驾驶位等待着红绿灯，雨刷器扑闪着刮走车前窗的雨水，副驾驶上似是有个身影，但你却如何也记不起他的长相，一束亮光从方照来，越来越刺眼，突然，画面混沌，整个世界都仿佛在晃动，随后一切重归于黑暗之中…</p><p>房间布局：</p><img src="/assets/images/crimaster/2021/05/20210512-1.png" alt="" class="post-image half"><h1 id="初始线索"><a href="#初始线索" class="headerlink" title="初始线索"></a>初始线索</h1><h2 id="车祸备案"><a href="#车祸备案" class="headerlink" title="车祸备案"></a>车祸备案</h2><p>2021年05月11日晚上22:39一辆卡车与一辆轿车于某某路段发生撞击，因现场路段无监控，车辆已被警方处理，带回相关部门做车祸鉴定。</p><h2 id="朋友谈话"><a href="#朋友谈话" class="headerlink" title="朋友谈话"></a>朋友谈话</h2><p><strong>朋友</strong>：你最近很奇怪，总说有人跟踪你，还说那个人潜入了你的家里。<br><strong>你</strong>：我有没有跟你说那个人是谁?<br><strong>朋友</strong>：没有，你好像一直也没把人找出来。以后开车可小心点，还有，你已经辞职快一个月了，从来也没跟我说过你有什么计划，想要干点什么总在家里闷着，把你一个人放在这儿我不是很放心，要不你跟我回我家住段时间?<br><strong>你</strong>：不了，我没事。<br><strong>朋友</strong>：好吧，我还有点事，你照顾好自己，有事给我打电话，我先走了。<br><strong>你</strong>：嗯，放心。</p><p>（我究竟是谁?这是我的家吗?等这人走了到屋里去看看吧……）</p><h1 id="房间线索"><a href="#房间线索" class="headerlink" title="房间线索"></a>房间线索</h1><h2 id="台历和照片"><a href="#台历和照片" class="headerlink" title="台历和照片"></a>台历和照片</h2><p>书房的书桌上有个台历和一张照片，台历上有着一个便签，上面写着:“计划安排:1.打猎 2.购买装备”照片年代有些老旧，上面是一个面庞慈善大概三十岁左右的女人正抱着一个眉眼与你有些相似的六七岁的小男孩。</p><h2 id="书架"><a href="#书架" class="headerlink" title="书架"></a>书架</h2><p>书桌的背后是一个书架，书架总共有三层，书从左到右都是从小书到大书的排列，十分整洁。<br>最上面一层有《爱的艺术》，《拆掉思维里的墙》，《天才在左，疯子在右》《怪诞心理学》…<br>中间一层有《人体断层解剖学图谱》，《人体系统解剖学》…<br>最下面一层有《小说的艺术》《百年孤独》《文学讲稿》…</p><h2 id="电脑"><a href="#电脑" class="headerlink" title="电脑"></a>电脑</h2><p>书桌上有一台台式电脑，打开需要密码，你几次尝试输入，一直显示密码错误。</p><h2 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h2><p>桌子上摆着一个牛皮封面的日记本，你翻着日记本，发现自己有每天写日记的习惯，但最近这段时间不知是有事还是想要偷懒，日记并没有每一天都写，而是断断续续，且最近的日记内容极其诡异。<br>日记部分较不正常内容：</p><p>04月02日<br>最近过的昏昏沉沉的，好像总是在睡觉，就像被人下了药一样，一觉醒来什么都不记得，日记竟然都忘记写了。</p><p>04月21日<br>家里最近是因为下雨太潮湿了吗?怎么这么多水渍下雨天我明明没有出门…</p><p>05月08日<br>他就和幽灵一样，他到底是谁，他想干嘛，他就像生活在我身边一样，甚至是住在我的家里，最近我的家里总是莫名出现一些奇怪的东西，我知道那些东西不属于我，可我却没有发现过他，但我坚信他一定存在，别人都觉得我疯了，但我清楚的知道他的存在，我准备在家里安装摄像头，我倒要看看他到底是谁!</p><p>05月10日<br>怎么可能，摄像头拍下的录像竟然失效被删除了，不可能的，电脑密码他怎么可能知道，怎么可能……这密码只有我一个人知道，只有我知道!</p><h2 id="卫生间"><a href="#卫生间" class="headerlink" title="卫生间"></a>卫生间</h2><p>洗漱台上摆放着一个漱口杯，里面有一只牙刷和一支牙膏、旁边有一支洗面奶以及一个刮胡刀。</p><h1 id="其他线索"><a href="#其他线索" class="headerlink" title="其他线索"></a>其他线索</h1><h2 id="手机线索"><a href="#手机线索" class="headerlink" title="手机线索"></a>手机线索</h2><p>你拿起了手机，想要在手机里寻找线索，一个被你单独收藏的软件《 CRIMASTER犯罪大师》引起了你的注意，其中有唯一一条被你点赞以及评论的帖子：<br>最近网络上沸沸扬扬的雨夜屠夫案，连续三个月，已有十余名女性遇，害据说这个雨夜屠夫只会在下雨的日子出现，专挑那些三十几岁的女性下手，还有很多受害者没有被找到，估计凶多吉少，这个案子你们怎么看？<br>评论：<br>据我推理，凶手专挑下雨天下手，估计是雨天对凶手本人有什么不一样的意义吧。</p><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p>5月10号<br>您的文章《你的身体里流淌着杀人犯的血液》已被收录至“鹿先森”杂志，稿费将于月底统一发送。</p><h2 id="卧室"><a href="#卧室" class="headerlink" title="卧室"></a>卧室</h2><p>室中十分整洁，但有一股淡淡的香料味道以及一股消毒水的味道，你仔细观察着卧室，并没有发现卧室里其他有异常的地方，味道好像是从衣柜里传出，你打开了衣柜，发现里面衣服都是西服，左边是浅蓝色，右边是黑色，你扒开衣服，竟发现卧室里衣柜里存在一个隐藏的密道门!你打开了门，顺着密道往下，发现了一间地下室…</p><h2 id="地下室"><a href="#地下室" class="headerlink" title="地下室"></a>地下室</h2><p>里面是一小段阶梯，你顺着阶梯走下不久便来到了地下室的房门前，打开房门，一股腐烂的味道直冲而来，抬眼望去，地下室的墙壁上悬挂着十几具血淋淋的尸体，水龙头未拧紧正朝下落着水滴，滴答滴答的声音刺激着你的灵魂，每具尸体前都摆着一张人皮，活生生的从尸体上剥下的人皮!每一具人皮都被精致处理，连手部、面部的表皮都完整无损，头皮上还连接着长发，一个个摆的整整齐齐，犹如一个个珍宝。<br>你忍住呕吐从地下室疯了一样跑了出来，瘫坐在卧室地上，你的脑海里只有一个想法，那就是报警!报警!你拿起手机刚准备按下最后的零，突然，停在了那个按键上。你…真的决定要报警嘛?</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>这个房子除了你是否有其他人居住？<br>A.有<br>B.没有</li></ol><ol start="2"><li>相对于以下选项，哪个最不可能是你的职业？<br>A.心理学教授<br>B.医生<br>C.作家</li></ol>]]></content>
    
    
    <summary type="html">你从医院的病床上醒来，抬眼望着周围陌生的一切，脑海里充满了疑:我是谁?我为什么会来到这里?你望着身上几处被医生缠好的绷带，脑中企图开始回忆，但一阵尖锐的疼痛不得不让你停止思考医生和你身边自称是你朋友的人见状走来，询问了你的状况并向你解释了你来到医院的原因…</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>极速破译-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Speed-Decipher-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Speed-Decipher-Ans/</id>
    <published>2021-05-09T12:00:00.000Z</published>
    <updated>2021-05-10T11:29:56.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>春丛认取双蝶</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><font style="color:#D9730D">后续:似乎警队只是抓到了被嫁祸之人，真正的手与被嫁祸人有深仇大恨，身边至亲人的离世与被嫁祸者有关!</font></p><p>本题有多种解法，需一一尝试，因诗词的提示所以其它皆为乱序，无法得出答案。</p><p>正确解题过程：</p><p>内华达州机密区域为51区，因此所需步骤为24即所有白格都要走一遍。天空到地狱，意为自上 而下的顺序，下面有R和E，但是右下角的E只有 一条能单向通向它的路，而且又要求所有格子都走完，所以E必定是起始点或终点(所以把极高处到底端理解为字母表中从A到Z的也可以通过观察这一点排除)，同理左上角的C也能这样确定是起始或终点，所以最终只能是左上角的C到右下角的E。</p><p>提示一为“王，皇后，战车与主教”，意为国际象棋，赤兔是马，马走L型，根据提示需要走24步，从头到尾走完所经历的字母，便是答案。</p><p>(即<font style="color:#D9730D">CHUNCONGRENQUSHUANGQIDIE</font>，根据答案要求的七个汉字加上诗词的提示得到:<font style="color:#D9730D">春丛认取双栖蝶</font>)</p><img src="/assets/images/crimaster/2021/05/20210509-ans-1.png" alt="图片" class="post-image half">]]></content>
    
    
    <summary type="html">20210509期侦探委托《神秘交易》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托-解答" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>极速破译</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Speed-Decipher/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Speed-Decipher/</id>
    <published>2021-05-09T00:00:00.000Z</published>
    <updated>2021-05-09T02:44:22.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>近日刑警平次和其团队告破了一起重大连环杀人案，但最终本该庆祝的时刻，平次忽然意识到案发时凶手使用某物件所对应的身高区间，与所抓嫌疑人不符，他急忙赶回现场，在隐秘角落里发现这样一条奇怪的图文。</p><img src="/assets/images/crimaster/2021/05/20210509-1.png" alt="图片" class="post-image half"><p>文：自天空极高处直至地狱的底端，追寻赤兔的足迹。(所需步骤为内华达州机密区域所对应数字减3的一半)</p><p><font style="color:#D9730D">提示1:王、皇后、战车与主教</font></p><p><font style="color:#D9730D">提示2:诗词</font></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>七个汉字</p>]]></content>
    
    
    <summary type="html">近日刑警平次和其团队告破了一起重大连环杀人案，但最终本该庆祝的时刻，平次忽然意识到案发时凶手使用某物件所对应的身高区间，与所抓嫌疑人不符，他急忙赶回现场，在隐秘角落里发现这样一条奇怪的图文。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>哥哥的礼物-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Brother&#39;s-Gift-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Brother&#39;s-Gift-Ans/</id>
    <published>2021-05-08T12:00:00.000Z</published>
    <updated>2021-05-09T02:36:48.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>cop</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>密码箱打开了，哥哥居然送了我一本CRIMASTERA解密本，上面还有一段哥哥写给我的话:</p><p>努力的苦读，就为这一刻！把你的实力全部发挥，所有关爱着你的人，都会为你祝福祈祷，相信你一定会考出满意的成绩！</p><p><font style="color:#D9730D">(作者在此祝愿莘莘学子们都能够金榜题名)</font></p><p>解题过程：</p><p>将连接处折叠形成一个正十二面体(提示降维打击指从三维立体到二维平面，需将平面还原成立体)十二面体中距离X最远的面是它的对面就是2，所以2就是O。骆驼英文是camel，与O相邻的面是3、5、6、7、8，所以3、5、6、7、8是camel但是具体对应还不明确。Z的一圈是X、1、5、8、4，5和8已经有字母了，所以1，4就是I、P，因为P不和Y相邻，所以1是P、4是。和Z、P都相邻的面是X和5，所以5是C，顺时针排一圈，5是C、8是A、7是M、6是E、3是L。再用和L是对面验证，成立。就剩下9，所以9是N。</p><img src="/assets/images/crimaster/2021/05/20210508-ans-1.png" alt="" class="post-image half no-limit-height"><p>按照1到9排列得policeman(警察)，将其镜像反转得到</p><img src="/assets/images/crimaster/2021/05/20210508-ans-2.png" alt="" class="post-image half no-limit-height"><p>台球中1-黄色，2-蓝色，3-红色，4-紫色，5桔色，6-绿色，7酱色，8-黑色，9-黄/白色，10-蓝/白色，11-红/白色，12-紫/白色，13-桔/白色，14-绿/白色，15-酱/白色对应就是589，即cop(警察)。</p>]]></content>
    
    
    <summary type="html">20210508期侦探委托《哥哥的礼物》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托-解答" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>哥哥的礼物</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Brother&#39;s-Gift/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Brother&#39;s-Gift/</id>
    <published>2021-05-08T00:00:00.000Z</published>
    <updated>2021-05-09T02:31:57.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>今天是哥哥从警校回家的日子，好在他还记得我这个妹妹还有几十天就要中考了，破天荒的为我准备了一份礼物，但是需要解开密码箱才能够拿到。</p><p>箱子上的一副图和一段话如下：</p><img src="/assets/images/crimaster/2021/05/20210508-1.png" alt="图片" class="post-image half"><p>提示：</p><p>整个世界被降维打击，请准确还原。Z有两边是 I、P，骆驼顺时绕O转一圈，P、Y吵架不相邻， Z、P也和C相邻，离X最远的是O，I、L是对面，最后一处就是N。</p><p>球杆依次击中正义之职在镜子中的桔、黑及黄白寻找答案。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>三个字母的单词</p>]]></content>
    
    
    <summary type="html">今天是哥哥从警校回家的日子，好在他还记得我这个妹妹还有几十天就要中考了，破天荒的为我准备了一份礼物，但是需要解开密码箱才能够拿到。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>地球保卫战-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Challenge-Earth-Defense-Force-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Challenge-Earth-Defense-Force-Ans/</id>
    <published>2021-05-05T12:00:00.000Z</published>
    <updated>2021-05-05T14:42:44.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>skullisland</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>观察第一幅图可知，这和猪圈密码有关</p><img src="/assets/images/crimaster/2021/05/20210505-ans-1.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210505-ans-2.png" alt="图片" class="post-image half"><p>则根据密码表根据观察得到，红对应的为M，蓝对应的为Z，紫对应的为H，根据第二张图可知， 第一张图的三个字母与第二张图的三个字母有某种正确对应关系。根据提示(找到正确的字母)，意思是告诉我们将进行字母按字母表顺序将对应。接下来将进行试错，若M对应V，H就将对应A，Z对应N，将无法按字母表顺序得到新的关系。</p><p>以此类推，最终确认M对应A，H对应V，Z对应N。如图，我们得到了新的对应表。</p><img src="/assets/images/crimaster/2021/05/20210505-ans-3.png" alt="图片" class="post-image half"><p>此时看第三张图，发现所给音素为元音音素，提示为元音密码，根据/将数字进行几个为一组的分组则可以得到</p><p>2/52/22/53/53/5/2/53/34/55/41</p><p>此时用元音密码则可以解出EWGXXUEXMZP</p><img src="/assets/images/crimaster/2021/05/20210505-ans-4.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210505-ans-5.png" alt="图片" class="post-image half"><p>此时得到的EWGXXUEXMZP带回对应表中，此时并不知道正确的明文密文对应方向，将进行两次试错：</p><p>1.若M为开头的为明文，A开头的为密文则，可得到qisjjgqjylb</p><p>2.若A开头的为明文，M开头的为密文，则可得到skullisland</p><p>综上所述，第2种有明显意义，所以答案为skull island</p><p>珂欣说:“让我们去骷髅岛？可那里不是已经沦陷了？”</p><p>浩玥说:“我们不能失去诗吟，想办法一定要去救她！”</p><p>LL说:“基地里的装备应该足以抵御那里的变异物种了！”</p><p>三人立即收拾了装备以及物资前往了骷髅岛。</p>]]></content>
    
    
    <summary type="html">202103期全民挑战《地球保卫战》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="全民挑战" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
    
    <category term="全民挑战-解答" scheme="http://yoursite.com/tags/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>地球保卫战</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Challenge-Earth-Defense-Force/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Challenge-Earth-Defense-Force/</id>
    <published>2021-05-05T00:00:00.000Z</published>
    <updated>2021-05-05T14:31:14.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>时间:六十世纪</p><p>地点:地球</p><p>背景:能源危机，地球生灵涂炭。</p><p>团队:地球守护小组</p><p>LL，浩玥，珂欣三人在进行飞船的研制与新能源的研究。</p><p>LL说:“诗吟去哪了?”</p><p>珂欣说:“大概三小时前，超级电波就联系不上她了。”</p><p>浩玥说:“马上进入紧急状态，去诗吟家找她”</p><p>三人带上武器装备，立即前往诗吟家。可诗吟家中的景象让三人瞠目结舌，房间凌乱不堪，有过被入侵的迹象，在一番仔细搜査后，一个用高分子纳米科技的码锁被发现，LL熟练的输入了密码。里面存放着三张图片，三人便对着图片思索起来。“她一定是要告诉我们什么信息!”</p><img src="/assets/images/crimaster/2021/05/20210505-1.png" alt="图片" class="post-image half"><p>请找到正确的对照表格并解出数字所表达的一处地点。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入答案11个字母不区分大小写及空格</p>]]></content>
    
    
    <summary type="html">LL，浩玥，珂欣三人在进行飞船的研制与新能源的研究。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="全民挑战" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
    
    <category term="全民挑战" scheme="http://yoursite.com/tags/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>第一期测试题-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Challenge-Test-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Challenge-Test-Ans/</id>
    <published>2021-05-04T06:23:40.061Z</published>
    <updated>2021-05-04T06:37:13.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>狄仁杰</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>marple小姐，翻译成中文最为广泛的版本就是简・马普尔。</p><p>根据线索:在马普尔小姐的指示下。</p><p>简可拆分为三个字，竹，门，日。诗集主编为，两张图片右下有角标，分别是竹和日。按照写字顺序先竹，然后门，再者是日。</p><p>竹的图</p><img src="/assets/images/crimaster/2021/05/20210503-ans-1.png" alt="图片" class="post-image half"><p>下有一句话:字母化数，把marple在十六位字母表中的序号化出来得1311816125。接下来写”门”</p><p>诗有五首，我们把数字化成五份13/11/81/61/25。</p><p>与査询的古诗对应(在其中可能会拿数字有人去对应诗的题目，但是每一首诗都有说明作者，说明我们应该查询古诗)</p><img src="/assets/images/crimaster/2021/05/20210503-ans-2.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-ans-3.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-ans-4.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-ans-5.png" alt="图片" class="post-image half"><p>按照13/11/81/61/25尝试各种的方式对应，得出唯一合理的答案，不计算撇捺</p><p>接下来就是日的图片:</p><img src="/assets/images/crimaster/2021/05/20210503-ans-6.png" alt="图片" class="post-image half"><p>把不计算撇捺的方式带入进去:(笔画可以上各大搜索引擎查询，基本无异议</p><p>只:竖、横折、横、撇、点。</p><p>雁:橫、撇、撇、竖、撇、竖、点、横、横、橫、竖、横。</p><p>躁:竖、横折、横、竖、橫、竖、提、竖、横折、橫、竖、横折、横、竖、横折、横、横、竖、撇、捺。</p><p>年:撇、横、横、竖、横、竖。</p><p>靠:撇、横、竖、橫、竖、横折、横、竖、横、橫、橫、竖、横、横、横。</p><p>就:点、横、竖、橫折、横、竖钩、撇、点、橫、撇、竖弯钩、点。</p><p>思:竖、橫折、横、竖、横、点、斜钩、点、点。</p><p>民:横折、横、竖提、橫、斜钩。</p><p>去除撇捺，计算得:4.9.18.5.14.10.9.5。再次转 变成字母可得: DIRENJIE</p><p>答案即为狄仁杰。</p><p>我们中国著名的侦探例如宋慈，狄仁杰，包拯等，在历史上，他们是古代封建社会統治下平民的希望寄托。 </p><p>公正严明，铁面无私———包拯</p><p>公元676至679年，升为了大理寺寺丞，解決了大量积压的案件，涉案人员高达1.7万人，却没有任何人状告他判決有误———狄仁杰</p><p>中外法医界普遍认为是宋慈于公元1235年开创了“法医鉴定学”，因此宋慈被尊为世界法医学鼻祖———宋慈</p><p>我们向先人致敬。</p><p>同时，向马普尔小姐致敬。侦探精神不分年不分性别，不分国界，有的，只是你和我心中那份对推理的热爱。</p>]]></content>
    
    
    <summary type="html">202103期全民挑战《第一期测试题》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="全民挑战" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
    
    <category term="全民挑战-解答" scheme="http://yoursite.com/tags/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>第一期测试题</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Challenge-Test/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Challenge-Test/</id>
    <published>2021-05-03T00:00:00.000Z</published>
    <updated>2021-05-04T06:23:40.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>我收到了一份神秘的信件，貌似是一位我在网络上结识的好友给我发来的，希望大家帮我一同破解这一份神秘的信件。信件容如下:</p><p><font style="color:#D9730D">听说你是马普尔(Jane Marple)小姐的忠实粉丝，我也是。而且我也特别喜欢中华文化，希望通过你的帮助，在marple小姐的指示下，寻找 一位我同样喜欢的侦探。</font></p><p>信中附带一本诗集，名称为“<font style="color:#D9730D">门</font>”。内容如下：</p><p><font style="color:#D9730D">古朗月行(唐・李白)</font><br><font style="color:#D9730D">摸鱼儿·春光(宋・李裕翁)</font><br><font style="color:#D9730D">暗香日时月色(宋·姜)</font><br><font style="color:#D9730D">与孟郊洛北野泉上煎茶(唐·刘言史)</font><br><font style="color:#D9730D">颂古一首其一(宋・释师一)</font></p><p>还有两张纸条：</p><img src="/assets/images/crimaster/2021/05/20210503-1.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-2.png" alt="图片" class="post-image half"><p>图下有一行字:<font style="color:#D9730D">字母化数</font></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入一位人物名称 （例:野田吴）</p>]]></content>
    
    
    <summary type="html">我收到了一份神秘的信件，貌似是一位我在网络上结识的好友给我发来的，希望大家帮我一同破解这一份神秘的信件。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="全民挑战" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
    
    <category term="全民挑战" scheme="http://yoursite.com/tags/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>【转】字节跳动最爱考的64道算法题(JS版)</title>
    <link href="http://yoursite.com/2021/05/byte-dance-top-64-algorithm-problems-js-version/"/>
    <id>http://yoursite.com/2021/05/byte-dance-top-64-algorithm-problems-js-version/</id>
    <published>2021-05-02T00:00:00.000Z</published>
    <updated>2021-05-03T14:44:13.137Z</updated>
    
    <content type="html"><![CDATA[<p>本文来源于图雀社区，作者一只图雀。<br>原文链接： <a href="https://mp.weixin.qq.com/s/HsZo757NDNV-3xnGQjPtAQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HsZo757NDNV-3xnGQjPtAQ</a></p><p><font style="color:#D9730D">欢迎关注公众号：图雀社区。 如果你想从零开始以实战的方式学习一门技术，亦或是想动手做一个比较完整的项目以准备面试，相信 「图雀社区」 的内容都能够帮助到你，成为初入前端的你成长路上的指南针。</font></p><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>现在大厂面试中，算法题几乎为必考项，且近几年频现 LeetCode 真题，此篇为拿到字节、腾讯、京东 Offer 的笔者本人在准备面试过程中亲自刷过以及遇到过高频算法题。文章内容会分模块整理，对于笔者在面试过程中遇到的真题，会给予着重 【🔥】标出。</p><p>同时，可以毫不客气的说，如果你准备时间有限，又想追求算法题准备效率最大化，那么你只需要按照大纲把下面的题目刷完，并把代码烂熟于心，就几乎可以应对 90% 的面试算法考题了。</p><p>整理这篇内容的目的一个是笔者在之前准备面试时的一点积累，而它确实也帮助笔者在面试算法题中过关斩将，同时呢，也希望能够在金三银四给予拼搏的你，一点点帮助就好！💪</p><p>本篇内容包括如下模块：</p><ul><li>高频算法题系列：链表</li><li>高频算法题系列：字符串【🔥】【有真题】</li><li>高频算法题系列：数组问题【🔥】【有真题】</li><li>高频算法题系列：二叉树</li><li>高频算法题系列：排序算法【🔥】</li><li>高频算法题系列：二分查找【🔥】</li><li>高频算法题系列：动态规划【🔥】</li><li>高频算法题系列：BFS</li><li>高频算法题系列：栈【🔥】</li><li>高频算法题系列：DFS【🔥】</li><li>高频算法题系列：回溯算法【🔥】</li></ul><p>其中标🔥的部分代表非常高频的考题，其中不乏笔者遇到的原题。其中对于每一类，首先会列出包含的考题，然后针对每一道考题会给出难度、考察知识点、是否是面试真题，在每道题详细介绍时，还会给出每道题的 LeetCode 链接，帮助读者理解题意，以及能够进行实际的测验，还可以观看其他人的答案，更好的帮助准备。</p><h1 id="高频算法题系列：链表"><a href="#高频算法题系列：链表" class="headerlink" title="高频算法题系列：链表"></a>高频算法题系列：链表</h1><p>笔者遇到的高频链表题主要包含这几道：</p><ul><li>通过快慢指针寻找链表中点 【简单】</li><li>通过链表的后续遍历判断回文链表问题 【简单】</li><li>链表的反向输出 【简单】</li><li>合并 K 个升序链表 【困难】</li><li>K个一组翻转链表 【困难】</li><li>环形链表 【简单】</li><li>排序链表 【中等】</li><li>相交链表 【简单】</li></ul><h2 id="寻找链表中点"><a href="#寻找链表中点" class="headerlink" title="寻找链表中点"></a>寻找链表中点</h2><p>题解</p><p>通过快慢指针寻找链表中点</p><pre><code class="javascript">function findCenter(head) {  let slower = head, faster = head;  while (faster &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;  }  // 如果 faster 不等于 null，说明是奇数个，slower 再移动一格  if (faster != null) {    slower = slower.next;  }  return slower;}</code></pre><h2 id="前序遍历判断回文链表"><a href="#前序遍历判断回文链表" class="headerlink" title="前序遍历判断回文链表"></a>前序遍历判断回文链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234 回文链表（简单）</a><sup>[1]</sup></p><p>题解1</p><p>利用链表的后续遍历，使用函数调用栈作为后序遍历栈，来判断是否回文</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {boolean} */var isPalindrome = function (head) {  let left = head;  function traverse(right) {    if (right == null) return true;    let res = traverse(right.next);    res = res &amp;&amp; (right.val === left.val);    left = left.next;    return res;  }  return traverse(head);};</code></pre><p>题解2</p><p>通过快、慢指针找链表中点，然后反转链表，比较两个链表两侧是否相等，来判断是否是回文链表</p><pre><code class="javascript">var isPalindrome = function (head) {  // 反转 slower 链表  let right = reverse(findCenter(head));  let left = head;  // 开始比较  while (right != null) {    if (left.val !== right.val) {      return false;    }    left = left.next;    right = right.next;  }  return true;}function findCenter(head) {  let slower = head, faster = head;  while (faster &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;  }  // 如果 faster 不等于 null，说明是奇数个，slower 再移动一格  if (faster != null) {    slower = slower.next;  }  return slower;}function reverse(head) {  let prev = null, cur = head, nxt = head;  while (cur != null) {    nxt = cur.next;    cur.next = prev;    prev = cur;    cur = nxt;  }  return prev;}</code></pre><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206 反转链表（简单）</a><sup>[2]</sup></p><p>题解1</p><p>迭代</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function (head) {  let prev = null, curr = head  while (curr) {    const node = curr.next    curr.next = prev    prev = curr    curr = node  }  return prev};</code></pre><p>解题2</p><p>递归</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function (head) {  if (head == null || head.next == null) return head;  let last = reverseList(head.next);  head.next.next = head;  head.next = null;  return last;};</code></pre><h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23 合并K个升序链表（困难）</a><sup>[3]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode[]} lists * @return {ListNode} */var mergeKLists = function (lists) {    if (lists.length === 0) return null;    return mergeArr(lists);};function mergeArr(lists) {    if (lists.length &lt;= 1) return lists[0];    let index = Math.floor(lists.length / 2);    const left = mergeArr(lists.slice(0, index))    const right = mergeArr(lists.slice(index));    return merge(left, right);}function merge(l1, l2) {    if (l1 == null &amp;&amp; l2 == null) return null;    if (l1 != null &amp;&amp; l2 == null) return l1;    if (l1 == null &amp;&amp; l2 != null) return l2;    let newHead = null, head = null;    while (l1 != null &amp;&amp; l2 != null) {        if (l1.val &lt; l2.val) {            if (!head) {                newHead = l1;                head = l1;            } else {                newHead.next = l1;                newHead = newHead.next;            }            l1 = l1.next;        } else {            if (!head) {                newHead = l2;                head = l2;            } else {                newHead.next = l2;                newHead = newHead.next;            }            l2 = l2.next;        }    }    newHead.next = l1 ? l1 : l2;    return head;}</code></pre><h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25 K 个一组翻转链表（困难）</a><sup>[4]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @param {number} k * @return {ListNode} */var reverseKGroup = function (head, k) {    let a = head, b = head;    for (let i = 0; i &lt; k; i++) {        if (b == null) return head;        b = b.next;    }    const newHead = reverse(a, b);    a.next = reverseKGroup(b, k);    return newHead;};function reverse(a, b) {    let prev = null, cur = a, nxt = a;    while (cur != b) {        nxt = cur.next;        cur.next = prev;        prev = cur;        cur = nxt;    }    return prev;}</code></pre><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141 环形链表（简单）</a><sup>[5]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @return {boolean} */var hasCycle = function (head) {  if (head == null || head.next == null) return false;  let slower = head, faster = head;  while (faster != null &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;    if (slower === faster) return true;  }  return false;};</code></pre><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148 排序链表（中等）</a><sup>[6]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var sortList = function (head) {  if (head == null) return null;  let newHead = head;  return mergeSort(head);};function mergeSort(head) {  if (head.next != null) {    let slower = getCenter(head);    let nxt = slower.next;    slower.next = null;    // console.log(head, slower, nxt);    const left = mergeSort(head);    const right = mergeSort(nxt);    head = merge(left, right);  }  return head;}function merge(left, right) {  let newHead = null, head = null;  while (left != null &amp;&amp; right != null) {    if (left.val &lt; right.val) {      if (!head) {        newHead = left;        head = left;      } else {        newHead.next = left;        newHead = newHead.next;      }      left = left.next;    } else {      if (!head) {        newHead = right;        head = right;      } else {        newHead.next = right;        newHead = newHead.next;      }      right = right.next;    }  }  newHead.next = left ? left : right;  return head;}function getCenter(head) {  let slower = head, faster = head.next;  while (faster != null &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;  }  return slower;}</code></pre><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160 相交链表（简单）</a><sup>[7]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} headA * @param {ListNode} headB * @return {ListNode} */var getIntersectionNode = function (headA, headB) {    let lastHeadA = null;    let lastHeadB = null;    let originHeadA = headA;    let originHeadB = headB;    if (!headA || !headB) {        return null;    }    while (true) {        if (headB == headA) {            return headB;        }        if (headA &amp;&amp; headA.next == null) {            lastHeadA = headA;            headA = originHeadB;        } else {            headA = headA.next;        }        if (headB &amp;&amp; headB.next == null) {            lastHeadB = headB            headB = originHeadA;        } else {            headB = headB.next;        }        if (lastHeadA &amp;&amp; lastHeadB &amp;&amp; lastHeadA != lastHeadB) {            return null;        }    }    return null;};</code></pre><h1 id="高频算法题系列：字符串【🔥】"><a href="#高频算法题系列：字符串【🔥】" class="headerlink" title="高频算法题系列：字符串【🔥】"></a>高频算法题系列：字符串【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>最长回文子串 【中等】【双指针】【面试真题】</li><li>最长公共前缀 【简单】【双指针】</li><li>无重复字符的最长子串【中等】【双指针】</li><li>最小覆盖子串 【困难】【滑动窗口】【面试真题】</li></ul><h2 id="【面试真题】最长回文子串【双指针】"><a href="#【面试真题】最长回文子串【双指针】" class="headerlink" title="【面试真题】最长回文子串【双指针】"></a>【面试真题】最长回文子串【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5 最长回文子串（中等）</a><sup>[8]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {string} */var longestPalindrome = function (s) {          if (s.length === 1) return s;          let maxRes = 0, maxStr = '';          for (let i = 0; i &lt; s.length; i++) {            let str1 = palindrome(s, i, i);            let str2 = palindrome(s, i, i + 1);            if (str1.length &gt; maxRes) {              maxStr = str1;              maxRes = str1.length;            }            if (str2.length &gt; maxRes) {              maxStr = str2;              maxRes = str2.length;            }          }          return maxStr;        };function palindrome(s, l, r) {  while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s[l] === s[r]) {    l--;    r++;  }  return s.slice(l + 1, r);}</code></pre><h2 id="最长公共前缀【双指针】"><a href="#最长公共前缀【双指针】" class="headerlink" title="最长公共前缀【双指针】"></a>最长公共前缀【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14 最长公共前缀（简单）</a><sup>[9]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string[]} strs * @return {string} */var longestCommonPrefix = function (strs) {    if (strs.length === 0) return "";    let first = strs[0];    if (first === "") return "";    let minLen = Number.MAX_SAFE_INTEGER;    for (let i = 1; i &lt; strs.length; i++) {        const len = twoStrLongestCommonPrefix(first, strs[i]);        minLen = Math.min(len, minLen);    }    return first.slice(0, minLen);};function twoStrLongestCommonPrefix(s, t) {    let i = 0, j = 0;    let cnt = 0;    while (i &lt; s.length &amp;&amp; j &lt; t.length) {        console.log(s[i], t[j], cnt)        if (s[i] === t[j]) {            cnt++;        } else {            return cnt;        }        i++;        j++;    }    return cnt;}</code></pre><h2 id="无重复字符的最长子串【双指针】"><a href="#无重复字符的最长子串【双指针】" class="headerlink" title="无重复字符的最长子串【双指针】"></a>无重复字符的最长子串【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3 无重复字符的最长子串（中等）</a><sup>[10]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function (s) {    let window = {};    let left = 0, right = 0;    let maxLen = 0, maxStr = '';    while (right &lt; s.length) {        let c = s[right];        right++;        if (window[c]) window[c]++;        else window[c] = 1        while (window[c] &gt; 1) {            let d = s[left];            left++;            window[d]--;        }        if (maxLen &lt; right - left) {            maxLen = right - left;        }    }    return maxLen;};</code></pre><h2 id="【面试真题】-最小覆盖子串【滑动窗口】"><a href="#【面试真题】-最小覆盖子串【滑动窗口】" class="headerlink" title="【面试真题】 最小覆盖子串【滑动窗口】"></a>【面试真题】 最小覆盖子串【滑动窗口】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76 最小覆盖子串（困难）</a><sup>[11]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @param {string} t * @return {string} */var minWindow = function (s, t) {    let need = {}, window = {};    for (let c of t) {        if (!need[c]) need[c] = 1;        else need[c]++;    }    let left = 0, right = 0;    let valid = 0, len = Object.keys(need).length;    let minLen = s.length + 1, minStr = '';    while (right &lt; s.length) {        const d = s[right];        right++;        if (!window[d]) window[d] = 1;        else window[d]++;        if (need[d] &amp;&amp; need[d] === window[d]) {            valid++;        }        console.log('left - right', left, right);        while (valid === len) {            if (right - left &lt; minLen) {                minLen = right - left;                minStr = s.slice(left, right);            }            console.lo            let c = s[left];            left++;            window[c]--;            if (need[c] &amp;&amp; window[c] &lt; need[c]) {                valid--;            }        }    }    return minStr;};</code></pre><h1 id="高频算法题系列：数组问题【🔥】"><a href="#高频算法题系列：数组问题【🔥】" class="headerlink" title="高频算法题系列：数组问题【🔥】"></a>高频算法题系列：数组问题【🔥】</h1><p>主要有几类高频考题：</p><ul><li>俄罗斯套娃信封问题【困难】【排序+最长上升子序列】【面试真题】</li><li>最长连续递增序列 【简单】【双指针】</li><li>最长连续序列【困难】【哈希表】</li><li>盛最多水的容器【困难】【面试真题】</li><li>寻找两个正序数组的中位数【困难】【双指针】</li><li>删除有序数组中的重复项【简单】【快慢指针】</li><li>和为K的子数组【中等】【哈希表】</li><li>nSum 问题【系列】【简单】【哈希表】</li><li>接雨水【困难】【暴力+备忘录优化】【面试真题】</li><li>跳跃游戏【系列】【中等】【贪心算法】</li></ul><h2 id="【面试真题】俄罗斯套娃信封问题【排序-最长上升子序列】"><a href="#【面试真题】俄罗斯套娃信封问题【排序-最长上升子序列】" class="headerlink" title="【面试真题】俄罗斯套娃信封问题【排序+最长上升子序列】"></a>【面试真题】俄罗斯套娃信封问题【排序+最长上升子序列】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354 俄罗斯套娃信封问题（困难）</a><sup>[12]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} envelopes * @return {number} */var maxEnvelopes = function (envelopes) {    if (envelopes.length === 1) return 1;    envelopes.sort((a, b) =&gt; {        if (a[0] !== b[0]) return a[0] - b[0];        else return b[1] - a[1];    });    let LISArr = [];    for (let [key, value] of envelopes) {        LISArr.push(value);    }    console.log(LISArr);    return LIS(LISArr);};function LIS(arr) {    let dp = [];    let maxAns = 0;    for (let i = 0; i &lt; arr.length; i++) {        dp[i] = 1;    }    for (let i = 1; i &lt; arr.length; i++) {        for (let j = i; j &gt;= 0; j--) {            if (arr[i] &gt; arr[j]) {                dp[i] = Math.max(dp[i], dp[j] + 1)            }            maxAns = Math.max(maxAns, dp[i]);        }    }    return maxAns;}</code></pre><h2 id="最长连续递增序列【快慢指针】"><a href="#最长连续递增序列【快慢指针】" class="headerlink" title="最长连续递增序列【快慢指针】"></a>最长连续递增序列【快慢指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674 最长连续递增序列（简单）</a><sup>[13]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var findLengthOfLCIS = function (nums) {    if (nums.length === 0) return 0;    const n = nums.length;    let left = 0, right = 1;    let globalMaxLen = 1, maxLen = 1;    while (right &lt; n) {        if (nums[right] &gt; nums[left]) maxLen++;        else {            maxLen = 1;        }        left++;        right++;        globalMaxLen = Math.max(globalMaxLen, maxLen);    }    return globalMaxLen;};</code></pre><h2 id="最长连续序列-【哈希表】"><a href="#最长连续序列-【哈希表】" class="headerlink" title="最长连续序列 【哈希表】"></a>最长连续序列 【哈希表】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128 最长连续序列（困难）</a><sup>[14]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var longestConsecutive = function (nums) {    if (nums.length === 0) return 0;    const set = new Set(nums);    const n = nums.length;    let globalLongest = 1;    for (let i = 0; i &lt; n; i++) {        if (!set.has(nums[i] - 1)) {            let longest = 1;            let currentNum = nums[i];            while (set.has(currentNum + 1)) {                currentNum += 1;                longest++;            }            globalLongest = Math.max(globalLongest, longest);        }    }    return globalLongest;};</code></pre><h2 id="【面试真题】盛最多水的容器【哈希表】"><a href="#【面试真题】盛最多水的容器【哈希表】" class="headerlink" title="【面试真题】盛最多水的容器【哈希表】"></a>【面试真题】盛最多水的容器【哈希表】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11 盛最多水的容器（中等）</a><sup>[15]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} height * @return {number} */var maxArea = function (height) {    let n = height.length;    let left = 0, right = n - 1;    let maxOpacity = 0;    while (left &lt; right) {        let res = Math.min(height[left], height[right]) * (right - left);        maxOpacity = Math.max(maxOpacity, res);        if (height[left] &lt; height[right]) left++        else right--;    }    return maxOpacity;};</code></pre><h2 id="寻找两个正序数组的中位数【双指针】"><a href="#寻找两个正序数组的中位数【双指针】" class="headerlink" title="寻找两个正序数组的中位数【双指针】"></a>寻找两个正序数组的中位数【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4 寻找两个正序数组的中位数（困难）</a><sup>[16]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */var findMedianSortedArrays = function (nums1, nums2) {    let m = nums1.length, n = nums2.length;    let i = 0, j = 0;    let newArr = [];    while (i &lt; m &amp;&amp; j &lt; n) {        if (nums1[i] &lt; nums2[j]) {            newArr.push(nums1[i++]);        } else {            newArr.push(nums2[j++]);        }    }    newArr = newArr.concat(i &lt; m ? nums1.slice(i) : nums2.slice(j));    const len = newArr.length;    console.log(newArr)    if (len % 2 === 0) {        return (newArr[len / 2] + newArr[len / 2 - 1]) / 2;    } else {        return newArr[Math.floor(len / 2)];    }};</code></pre><h2 id="删除有序数组中的重复项【快慢指针】"><a href="#删除有序数组中的重复项【快慢指针】" class="headerlink" title="删除有序数组中的重复项【快慢指针】"></a>删除有序数组中的重复项【快慢指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26 删除有序数组中的重复项（简单）</a><sup>[17]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var removeDuplicates = function (nums) {    if (nums.length &lt;= 1) return nums.length;    let lo = 0, hi = 0;    while (hi &lt; nums.length) {        while (nums[lo] === nums[hi] &amp;&amp; hi &lt; nums.length) hi++;        if (nums[lo] !== nums[hi] &amp;&amp; hi &lt; nums.length) {            lo++;            nums[lo] = nums[hi];        }        hi++;    }    return lo + 1;};</code></pre><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">695 岛屿的最大面积（中等）</a><sup>[18]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} grid * @return {number} */let maxX, maxY;let visited;let globalMaxArea;var maxAreaOfIsland = function (grid) {    visited = new Set();    maxX = grid.length;    maxY = grid[0].length;    globalMaxArea = 0;    for (let i = 0; i &lt; maxX; i++) {        for (let j = 0; j &lt; maxY; j++) {            if (grid[i][j] === 1) {                visited.add(`(${i}, ${j})`);                globalMaxArea = Math.max(globalMaxArea, dfs(grid, i, j));            }            visited.clear();        }    }    return globalMaxArea;};function dfs(grid, x, y) {    let res = 1;    for (let i = -1; i &lt;= 1; i++) {        for (let j = -1; j &lt;= 1; j++) {            if (Math.abs(i) === Math.abs(j)) continue;            const newX = x + i;            const newY = y + j;            if (newX &gt;= maxX || newX &lt; 0 || newY &gt;= maxY || newY &lt; 0) continue;            if (visited.has(`(${newX}, ${newY})`)) continue;            visited.add(`(${newX}, ${newY})`);            const areaCnt = grid[newX][newY]            if (areaCnt === 1) {                const cnt = dfs(grid, newX, newY);                res += cnt;            }        }    }    return res;}</code></pre><h2 id="和为K的子数组【哈希表】"><a href="#和为K的子数组【哈希表】" class="headerlink" title="和为K的子数组【哈希表】"></a>和为K的子数组【哈希表】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560 和为K的子数组（中等）</a><sup>[19]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @param {number} k * @return {number} */var subarraySum = function (nums, k) {    let cnt = 0;    let sum0_i = 0, sum0_j = 0;    let map = new Map();    map.set(0, 1);    for (let i = 0; i &lt;= nums.length; i++) {        sum0_i += nums[i];        sum0_j = sum0_i - k;        console.log('map', sum0_j, map.get(sum0_j))        if (map.has(sum0_j)) {            cnt += map.get(sum0_j);        }        let sumCnt = map.get(sum0_i) || 0;        map.set(sum0_i, sumCnt + 1);    }    return cnt;};</code></pre><h2 id="nSum问题【哈希表】【系列】"><a href="#nSum问题【哈希表】【系列】" class="headerlink" title="nSum问题【哈希表】【系列】"></a>nSum问题【哈希表】【系列】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1 两数之和（简单）</a><sup>[20]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167 两数之和 II - 输入有序数组（简单）</a><sup>[21]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15 三数之和（中等）</a><sup>[22]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18 四数之和（中等）</a><sup>[23]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题。</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @param {number} target * @return {number[]} */var twoSum = function (nums, target) {    let map2 = new Map();    for (let i = 0; i &lt; nums.length; i++) {        map2.set(nums[i], i);    }    for (let i = 0; i &lt; nums.length; i++) {        if (map2.has(target - nums[i]) &amp;&amp; map2.get(target - nums[i]) !== i) return [i, map2.get(target - nums[i])]    }};</code></pre><h2 id="接雨水【暴力-备忘录优化】"><a href="#接雨水【暴力-备忘录优化】" class="headerlink" title="接雨水【暴力+备忘录优化】"></a>接雨水【暴力+备忘录优化】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42 接雨水（困难）</a><sup>[24]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} height * @return {number} */var trap = function (height) {    let l_max = [], r_max = [];    let len = height.length;    let maxCapacity = 0;    for (let i = 0; i &lt; len; i++) {        l_max[i] = height[i];        r_max[i] = height[i];    }    for (let i = 1; i &lt; len; i++) {        l_max[i] = Math.max(l_max[i - 1], height[i]);    }    for (let j = len - 2; j &gt;= 0; j--) {        r_max[j] = Math.max(r_max[j + 1], height[j]);    }    for (let i = 0; i &lt; len; i++) {        maxCapacity += Math.min(l_max[i], r_max[i]) - height[i];    }    return maxCapacity;};</code></pre><h2 id="跳跃游戏【贪心算法】【系列】"><a href="#跳跃游戏【贪心算法】【系列】" class="headerlink" title="跳跃游戏【贪心算法】【系列】"></a>跳跃游戏【贪心算法】【系列】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55 跳跃游戏（中等）</a><sup>[25]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45 跳跃游戏 II（中等）</a><sup>[26]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题。</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {boolean} */var canJump = function(nums) {    let faster = 0;    for (let i = 0; i &lt; nums.length - 1; i++) {        faster = Math.max(faster, i + nums[i]);        if (faster &lt;= i) return false;    }    return faster &gt;= nums.length - 1;};</code></pre><h1 id="高频算法题系列：二叉树"><a href="#高频算法题系列：二叉树" class="headerlink" title="高频算法题系列：二叉树"></a>高频算法题系列：二叉树</h1><p>主要有以下几类高频考题：</p><ul><li>二叉树的最近公共祖先【简单】【二叉树】</li><li>二叉搜索树中的搜索【简单】【二叉树】</li><li>删除二叉搜索树中的节点【中等】【二叉树】</li><li>完全二叉树的节点个数【中等】【二叉树】</li><li>二叉树的锯齿形层序遍历【中等】【二叉树】</li></ul><h2 id="二叉树的最近公共祖先【二叉树】"><a href="#二叉树的最近公共祖先【二叉树】" class="headerlink" title="二叉树的最近公共祖先【二叉树】"></a>二叉树的最近公共祖先【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236 二叉树的最近公共祖先（简单）</a><sup>[27]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} */let visited;let parent;var lowestCommonAncestor = function (root, p, q) {  visited = new Set();  parent = new Map();  dfs(root);  while (p != null) {    visited.add(p.val);    p = parent.get(p.val);  }  while (q != null) {    if (visited.has(q.val)) {      return q;    }    q = parent.get(q.val);  }  return null;};function dfs(root) {  if (root.left != null) {    parent.set(root.left.val, root);    dfs(root.left);  }  if (root.right != null) {    parent.set(root.right.val, root);    dfs(root.right);  }}</code></pre><h2 id="二叉搜索树中的搜索【二叉树】"><a href="#二叉搜索树中的搜索【二叉树】" class="headerlink" title="二叉搜索树中的搜索【二叉树】"></a>二叉搜索树中的搜索【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700 二叉搜索树中的搜索（简单）</a><sup>[28]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {number} val * @return {TreeNode} */var searchBST = function (root, val) {    if (root == null) return null;    if (root.val === val) return root;    if (root.val &gt; val) {        return searchBST(root.left, val);    } else if (root.val &lt; val) {        return searchBST(root.right, val);    }};</code></pre><h2 id="删除二叉搜索树中的节点【二叉树】"><a href="#删除二叉搜索树中的节点【二叉树】" class="headerlink" title="删除二叉搜索树中的节点【二叉树】"></a>删除二叉搜索树中的节点【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450 删除二叉搜索树中的节点（中等）</a><sup>[29]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {number} key * @return {TreeNode} */var deleteNode = function (root, key) {    if (root == null) return null;    if (root.val === key) {        if (root.left == null &amp;&amp; root.right == null) return null;        if (root.left == null) return root.right;        if (root.right == null) return root.left;        if (root.left != null &amp;&amp; root.right != null) {            let target = getMinTreeMaxNode(root.left);            root.val = target.val;            root.left = deleteNode(root.left, target.val);        }    }    if (root.val &lt; key) {        root.right = deleteNode(root.right, key);    } else if (root.val &gt; key) {        root.left = deleteNode(root.left, key);    }    return root;};function getMinTreeMaxNode(root) {    if (root.right == null) return root;    return getMinTreeMaxNode(root.right);}</code></pre><h2 id="完全二叉树的节点个数【二叉树】"><a href="#完全二叉树的节点个数【二叉树】" class="headerlink" title="完全二叉树的节点个数【二叉树】"></a>完全二叉树的节点个数【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222 完全二叉树的节点个数（中等）</a><sup>[30]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */var countNodes = function (root) {    if (root == null) return 0;    let l = root, r = root;    let lh = 0, rh = 0;    while (l != null) {        l = l.left;        lh++;    }    while (r != null) {        r = r.right;        rh++;    }    if (lh === rh) {        return Math.pow(2, lh) - 1;    }    return 1 + countNodes(root.left) + countNodes(root.right);};</code></pre><h2 id="二叉树的锯齿形层序遍历【二叉树】"><a href="#二叉树的锯齿形层序遍历【二叉树】" class="headerlink" title="二叉树的锯齿形层序遍历【二叉树】"></a>二叉树的锯齿形层序遍历【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103 二叉树的锯齿形层序遍历（中等）</a><sup>[31]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[][]} */let res;var zigzagLevelOrder = function (root) {    if (root == null) return [];    res = [];    BFS(root, true);    return res;};function BFS(root, inOrder) {    let arr = [];    let resItem = [];    let node;    let stack1 = new Stack();    let stack2 = new Stack();    // 判断交换时机    let flag;    stack1.push(root);    res.push([root.val]);    inOrder = !inOrder;    while (!stack1.isEmpty() || !stack2.isEmpty()) {        if (stack1.isEmpty()) {            flag = 'stack1';        } else if (stack2.isEmpty()) {            flag = 'stack2';        }        // 决定取那个栈里面的元素        if (flag === 'stack2' &amp;&amp; !stack1.isEmpty()) node = stack1.pop();        else if (flag === 'stack1' &amp;&amp; !stack2.isEmpty()) node = stack2.pop();        if (inOrder) {            if (node.left) {                if (flag === 'stack1') {                    stack1.push(node.left);                } else {                    stack2.push(node.left);                }                resItem.push(node.left.val);            }            if (node.right) {                if (flag === 'stack1') {                    stack1.push(node.right);                } else {                    stack2.push(node.right);                }                resItem.push(node.right.val);            }        } else {            if (node.right) {                if (flag === 'stack1') {                    stack1.push(node.right);                } else {                    stack2.push(node.right);                }                resItem.push(node.right.val);            }            if (node.left) {                if (flag === 'stack1') {                    stack1.push(node.left);                } else {                    stack2.push(node.left);                }                resItem.push(node.left.val);            }        }        // 判断下次翻转的时机        if ((flag === 'stack2' &amp;&amp; stack1.isEmpty()) || (flag === 'stack1' &amp;&amp; stack2.isEmpty())) {            inOrder = !inOrder;            // 需要翻转了，就加一轮值            if (resItem.length &gt; 0) {                res.push(resItem);            }            resItem = [];        }    }}class Stack {    constructor() {        this.count = 0;        this.items = [];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return undefined;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    size() {        return this.count;    }    isEmpty() {        return this.size() === 0;    }}</code></pre><h1 id="高频算法题系列：排序算法【🔥】"><a href="#高频算法题系列：排序算法【🔥】" class="headerlink" title="高频算法题系列：排序算法【🔥】"></a>高频算法题系列：排序算法【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>用最少数量的箭引爆气球【中等】【排序】</li><li>合并区间【中等】【排序算法+区间问题】【面试真题】</li></ul><h2 id="用最少数量的箭引爆气球【排序算法】"><a href="#用最少数量的箭引爆气球【排序算法】" class="headerlink" title="用最少数量的箭引爆气球【排序算法】"></a>用最少数量的箭引爆气球【排序算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452 用最少数量的箭引爆气球（中等）</a><sup>[32]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} points * @return {number} */var findMinArrowShots = function (points) {    if (points.length === 0) return 0;    points.sort((a, b) =&gt; a[1] - b[1]);    let cnt = 1;    let resArr = [points[0]];    let curr, last;    for (let i = 1; i &lt; points.length; i++) {        curr = points[i];        last = resArr[resArr.length - 1];        if (curr[0] &gt; last[1]) {            resArr.push(curr);            cnt++;        }    }    return cnt;};</code></pre><h2 id="合并区间【排序算法-区间问题】"><a href="#合并区间【排序算法-区间问题】" class="headerlink" title="合并区间【排序算法+区间问题】"></a>合并区间【排序算法+区间问题】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56 合并区间（中等）</a><sup>[33]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} intervals * @return {number[][]} */var merge = function (intervals) {    if (intervals.length === 0) return [];    intervals.sort((a, b) =&gt; a[0] - b[0]);    let mergeArr = [intervals[0]];    let last, curr;    for (let j = 1; j &lt; intervals.length; j++) {        last = mergeArr[mergeArr.length - 1];        curr = intervals[j];        if (last[1] &gt;= curr[0]) {            last[1] = Math.max(curr[1], last[1]);        } else {            mergeArr.push(curr);        }    }    return mergeArr;};</code></pre><h1 id="高频算法题系列：二分查找"><a href="#高频算法题系列：二分查找" class="headerlink" title="高频算法题系列：二分查找"></a>高频算法题系列：二分查找</h1><p>主要有以下几类高频考题：</p><ul><li>寻找两个正序数组的中位数【困难】【二分查找】</li><li>判断子序列【简单】【二分查找】</li><li>在排序数组中查找元素的第一个和最后一个位置【中等】【二分查找】</li></ul><h2 id="寻找两个正序数组的中位数【二分查找】"><a href="#寻找两个正序数组的中位数【二分查找】" class="headerlink" title="寻找两个正序数组的中位数【二分查找】"></a>寻找两个正序数组的中位数【二分查找】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4 寻找两个正序数组的中位数（困难）</a><sup>[34]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */var findMedianSortedArrays = function (nums1, nums2) {    let m = nums1.length, n = nums2.length;    let i = 0, j = 0;    let newArr = [];    while (i &lt; m &amp;&amp; j &lt; n) {        if (nums1[i] &lt; nums2[j]) {            newArr.push(nums1[i++]);        } else {            newArr.push(nums2[j++]);        }    }    newArr = newArr.concat(i &lt; m ? nums1.slice(i) : nums2.slice(j));    const len = newArr.length;    console.log(newArr)    if (len % 2 === 0) {        return (newArr[len / 2] + newArr[len / 2 - 1]) / 2;    } else {        return newArr[Math.floor(len / 2)];    }};</code></pre><h2 id="判断子序列【二分查找】"><a href="#判断子序列【二分查找】" class="headerlink" title="判断子序列【二分查找】"></a>判断子序列【二分查找】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392 判断子序列（简单）</a><sup>[35]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @param {string} t * @return {boolean} */var isSubsequence = function (s, t) {    let hash = {};    for (let i = 0; i &lt; t.length; i++) {        if (!hash[t[i]]) hash[t[i]] = [];        hash[t[i]].push(i);    }    let lastMaxIndex = 0;    for (let i = 0; i &lt; s.length; i++) {        if (hash[s[i]]) {            const index = binarySearch(hash[s[i]], lastMaxIndex);            console.log('index', index, hash[s[i]]);            if (index === -1) return false;            lastMaxIndex = hash[s[i]][index] + 1;        } else return false;    }    return true;};function binarySearch(array, targetIndex) {    let left = 0, right = array.length;    while (left &lt; right) {        let mid = left + Math.floor((right - left) / 2);        if (array[mid] &gt;= targetIndex) {            right = mid;        } else if (array[mid] &lt; targetIndex) {            left = mid + 1;        }    }    if (left &gt;= array.length || array[left] &lt; targetIndex) return -1;    return left;}</code></pre><h2 id="在排序数组中查找元素的第一个和最后一个位置【二分搜索】"><a href="#在排序数组中查找元素的第一个和最后一个位置【二分搜索】" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置【二分搜索】"></a>在排序数组中查找元素的第一个和最后一个位置【二分搜索】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34 在排序数组中查找元素的第一个和最后一个位置（中等）</a><sup>[36]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @param {number} target * @return {number[]} */var searchRange = function (nums, target) {    const left = leftBound(nums, target);    const right = rightBound(nums, target);    return [left, right];};function leftBound(nums, target) {    let left = 0;    let right = nums.length - 1;    while (left &lt;= right) {        let mid = Math.floor(left + (right - left) / 2);        if (nums[mid] === target) {            right = mid - 1;        } else if (nums[mid] &lt; target) {            left = mid + 1;        } else if (nums[mid] &gt; target) {            right = mid - 1;        }    }    if (left &gt;= nums.length || nums[left] !== target) {        return -1;    }    return left;}function rightBound(nums, target) {    let left = 0;    let right = nums.length - 1;    while (left &lt;= right) {        let mid = Math.floor(left + (right - left) / 2);        if (nums[mid] === target) {            left = mid + 1;        } else if (nums[mid] &lt; target) {            left = mid + 1;        } else if (nums[mid] &gt; target) {            right = mid - 1;        }    }    if (right &lt; 0 || nums[right] !== target) {        return -1;    }    return right;}</code></pre><h1 id="高频算法题系列：动态规划【🔥】"><a href="#高频算法题系列：动态规划【🔥】" class="headerlink" title="高频算法题系列：动态规划【🔥】"></a>高频算法题系列：动态规划【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>最长递增子序列【中等】【动态规划】</li><li>零钱兑换【中等】【动态规划】【面试真题】</li><li>最长公共子序列 【中等】【动态规划】【面试真题】</li><li>编辑距离 【困难】【动态规划】</li><li>最长回文子序列【中等】【动态规划】【面试真题】</li><li>最大子序和【简单】【动态规划】【面试真题】</li><li>买卖股票的最佳时机系列【系列】【动态规划】【面试真题】</li></ul><h2 id="最长递增子序列【动态规划】"><a href="#最长递增子序列【动态规划】" class="headerlink" title="最长递增子序列【动态规划】"></a>最长递增子序列【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300 最长递增子序列（中等）</a><sup>[37]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var lengthOfLIS = function (nums) {    let maxLen = 0, n = nums.length;    let dp = [];    for (let i = 0; i &lt; n; i++) {        dp[i] = 1;    }    for (let i = 0; i &lt; n; i++) {        for (let j = 0; j &lt; i; j++) {            if (nums[i] &gt; nums[j]) {                dp[i] = Math.max(dp[i], dp[j] + 1);            }        }        maxLen = Math.max(maxLen, dp[i]);    }    return maxLen;};</code></pre><h2 id="【面试真题】-零钱兑换【动态规划】"><a href="#【面试真题】-零钱兑换【动态规划】" class="headerlink" title="【面试真题】 零钱兑换【动态规划】"></a>【面试真题】 零钱兑换【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322 零钱兑换（中等）</a><sup>[38]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} coins * @param {number} amount * @return {number} */var coinChange = function (coins, amount) {    if (amount === 0) return 0;    let dp = [];    for (let i = 0; i &lt;= amount; i++) {        dp[i] = amount + 1;    }    dp[0] = 0;    for (let i = 0; i &lt;= amount; i++) {        for (let j = 0; j &lt; coins.length; j++) {            if (i &gt;= coins[j]) {                dp[i] = Math.min(dp[i - coins[j]] + 1, dp[i])            }        }    }    return dp[amount] === amount + 1 ? -1 : dp[amount];};</code></pre><h2 id="【面试真题】-最长公共子序列【动态规划】"><a href="#【面试真题】-最长公共子序列【动态规划】" class="headerlink" title="【面试真题】 最长公共子序列【动态规划】"></a>【面试真题】 最长公共子序列【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143 最长公共子序列（中等）</a><sup>[39]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} text1 * @param {string} text2 * @return {number} */var longestCommonSubsequence = function (text1, text2) {    let n1 = text1.length, n2 = text2.length;    let dp = [];    for (let i = -1; i &lt; n1; i++) {        dp[i] = [];        for (let j = -1; j &lt; n2; j++) {            dp[i][j] = 0;        }    }    for (let i = 0; i &lt; n1; i++) {        for (let j = 0; j &lt; n2; j++) {            if (text1[i] === text2[j]) {                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);            } else {                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])            }        }    }    return dp[n1 - 1][n2 - 1];};</code></pre><h2 id="编辑距离【动态规划】"><a href="#编辑距离【动态规划】" class="headerlink" title="编辑距离【动态规划】"></a>编辑距离【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72 编辑距离（困难）</a><sup>[40]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} word1 * @param {string} word2 * @return {number} */var minDistance = function (word1, word2) {    let len1 = word1.length, len2 = word2.length;    let dp = [];    for (let i = 0; i &lt;= len1; i++) {        dp[i] = [];        for (let j = 0; j &lt;= len2; j++) {            dp[i][j] = 0;            if (i === 0) {                dp[i][j] = j;            }            if (j === 0) {                dp[i][j] = i;            }        }    }    for (let i = 1; i &lt;= len1; i++) {        for (let j = 1; j &lt;= len2; j++) {            if (word1[i - 1] === word2[j - 1]) {                dp[i][j] = dp[i - 1][j - 1];            } else {                dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1);            }        }    }    return dp[len1][len2];};</code></pre><h2 id="【面试真题】最长回文子序列【动态规划】"><a href="#【面试真题】最长回文子序列【动态规划】" class="headerlink" title="【面试真题】最长回文子序列【动态规划】"></a>【面试真题】最长回文子序列【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516 最长回文子序列（中等）</a><sup>[41]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {number} */var longestPalindromeSubseq = function (s) {    let dp = [];    for (let i = 0; i &lt; s.length; i++) {        dp[i] = [];        for (let j = 0; j &lt; s.length; j++) {            dp[i][j] = 0;        }        dp[i][i] = 1;    }    for (let i = s.length - 1; i &gt;= 0; i--) {        for (let j = i + 1; j &lt; s.length; j++) {            if (s[i] === s[j]) {                dp[i][j] = dp[i + 1][j - 1] + 2;            } else {                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);            }        }    }    return dp[0][s.length - 1];};</code></pre><h2 id="【面试真题】最大子序和【动态规划】"><a href="#【面试真题】最大子序和【动态规划】" class="headerlink" title="【面试真题】最大子序和【动态规划】"></a>【面试真题】最大子序和【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53 最大子序和（简单）</a><sup>[42]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var maxSubArray = function (nums) {    let maxSum = -Infinity;    let dp = [], n = nums.length;    for (let i = -1; i &lt; n; i++) {        dp[i] = 0;    }    for (let i = 0; i &lt; n; i++) {        dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);        maxSum = Math.max(maxSum, dp[i]);    }    return maxSum;};</code></pre><h2 id="【面试真题】买卖股票的最佳时机【动态规划】"><a href="#【面试真题】买卖股票的最佳时机【动态规划】" class="headerlink" title="【面试真题】买卖股票的最佳时机【动态规划】"></a>【面试真题】买卖股票的最佳时机【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121 买卖股票的最佳时机（简单）</a><sup>[43]</sup>【面试真题】</p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122 买卖股票的最佳时机 II（简单）</a><sup>[44]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123 买卖股票的最佳时机 III（困难）</a><sup>[45]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188 买卖股票的最佳时机IV（困难）</a><sup>[46]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309 买卖股票的最佳时机含冷冻期（中等）</a><sup>[47]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714 买卖股票的最佳时机含手续费（中等）</a><sup>[48]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题，笔者在面试字节跳动时就遇到过。</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} prices * @return {number} */var maxProfit = function (prices) {    let dp = [];    for (let i = -1; i &lt; prices.length; i++) {        dp[i] = []        for (let j = 0; j &lt;= 1; j++) {            dp[i][j] = [];            dp[i][j][0] = 0;            dp[i][j][1] = 0;            if (i === -1) {                dp[i][j][1] = -Infinity;            }            if (j === 0) {                dp[i][j][1] = -Infinity;            }            if (j === -1) {                dp[i][j][1] = -Infinity;            }        }    }    for (let i = 0; i &lt; prices.length; i++) {        for (let j = 1; j &lt;= 1; j++) {            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);        }    }    return dp[prices.length - 1][1][0];};</code></pre><h1 id="高频算法题系列：BFS"><a href="#高频算法题系列：BFS" class="headerlink" title="高频算法题系列：BFS"></a>高频算法题系列：BFS</h1><p>主要有以下几类高频考题：</p><ul><li>打开转盘锁【中等】【BFS】</li><li>二叉树的最小深度【简单】【BFS】</li></ul><h2 id="打开转盘锁【BFS】"><a href="#打开转盘锁【BFS】" class="headerlink" title="打开转盘锁【BFS】"></a>打开转盘锁【BFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">752 打开转盘锁（中等）</a><sup>[49]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string[]} deadends * @param {string} target * @return {number} */var openLock = function (deadends, target) {    let queue = new Queue();    let visited = new Set();    let step = 0;    queue.push('0000');    visited.add('0000');    while (!queue.isEmpty()) {        let size = queue.size();        for (let i = 0; i &lt; size; i++) {            let str = queue.pop();            if (deadends.includes(str)) continue;            if (target === str) {                return step;            }            for (let j = 0; j &lt; 4; j++) {                let plusStr = plusOne(str, j);                let minusStr = minusOne(str, j);                if (!visited.has(plusStr)) {                    queue.push(plusStr);                    visited.add(plusStr)                }                if (!visited.has(minusStr)) {                    queue.push(minusStr);                    visited.add(minusStr)                }            }        }        step++;    }    return -1;};function plusOne(str, index) {    let strArr = str.split('');    if (strArr[index] === '9') {        strArr[index] = '0'    } else {        strArr[index] = (Number(strArr[index]) + 1).toString()    }    return strArr.join('');}function minusOne(str, index) {    let strArr = str.split('');    if (strArr[index] === '0') {        strArr[index] = '9'    } else {        strArr[index] = (Number(strArr[index]) - 1).toString()    }    return strArr.join('');}class Queue {    constructor() {        this.items = [];        this.count = 0;        this.lowerCount = 0;    }    push(elem) {        this.items[this.count++] = elem;    }    pop() {        if (this.isEmpty()) {            return;        }        const elem = this.items[this.lowerCount];        delete this.items[this.lowerCount];        this.lowerCount++;        return elem;    }    isEmpty() {        if (this.size() === 0) return true;        return false;    }    size() {        return this.count - this.lowerCount;    }}</code></pre><h2 id="二叉树的最小深度【BFS】"><a href="#二叉树的最小深度【BFS】" class="headerlink" title="二叉树的最小深度【BFS】"></a>二叉树的最小深度【BFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111 二叉树的最小深度（简单）</a><sup>[50]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */var minDepth = function (root) {    if (root == null) return 0;    let depth = 1;    let queue = new Queue();    queue.push(root);    while (!queue.isEmpty()) {        let size = queue.size();        for (let i = 0; i &lt; size; i++) {            const node = queue.pop();            if (node.left == null &amp;&amp; node.right == null) return depth;            if (node.left) {                queue.push(node.left);            }            if (node.right) {                queue.push(node.right);            }        }        depth++;    }    return depth;};class Queue {    constructor() {        this.items = [];        this.count = 0;        this.lowerCount = 0;    }    push(elem) {        this.items[this.count++] = elem;    }    pop() {        if (this.isEmpty()) {            return;        }        const elem = this.items[this.lowerCount];        delete this.items[this.lowerCount];        this.lowerCount++;        return elem;    }    isEmpty() {        if (this.size() === 0) return true;        return false;    }    size() {        return this.count - this.lowerCount;    }}</code></pre><h1 id="高频算法题系列：栈【🔥】"><a href="#高频算法题系列：栈【🔥】" class="headerlink" title="高频算法题系列：栈【🔥】"></a>高频算法题系列：栈【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>最小栈【简单】【栈】</li><li>有效的括号【中等】【栈】【面试真题】</li><li>简化路径【中等】【栈】</li><li>下一个更大元素 【系列】【栈】</li></ul><h2 id="最小栈【栈】"><a href="#最小栈【栈】" class="headerlink" title="最小栈【栈】"></a>最小栈【栈】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/min-stack/submissions/" target="_blank" rel="noopener">155 最小栈（简单）</a><sup>[51]</sup></p><p>题解</p><pre><code class="javascript">/** * initialize your data structure here. */var MinStack = function () {    this.stack = [];    this.minArr = [];    this.count = 0;    this.min = Number.MAX_SAFE_INTEGER;};/** * @param {number} x * @return {void} */MinStack.prototype.push = function (x) {    this.min = Math.min(this.min, x);    this.minArr[this.count] = this.min;    this.stack[this.count] = x;    this.count++;};/** * @return {void} */MinStack.prototype.pop = function () {    const element = this.stack[this.count - 1];    if (this.count - 2 &gt;= 0) this.min = this.minArr[this.count - 2];    else this.min = Number.MAX_SAFE_INTEGER;    delete this.stack[this.count - 1];    delete this.minArr[this.count - 1];    this.count--;    return element;};/** * @return {number} */MinStack.prototype.top = function () {    if (this.count &gt;= 1) {        return this.stack[this.count - 1];    }    return null;};/** * @return {number} */MinStack.prototype.getMin = function () {    const element = this.minArr[this.count - 1];    return element;};/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */</code></pre><h2 id="【系列】下一个更大元素-【栈】"><a href="#【系列】下一个更大元素-【栈】" class="headerlink" title="【系列】下一个更大元素 【栈】"></a>【系列】下一个更大元素 【栈】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496 下一个更大元素 I（简单）</a><sup>[52]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503 下一个更大元素 II（中等）</a><sup>[53]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number[]} */var nextGreaterElements = function (nums) {    let ans = [];    let stack = new Stack();    const n = nums.length;    for (let i = 2 * n - 1; i &gt;= 0; i--) {        while (!stack.isEmpty() &amp;&amp; stack.top() &lt;= nums[i % n]) {            stack.pop();        }        ans[i % n] = stack.isEmpty() ? -1 : stack.top();        stack.push(nums[i % n]);    }    return ans;};class Stack {    constructor() {        this.count = 0;        this.items = [];    }    top() {        if (this.isEmpty()) return undefined;        return this.items[this.count - 1];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return undefined;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    isEmpty() {        return this.size() === 0;    }    size() {        return this.count;    }}</code></pre><p>##【面试真题】有效的括号【栈】</p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20 有效的括号（中等）</a><sup>[54]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {boolean} */var isValid = function (s) {          if (s.length === 0) {            return true;          }          if (s.length % 2 !== 0) {            return false;          }          let map = {            ')': '(',            ']': '[',            '}': '{',          };          let left = ['(', '[', '{'];          let right = [')', ']', '}'];          let stack = new Stack();          for (let i = 0; i &lt; s.length; i++) {            if (!right.includes(s[i])) {              stack.push(s[i]);            } else {              const matchStr = map[s[i]];              while (!stack.isEmpty()) {                const element = stack.pop();                if (left.includes(element) &amp;&amp; matchStr !== element) return false;                if (element === matchStr) break;              }            }          }          return stack.isEmpty();        };class Stack {  constructor() {    this.count = 0;    this.items = [];  }  push(element) {    this.items[this.count] = element;    this.count++;  }  pop() {    if (this.isEmpty()) return undefined;    const element = this.items[this.count - 1];    delete this.items[this.count - 1];    this.count--;    return element;  }  isEmpty() {    return this.size() === 0;  }  size() {    return this.count;  }}</code></pre><h2 id="简化路径【栈】"><a href="#简化路径【栈】" class="headerlink" title="简化路径【栈】"></a>简化路径【栈】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71 简化路径（中等）</a><sup>[55]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} path * @return {string} */var simplifyPath = function (path) {    let newPath = path.split('/');    newPath = newPath.filter(item =&gt; item !== "");    const stack = new Stack();    for (let s of newPath) {        if (s === '..') stack.pop();        else if (s !== '.') stack.push(s);    }    if (stack.isEmpty()) return '/';    let str = '';    while (!stack.isEmpty()) {        const element = stack.pop();        str = '/' + element + str;    }    return str;};function handleBack(stack, tag, num) {    if (!stack.isEmpty()) return num;    const element = stack.pop();    if (element === '..') return handleBack(stack, tag, num + 1);    else {        stack.push(element);        return num;    }}class Stack {    constructor() {        this.count = 0;        this.items = [];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return undefined;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    size() {        return this.count;    }    isEmpty() {        return this.size() === 0;    }}</code></pre><h1 id="高频算法题系列：DFS【🔥】"><a href="#高频算法题系列：DFS【🔥】" class="headerlink" title="高频算法题系列：DFS【🔥】"></a>高频算法题系列：DFS【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>岛屿的最大面积【中等】【DFS】</li><li>相同的树【简单】【DFS】</li></ul><h2 id="岛屿的最大面积【DFS】"><a href="#岛屿的最大面积【DFS】" class="headerlink" title="岛屿的最大面积【DFS】"></a>岛屿的最大面积【DFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">695 岛屿的最大面积（中等）</a><sup>[56]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} grid * @return {number} */let maxX, maxY;let visited;let globalMaxArea;var maxAreaOfIsland = function (grid) {    visited = new Set();    maxX = grid.length;    maxY = grid[0].length;    globalMaxArea = 0;    for (let i = 0; i &lt; maxX; i++) {        for (let j = 0; j &lt; maxY; j++) {            if (grid[i][j] === 1) {                visited.add(`(${i}, ${j})`);                globalMaxArea = Math.max(globalMaxArea, dfs(grid, i, j));            }            visited.clear();        }    }    return globalMaxArea;};function dfs(grid, x, y) {    let res = 1;    for (let i = -1; i &lt;= 1; i++) {        for (let j = -1; j &lt;= 1; j++) {            if (Math.abs(i) === Math.abs(j)) continue;            const newX = x + i;            const newY = y + j;            if (newX &gt;= maxX || newX &lt; 0 || newY &gt;= maxY || newY &lt; 0) continue;            if (visited.has(`(${newX}, ${newY})`)) continue;            visited.add(`(${newX}, ${newY})`);            const areaCnt = grid[newX][newY]            if (areaCnt === 1) {                const cnt = dfs(grid, newX, newY);                res += cnt;            }        }    }    return res;}</code></pre><h2 id="相同的树【DFS】"><a href="#相同的树【DFS】" class="headerlink" title="相同的树【DFS】"></a>相同的树【DFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100 相同的树（简单）</a><sup>[57]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */var isSameTree = function (p, q) {    if (p == null &amp;&amp; q == null) return true;    if (p == null || q == null) return false;    if (p.val !== q.val) return false;    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);};</code></pre><h1 id="高频算法题系列：回溯算法【🔥】"><a href="#高频算法题系列：回溯算法【🔥】" class="headerlink" title="高频算法题系列：回溯算法【🔥】"></a>高频算法题系列：回溯算法【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>N皇后【困难】【回溯算法】【面试真题】</li><li>全排列【中等】【回溯算法】</li><li>括号生成【中等】【回溯算法】</li><li>复原 IP 地址【中等】【回溯算法】</li><li>子集 【简单】【回溯算法】</li></ul><h2 id="【面试真题】N皇后【回溯算法】"><a href="#【面试真题】N皇后【回溯算法】" class="headerlink" title="【面试真题】N皇后【回溯算法】"></a>【面试真题】N皇后【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51 N皇后（困难）</a><sup>[58]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number} n * @return {string[][]} */let result = [];var solveNQueens = function (n) {    result = [];    let board = [];    for (let i = 0; i &lt; n; i++) {        board[i] = [];        for (let j = 0; j &lt; n; j++) {            board[i][j] = '.'        }    }    backtrack(0, board, n);    return result;};function deepClone(board) {    let res = [];    for (let i = 0; i &lt; board.length; i++) {        res.push(board[i].join(''));    }    return res;}function backtrack(row, board, n) {    if (row === n) {        result.push(deepClone(board));        return;    }    for (let j = 0; j &lt; n; j++) {        if (checkInValid(board, row, j, n)) continue;        board[row][j] = 'Q';        backtrack(row + 1, board, n);        board[row][j] = '.';    }}function checkInValid(board, row, column, n) {    // 行    for (let i = 0; i &lt; n; i++) {        if (board[i][column] === 'Q') return true;    }    for (let i = row - 1, j = column + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {        if (board[i][j] === 'Q') return true;    }    for (let i = row - 1, j = column - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {        if (board[i][j] === 'Q') return true;    }    return false;}</code></pre><h2 id="全排列【回溯算法】"><a href="#全排列【回溯算法】" class="headerlink" title="全排列【回溯算法】"></a>全排列【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46 全排列（中等）</a><sup>[59]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number[][]} */let results = [];var permute = function (nums) {    results = [];    backtrack(nums, []);    return results;};function backtrack(nums, track) {    if (nums.length === track.length) {        results.push(track.slice());        return;    }    for (let i = 0; i &lt; nums.length; i++) {        if (track.includes(nums[i])) continue;        track.push(nums[i]);        backtrack(nums, track);        track.pop();    }}</code></pre><h2 id="括号生成【回溯算法】"><a href="#括号生成【回溯算法】" class="headerlink" title="括号生成【回溯算法】"></a>括号生成【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22 括号生成（中等）</a><sup>[60]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number} n * @return {string[]} */var generateParenthesis = function (n) {    let validRes = [];    backtrack(n * 2, validRes, '');    return validRes;};function backtrack(len, validRes, bracket) {    if (bracket.length === len) {        if (isValidCombination(bracket)) {            validRes.push(bracket);        }        return;    }    for (let str of ['(', ')']) {        bracket += str;        backtrack(len, validRes, bracket);        bracket = bracket.slice(0, bracket.length - 1);    }}function isValidCombination(bracket) {    let stack = new Stack();    for (let i = 0; i &lt; bracket.length; i++) {        const str = bracket[i];        if (str === '(') {            stack.push(str);        } else if (str === ')') {            const top = stack.pop();            if (top !== '(') return false;        }    }    return stack.isEmpty();}class Stack {    constructor() {        this.count = 0;        this.items = [];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    size() {        return this.count;    }    isEmpty() {        return this.size() === 0;    }}</code></pre><h2 id="复原-IP-地址【回溯算法】"><a href="#复原-IP-地址【回溯算法】" class="headerlink" title="复原 IP 地址【回溯算法】"></a>复原 IP 地址【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93 复原 IP 地址（中等）</a><sup>[61]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {string[]} */var restoreIpAddresses = function (s) {    if (s.length &gt; 12) return [];    let res = [];    const track = [];    backtrack(s, track, res);    return res;};function backtrack(s, track, res) {    if (track.length === 4 &amp;&amp; s.length === 0) {        res.push(track.join('.'));        return;    }    let len = s.length &gt;= 3 ? 3 : s.length;    for (let i = 0; i &lt; len; i++) {        const c = s.slice(0, i + 1);        if (parseInt(c) &gt; 255) continue;        if (i &gt;= 1 &amp;&amp; parseInt(c) &lt; parseInt((1 + '0'.repeat(i)))) continue;        track.push(c);        backtrack(s.slice(i + 1), track, res);        track.pop();    }}</code></pre><p>##　子集【回溯算法】</p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78 子集（中等）</a><sup>[62]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number[][]} */var subsets = function (nums) {    if (nums.length === 0) return [[]];    let resArr = [];    backtrack(nums, 0, [], resArr);    return resArr;};function backtrack(nums, index, subArr, resArr) {    if (Array.isArray(subArr)) {        resArr.push(subArr.slice());    }    if (index === nums.length) {        return;    }    for (let i = index; i &lt; nums.length; i++) {        subArr.push(nums[i]);        backtrack(nums, i + 1, subArr, resArr);        subArr.pop(nums[i]);    }}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<br>【LeetCode 直通车】：234 回文链表（简单）: <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p><p>[2]<br>【LeetCode 直通车】：206 反转链表（简单）: <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>[3]<br>【LeetCode 直通车】：23 合并K个升序链表（困难）: <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p><p>[4]<br>【LeetCode 直通车】：25 K 个一组翻转链表（困难）: <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p><p>[5]<br>【LeetCode 直通车】：141 环形链表（简单）: <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p>[6]<br>【LeetCode 直通车】：148 排序链表（中等）: <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/</a></p><p>[7]<br>【LeetCode 直通车】：160 相交链表（简单）: <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><p>[8]<br>【LeetCode 直通车】：5 最长回文子串（中等）: <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>[9]<br>【LeetCode 直通车】：14 最长公共前缀（简单）: <a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p><p>[10]<br>【LeetCode 直通车】：3 无重复字符的最长子串（中等）: <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>[11]<br>【LeetCode 直通车】：76 最小覆盖子串（困难）: <a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-window-substring/</a></p><p>[12]<br>【LeetCode 直通车】：354 俄罗斯套娃信封问题（困难）: <a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/russian-doll-envelopes/</a></p><p>[13]<br>【LeetCode 直通车】：674 最长连续递增序列（简单）: <a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/</a></p><p>[14]<br>【LeetCode 直通车】：128 最长连续序列（困难）: <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence/</a></p><p>[15]<br>【LeetCode 直通车】：11 盛最多水的容器（中等）: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>[16]<br>【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）: <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><p>[17]<br>【LeetCode 直通车】：26 删除有序数组中的重复项（简单）: <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><p>[18]<br>【LeetCode 直通车】：695 岛屿的最大面积（中等）: <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island/</a></p><p>[19]<br>【LeetCode 直通车】：560 和为K的子数组（中等）: <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p><p>[20]<br>【LeetCode 直通车】：1 两数之和（简单）: <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p><p>[21]<br>【LeetCode 直通车】：167 两数之和 II - 输入有序数组（简单）: <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p><p>[22]<br>【LeetCode 直通车】：15 三数之和（中等）: <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p><p>[23]<br>【LeetCode 直通车】：18 四数之和（中等）: <a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum/</a></p><p>[24]<br>【LeetCode 直通车】：42 接雨水（困难）: <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water/</a></p><p>[25]<br>【LeetCode 直通车】：55 跳跃游戏（中等）: <a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game/</a></p><p>[26]<br>【LeetCode 直通车】：45 跳跃游戏 II（中等）: <a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game-ii/</a></p><p>[27]<br>【LeetCode 直通车】：236 二叉树的最近公共祖先（简单）: <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><p>[28]<br>【LeetCode 直通车】：700 二叉搜索树中的搜索（简单）: <a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/</a></p><p>[29]<br>【LeetCode 直通车】：450 删除二叉搜索树中的节点（中等）: <a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-bst/</a></p><p>[30]<br>【LeetCode 直通车】：222 完全二叉树的节点个数（中等）: <a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></p><p>[31]<br>【LeetCode 直通车】：103 二叉树的锯齿形层序遍历（中等）: <a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/</a></p><p>[32]<br>【LeetCode 直通车】：452 用最少数量的箭引爆气球（中等）: <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><p>[33]<br>【LeetCode 直通车】：56 合并区间（中等）: <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-intervals/</a></p><p>[34]<br>【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）: <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><p>[35]<br>【LeetCode 直通车】：392 判断子序列（简单）: <a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/is-subsequence/</a></p><p>[36]<br>【LeetCode 直通车】：34 在排序数组中查找元素的第一个和最后一个位置（中等）: <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><p>[37]<br>【LeetCode 直通车】：300 最长递增子序列（中等）: <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><p>[38]<br>【LeetCode 直通车】：322 零钱兑换（中等）: <a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p><p>[39]<br>【LeetCode 直通车】：1143 最长公共子序列（中等）: <a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p><p>[40]<br>【LeetCode 直通车】：72 编辑距离（困难）: <a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/</a></p><p>[41]<br>【LeetCode 直通车】：516 最长回文子序列（中等）: <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-subsequence/</a></p><p>[42]<br>【LeetCode 直通车】：53 最大子序和（简单）: <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p>[43]<br>【LeetCode 直通车】：121 买卖股票的最佳时机（简单）: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>[44]<br>【LeetCode 直通车】：122 买卖股票的最佳时机 II（简单）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>[45]<br>【LeetCode 直通车】：123 买卖股票的最佳时机 III（困难）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>[46]<br>【LeetCode 直通车】：188 买卖股票的最佳时机IV（困难）: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>[47]<br>【LeetCode 直通车】：309 买卖股票的最佳时机含冷冻期（中等）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p>[48]<br>【LeetCode 直通车】：714 买卖股票的最佳时机含手续费（中等）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><p>[49]<br>【LeetCode 直通车】：752 打开转盘锁（中等）: <a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/open-the-lock/</a></p><p>[50]<br>【LeetCode 直通车】：111 二叉树的最小深度（简单）: <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><p>[51]<br>【LeetCode 直通车】：155 最小栈（简单）: <a href="https://leetcode-cn.com/problems/min-stack/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack/submissions/</a></p><p>[52]<br>【LeetCode 直通车】：496 下一个更大元素 I（简单）: <a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-i/</a></p><p>[53]<br>【LeetCode 直通车】：503 下一个更大元素 II（中等）: <a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-ii/</a></p><p>[54]<br>【LeetCode 直通车】：20 有效的括号（中等）: <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a></p><p>[55]<br>【LeetCode 直通车】：71 简化路径（中等）: <a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/simplify-path/</a></p><p>[56]<br>【LeetCode 直通车】：695 岛屿的最大面积（中等）: <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island/</a></p><p>[57]<br>【LeetCode 直通车】：100 相同的树（简单）: <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p><p>[58]<br>【LeetCode 直通车】：51 N皇后（困难）: <a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p><p>[59]<br>【LeetCode 直通车】：46 全排列（中等）: <a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p><p>[60]<br>【LeetCode 直通车】：22 括号生成（中等）: <a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/</a></p><p>[61]<br>【LeetCode 直通车】：93 复原 IP 地址（中等）: <a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/restore-ip-addresses/</a></p><p>[62]<br>【LeetCode 直通车】：78 子集（中等）: <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p>]]></content>
    
    
    <summary type="html">现在大厂面试中，算法题几乎为必考项，且近几年频现 LeetCode 真题，此篇为拿到字节、腾讯、京东 Offer 的笔者本人在准备面试过程中亲自刷过以及遇到过高频算法题。文章内容会分模块整理，对于笔者在面试过程中遇到的真题，会给予着重 【🔥】标出。</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>202104赛季晋级赛第一关-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Trace-Battle-For-Promotion-202104-1-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Trace-Battle-For-Promotion-202104-1-Ans/</id>
    <published>2021-05-01T12:00:00.000Z</published>
    <updated>2021-05-02T09:44:03.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>中国香港港铁东铁线</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>网络迷踪由于线索取景真实，所以解题思路并不唯一，但答案唯一。本题解析仅为其中一种方法。</p><p>本关的歧义主要在于轨道交通系统名称，港铁是由九广铁路与香港地铁合并而成，随后注册名称叫做港铁。示例中的澳门轻轨是一个意思。</p><div class="text-center"><img src="/assets/images/crimaster/2021/05/20210501-ans-1.png" alt="港铁" class="post-image inline" style="width:30%"><img src="/assets/images/crimaster/2021/05/20210501-ans-2.png" alt="澳门轻轨" class="post-image inline" style="width:30%"></div><p>单看视频可能没有什么特定的头绪。不妨筛选出有用的线索。</p><p>仔细聆听声音，可以在视频末端聆听到一则语音播报:</p><video controls="" class="post-video half"><source src="/assets/videos/crimaster/2021/05/20210501-1.mp4" type="video/mp4"></video><p>利用音频翻译搜寻可以得出，此为广东话:下一站。车行走缓慢均匀且在路轨上行驶，说明即将抵达站台，由此可以大致确定为使用广东话为播报的某地铁内所拍摄。</p><p>语音播报为广东话，而使用广东话为语音播报的城市有:中国广东省，中国香港，中国澳门。</p><p>中国广东省车内语音播报提示顺序为先普通话后广东话(语)，视频中先是粵语，所以排除中国广东省</p><p>中国澳门轻铁以及中国香港港铁均是使用广东话(粵语)为主语的城市，列车语言播报顺序为:先粤语，后普通话，再英语。</p><p>我们需要进行进一步排除，当进行谷歌搜索了解港铁与澳门轻铁车语音播报内容时发现:中国香港的港铁播报方式为:“下一站x”，而中国澳门的轻铁播报方式为:“即将到达x”。视频内播报为:“下一站”，由此我们仅从视频中的一句播报，便可锁定该列车为中国香港港</p><p>铁: HK MTR</p><p>根据视频里的风景可以推断出这是在地上的线路。利用谷歌实景地图翻阅香港各大站可以筛选出地上站台有:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-3.png" alt="" class="post-image"><p>线路站点</p><table><thead><tr><th>线路</th><th>站点</th></tr></thead><tbody><tr><td>东铁线</td><td>全线</td></tr><tr><td>西铁线</td><td>屯门、兆康、天水围、郎屏、元朗、锦上路</td></tr><tr><td>观塘线</td><td>彩虹、九龙湾、牛头角、观塘、蓝田</td></tr><tr><td>荃湾线</td><td>荃湾、葵兴、葵芳、荔景</td></tr><tr><td>迪士尼线</td><td>欣澳、迪士尼</td></tr><tr><td>东涌线</td><td>荔景、欣澳、东涌</td></tr><tr><td>机场快线</td><td>荔景、机场、欣澳</td></tr><tr><td>南港岛线</td><td>海洋公园、黄竹坑、利东、海怡丰岛</td></tr><tr><td>马鞍山线</td><td>全线</td></tr></tbody></table><p>符合条件的站台太多，这样一一排査太费时间，我们需要再缩小范围。</p><p>从视频里我们可以发现这样一景</p><img src="/assets/images/crimaster/2021/05/20210501-ans-4.png" alt="" class="post-image"><p>一排排房子。我们可以借此确定列车方位。香港位于中国，太阳日出东方，日落西方，视频中右侧可看到房屋的阳光照射角度，用太阳方位推断列车自西向东行驶。</p><p>香港是沿海城市，视频里的走向没有经过海，且一般铁路设计不会靠着海行驶，中间会隔着马路。所以可以确定这段路程非沿海所行。结合以上两点，我们可以排除许多车站，只剩下:</p><div class="text-center"><img src="/assets/images/crimaster/2021/05/20210501-ans-5.png" alt="" style="height: 55px" class="post-image inline"><img src="/assets/images/crimaster/2021/05/20210501-ans-6.png" alt="" style="height: 55px" class="post-image inline"><img src="/assets/images/crimaster/2021/05/20210501-ans-7.png" alt="" style="height: 55px" class="post-image inline"></div><p>这里再次涉及到香港车内播报的一个习俗:除两头终点站外，车内语音播报会在快到下一站时才会播报。而观塘线的彩虹站至九龙湾站以及南港岛线的黄竹坑至海洋公园站快到站台都已经分别为北南走向及南北走向。所以排除。因此也可以排除东铁线的罗湖/落马洲站至上水站以及大学至火炭站。</p><p>推理至此，符合条件的仅剩下东铁线，此时答案已经明确，当然如果我们足够耐心，甚至可以进一步推测出该列车下一站的站点。</p><p>至此，为推测列车下一站站点，我们可以锁定到:上水至粉岭站，粉岭至太和站，太和至大埔墟站，大埔墟至大学站这些路线进行排查。</p><p>路程较远我们依旧无法很好的锁定。视频里又可以为我们提供信息。视频先后为我们提供了:</p><p>公交车:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-8.png" alt="" class="post-image half"><p>高速公路:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-9.png" alt="" class="post-image half"><p>高压线缆:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-10.png" alt="" class="post-image half"><p>房屋:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-11.png" alt="" class="post-image half"><p>小马路:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-12.png" alt="" class="post-image half"><p>由此可以推断后来的房屋与铁路成直线。高压线缆，与铁路交汇。高速公路可能开始呈一直线，后来分岔。以及沿途涉及公交路线。这给我们进行实景搜索提供很多信息。</p><p>只要足够耐心，最后经过谷歌地球实景，我们可以在通往大埔墟的线段里发现这一风景。</p><p>本次网络迷踪的挑战可以让我们知道，一句简单的语音播报也能蕴含许多信息，类似于此类信息的还有车牌号，电话号等具有区域性及规律性的讯息，这些都是让我们突破惯性思维，得到真相的关键。通过一句语音播报，一段风景视频，利用互联网各类工具及知识，便可查找出视频拍摄者的具体位置，即便在这过程中些许枯燥，但每一次新的突破口涌入脑中，都会是一次思维风暴，这便是网络迷踪中逻辑及推理的魅力!</p>]]></content>
    
    
    <summary type="html">202104赛季晋级赛第一关答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="网络迷踪" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/"/>
    
    
    <category term="网络迷踪-解答" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>202104赛季晋级赛第一关</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Trace-Battle-For-Promotion-202104-1/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Trace-Battle-For-Promotion-202104-1/</id>
    <published>2021-05-01T00:00:00.000Z</published>
    <updated>2021-05-02T09:44:03.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这是一段于北京时间2021年4月11日15:28分在 Instagram上传的视频，视频发布者声明这是一段在列车上拍摄的视频，而此次你需要挑战的是，如何在这一段视频，推理出视频发布者乘坐的列车是什么城市的哪条线路?</p><video controls="" class="post-video half"><source src="/assets/videos/crimaster/2021/05/20210501-1.mp4" type="video/mp4"></video><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入视频中所在地点及搭载的轨道交通系统名称和线路</p>]]></content>
    
    
    <summary type="html">这是一段于北京时间2021年4月11日15:28分在 Instagram上传的视频，视频发布者声明这是一段在列车上拍摄的视频，而此次你需要挑战的是，如何在这一段视频，推理出视频发布者乘坐的列车是什么城市的哪条线路?</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="网络迷踪" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/"/>
    
    
    <category term="网络迷踪" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>意外之谜-答案</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Delegate-Unexpected-Mystery-Ans/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Delegate-Unexpected-Mystery-Ans/</id>
    <published>2021-04-28T12:00:00.000Z</published>
    <updated>2021-05-02T09:31:57.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>SHELF</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>观察发现是上下左右的字符，在一张表格里，从任意初始位置开始，按着题目上的箭头每次走一格，如果是黑色的方向那就给这个格子涂黑绿色就涂绿，最后会发现绿色格子象形得到答案。</p><img src="/assets/images/crimaster/2021/04/20210428-ans-1.png" alt="" class="post-image">]]></content>
    
    
    <summary type="html">20210428期侦探委托《意外之谜》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托-解答" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>意外之谜</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Delegate-Unexpected-Mystery/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Delegate-Unexpected-Mystery/</id>
    <published>2021-04-28T00:00:00.000Z</published>
    <updated>2021-05-02T09:29:38.132Z</updated>
    
    <content type="html"><![CDATA[<p><font style="color:#D9730D">今天是CRIMASTER四月赛季最后一天了，这也是晋级赛前最后一道题，晚间将暂时关闭竞技赛场，等待5.1巅峰对决晋级赛的开启!希望大家都会取得一个好成绩，今天可以陆续更新版本啦，各应用商店更新审核时间不同，请耐心等待!加油!</font></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>我叫柳菲，是一名古玩字画收藏家。</p><p>就在刚才，我收到了朋友发的消息:“菲姐菲姐!快点来卧龙观邸一趟，听说有关于《骷髅幻戏图》的消息。</p><p>”我对这幅画很感兴趣，于是立即驱车到达。只是…这守门大爷给我这张纸是为何?看画还要解谜题?</p><img src="/assets/images/crimaster/2021/04/20210428-1.png" alt="" class="post-image"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>图片代表的意思 英文单词</p>]]></content>
    
    
    <summary type="html">我叫柳菲，是一名古玩字画收藏家。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来到我的世界-答案</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Decipher-Welcome-To-My-World-Ans/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Decipher-Welcome-To-My-World-Ans/</id>
    <published>2021-04-25T12:00:00.000Z</published>
    <updated>2021-05-02T09:57:29.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>金沙县</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我们像那跨越七海的风一般，在碧蓝的未来描绘我们的梦想，穿越了无数片海域和星河。到人生的每个阶段蓦然回首，还能是否想起那年少时的热枕。我偶尔还能想起，山脉间那跨越七海的风，少年在地图上勾画的那个午后。</p><p>我国领土的四端为:<br>最东端在黑龙江和乌苏里江的主航道中心线的相交处(135°2’30”E);<br>最西端在帕米尔高原附近(73°29’59.79”E);<br>最南端在立地暗沙(3°31’00”N，东经112°17’09” E)，为中国南海南沙群岛区域的一座暗沙，是实际上的中国领土的最南端;<br>最北端在漠河以北黑龙江主航道的中心线上(53°33’N，124°20’E)  </p><p>1、我们按照拼图形式得到:</p><img src="/assets/images/crimaster/2021/04/20210425-ans-1.png" alt="图片" class="post-image half"><p>2、根据符号X的位置带入图片得到数据表格</p><img src="/assets/images/crimaster/2021/04/20210425-ans-2.png" alt="图片" class="post-image half"><p>我国古代纪年法的其中一种为干支纪年法，近世也常用干支纪年表示重要历史事件，如:“戊戌变法”“辛亥革命”等。</p><p>按照提示得到年份的天干地支以及顺序:</p><p>圆圈：</p><p>1804(甲子年)</p><p>X</p><p>1829(己丑年)</p><p>1855(乙卯年)</p><p>1905(乙巳年)</p><p>X</p><p>1937(丁丑年)</p><p>2037(丁巳年)</p><p>方块:</p><p>1841(辛丑年)</p><p>1894(甲午年)</p><p>1939(己卯年)</p><p>1940(庚辰年)</p><p>1965(乙已年)</p><p>2004(甲申年)</p><p>由“天圆地方”的提示将圆圈所对应的天干提取方块对应的地支提取得到：</p><p>圆圈：甲X己乙乙X丁丁</p><p>方块:丑午卯辰已申</p><p>提示X=0，得到数字</p><p>方块 274569</p><p>圆圈 10622044</p><p>1、地点在中国，根据中国经纬度范围划分数字得到：</p><p>27.4569 N</p><p>106.22044 E</p><p>2、打开地图，输入坐标，得到答案金沙县。</p><img src="/assets/images/crimaster/2021/04/20210425-ans-3.png" alt="图片" class="post-image half no-limit-height"><img src="/assets/images/crimaster/2021/04/20210425-ans-4.png" alt="图片" class="post-image">]]></content>
    
    
    <summary type="html">20210425期极速破译《欢迎来到我的世界》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="极速破译" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E6%9E%81%E9%80%9F%E7%A0%B4%E8%AF%91/"/>
    
    
    <category term="极速破译-解答" scheme="http://yoursite.com/tags/%E6%9E%81%E9%80%9F%E7%A0%B4%E8%AF%91-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来到我的世界</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Decipher-Welcome-To-My-World/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Decipher-Welcome-To-My-World/</id>
    <published>2021-04-25T00:00:00.000Z</published>
    <updated>2021-05-02T09:51:46.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>“亲爱的侦探，人们常说，对着大山呐喊，大山对面的人就会听到你的声音，可是当你真正呐喊后畅快过后，仿佛更加深了一种失意，再美好的风景都不如回家的路。偶尔听听耳边的风，跨越了祖国的大江南北，渡过了多少江河，将故乡的气息传递到这。这是我生长的地方，欢迎来到我的世界。”</p><img src="/assets/images/crimaster/2021/04/20210425-1.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/04/20210425-2.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/04/20210425-3.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/04/20210425-4.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/04/20210425-5.png" alt="图片" class="post-image half"><p><font color="#e03e3e">提示1:X=0<br>提示2:以古人纪年之法寻由古至今、天圆地方之数</font></p><p>拼合图片对应表格找寻线索，遵循本初子午线的规则对应我国经纬度范围内寻找一处确切的地点，即为答案。聪明的侦探，请解开谜题填入相应的一处地名。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入一处地点名称 <font color="#e03e3e">例如:凤凰县</font></p>]]></content>
    
    
    <summary type="html">亲爱的侦探，人们常说，对着大山呐喊，大山对面的人就会听到你的声音，可是当你真正呐喊后畅快过后，仿佛更加深了一种失意，再美好的风景都不如回家的路。偶尔听听耳边的风，跨越了祖国的大江南北，渡过了多少江河，将故乡的气息传递到这。这是我生长的地方，欢迎来到我的世界。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="极速破译" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E6%9E%81%E9%80%9F%E7%A0%B4%E8%AF%91/"/>
    
    
    <category term="极速破译" scheme="http://yoursite.com/tags/%E6%9E%81%E9%80%9F%E7%A0%B4%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>荷兰公寓杀人案-答案</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Case-Apartment-Homicide-In-The-Netherlands-Ans/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Case-Apartment-Homicide-In-The-Netherlands-Ans/</id>
    <published>2021-04-24T12:00:00.000Z</published>
    <updated>2021-05-02T11:04:15.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><ol><li>埃里克在该公寓租房更可能的原因是?<br>A.埃里克正在与雷合作<br><font color="#56c596">B.埃里克要观察雷</font><br>C.埃里克不想住分配公寓<br>D.埃里克要调查分尸案</li></ol><ol start="2"><li>雷是被谁杀死的?<br>A.温特<br>B.丹<br>C.埃里克<br><font color="#56c596">D.博斯</font></li></ol><ol start="3"><li>是谁将丹锁在公寓一内?<br>A.雷<br>B.温特<br><font color="#56c596">C.埃里克</font><br>D.博斯</li></ol><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>埃里克作为大贩毒团伙多年的下手，他靠关系和博斯去了同一所监狱。博斯的哥哥皮特也在这所监狱中。他们三人很快洽谈起来——从该死的侦探和便利店的老板，谈到埃里克和博斯是如何手忙脚乱地往下水道倾倒毒品时忘了自己身上有枪可以反抗。</p><p>皮特表示自己因为开枪袭警而被判处了无期徒刑，而自己唯一的愿望就是希望弟弟斯能够在出狱之后向雷复仇。</p><p>博斯答应了。</p><p>时间慢慢爬过。雷在这段时间里过着穷困潦倒且堕落的日子，他等待着在博斯出狱后将其手刃。雷在丹的公寓楼里租房。丹的长期租金异常便宜——因为很久之前这里发生过碎尸案，几乎没有长期租客。丹作为当时碎尸案的目击证人，从垃圾袋中见证了那残忍的真相，精神上出了问题(家族精神疾病触发)。</p><p>从那之后，丹就对租户的垃圾袋特别不放心，总是要亲自翻看租户的垃圾，直到确认里面没有尸块为止。为了防止发生过凶案的公寓无法租出，丹拆下了所有的公寓门牌号，借此掩盖案现场的号码牌以使得不明真相的租户能继续租用公寓。</p><p>雷对此事并不知情也不在意。</p><p>2021年的4月，博斯和埃里克陆续出狱。雷打通警监，得到了埃里克出狱后被安排的住址。雷在埃里克的住址门口留了一封装有博斯与埃里克毒品交易的照片复印件和自己的电话联系方式的信。</p><p>这张照片复印件足以将埃里克重新定罪。</p><p>埃里克看见照片后立马拨向雷在信上留下的电话号码。电话里，雷希望埃里克可以接近博斯并且杀掉他，否则就向警方公布照片让其再进一次监狱。埃里克口头答应了雷，但却对此事有别的想法。</p><p>在埃里克看来，有可能拍照并且利用自己来杀掉博斯的人，应该是当时店长阿尔贝的亲人。于是埃里克于2021年4月13日找到隔壁店主罗根打听店长阿尔贝的人际关系，接着就联系到了后来退伍的军人温特。</p><p>温特明显不是联系埃里克的人，他对埃里克的存在完全不知情。埃里克通过说出催命电话这个细节贏得了温特和罗根的信任。</p><p>罗根于是给埃里克播放了当年案件最关键的证据——监控录像。监控上的人虽然模糊不清，但埃里克一眼认出画面中逃跑的人是博斯。录像里还有想要追上博斯的雷，只不过画面也是同样的模糊不清。埃里克虽知道杀人犯博斯的身份和行踪，但是他并未透露给温特，而仅是向温特透露了雷的情况，并暗示雷很可能在追查博斯。</p><p>2021年4月14日，丹通过雷扔在垃圾袋里的电话卡，得到了图片和短信内容。</p><p>丹一直依靠药物维持精神，他想通过出卖雷的住址等信息，来从这个贩毒的联系人那里赚一笔药费。丹联系到了埃里克，无意中透露了雷的身份。双方随后做了一笔交易——用雷的住址及个人信息来交药物和钱。</p><p>交易达成后，雷的住址被暴露在埃里克的面前。因雷拥有照片的复印件，故埃里克决定销毀掉该照片的原件及其它的信息和证据，届时了结一众人的夙愿。</p><p>埃里克用假身份住进与雷对门的公寓二，伺机观察雷的生活作息，了解他的习惯，从其房间内十分凌乱而防盗门的门镜里外却都被擦拭干净而推测其经常通过门镜进行观察。</p><p>温特多次的追问埃里克有关雷的更多事情，且有怀疑他的迹象，埃里克向温特透露了雷的住址所在地。听到这个消息的温特表示自己想与雷见面，以便了解父亲死亡案件的进展。埃里克也将雷的地址告知了博斯，通过几日的观察，埃里克发现雷的生活规律，觉得这是个机会，博斯想要杀人，而自己则可以顺势将雷手里的证据销毀。2021年4月23日早晨10点，雷出门，并在等待电梯时被埋伏已久的埃里克用电击枪击晕。埃里克把雷拖到了自己租的二号房间，所以房间门ロ较干净，且雷的衣服和后脑勺有灰尘，然后搜出雷身上的一号房间钥匙，打开雷的房门开始销毁证据。</p><p>10点09分，温特进入楼内并来到了公寓一前。此时埃里克还在房间内。温特敲了公寓一的门，屋内的埃里克担心暴露，并未回应温特。温特误以为雷不在家中，于是拨打了雷的电话(这个电话号码是丹留给埃里克，随后被埃里克告诉了温特)。电话铃从公寓二内雷的口袋里响了起来。站在公寓一外的温特听见铃声觉得纳闷，以为自己敲错了房门。于是温特转而敲响了公寓二的门，但是公寓二内也没有人回应。</p><p>由于没有门牌号的缘故，温特便打算找物业询问情况。温特从楼道广告得知房东丹平时住在顶楼后，便通过电梯上楼寻找房东丹了解住户雷的情况。</p><p>温特进入电梯并按下了10楼的按钮。</p><p>此时，埃里克处理完证据，钥匙遗留在了桌子上，回到自己的公寓二，并把雷搬回了公寓一。埃里克没有关上公寓一的门，而是留了道门缝以待博斯的到来。</p><p>随后埃里克径直回到了自己的公寓二。</p><p>10点25分，博斯来到雷半掩的门前。此时的雷已经半醒，他在迷糊之中看见了博斯。博斯瞬间用携带的粗尼龙绳从雷身后勒住他的脖子。</p><p>雷反应过来的时候已经晚了。挣扎了许久后，强撑着意识用右手抽出腰间藏有的防身匕首朝背后的博斯身上刺去。博斯虽然受伤，但是他没有松手，在雷失去意识后他依旧没有停止勒绞，直至雷死去。而房东那边听完温特的陈述后决定着备用钥匙与温特一同下楼查看住户雷的情况。此时公寓一内，博斯在确认雷死亡之后，捂着受伤的部位逃出了公寓一。由于首仍插在博斯的伤口上，因此走廊上仅滴落少量血滴。</p><p>因为害怕案发现场被人过早发现而导致自己无法顺利脱身，博斯离开前关上了雷的房门。博斯走向电梯，正好在走廊转角撞见赶下来的丹和温特。衣物带血的博斯使丹的情绪变得激动起来。而温特则认为五楼两户居民中一户为雷，推断此人受伤很可能与雷有关，且通过自己参军的敏锐洞察力判断出博斯就是监控中那个枪杀父亲并逃窜的凶手。</p><p>博斯谎称有人要杀害自己，凶手被他打晕，寻求救命。温特让丹留在原地看守防止手逃离，自己则找借口说要护送伤者到一楼。丹慌乱之中听取了温特的意见，在公寓一门口将门死死抵住。温特帮博斯打开了电梯的大门，博斯因失血过多靠着电梯壁坐在地。温特不打算帮助杀父凶手博斯，他趁博斯不注意，拔出了留在博斯体内的首，让博斯失血过多在电梯内死去。博斯死之后，温特拨打了急救电话并离开建筑物前往街角等待救护车的到来。</p><p>此时公寓二内的埃里克通过门镜看见丹抵着公寓的门。于是埃里克故意开门训斥丹在偷窥租户。丹回头辩解，并向埃里克说明情况。埃里克建议应该先进屋制服凶手再报警。</p><p>于是丹用备用钥匙打开了公寓一的房门。丹和埃里克进入公寓一，看到了雷死不瞑目的尸体，丹并没有注意到此刻身后的埃里克掏出了电击枪。埃里克从丹背后用电击枪将其击晕，拿走了丹的备用钥匙串，随后在公寓一门外用备用钥匙将门反锁，然后带着电击枪和备用钥匙通过楼梯跑到顶楼丹的住房寻找丹用来与自己交易的照片与电话卡。</p><p>在找到证据并将其销毀后，埃里克企图乘坐电梯离开。电梯门开后，博斯的尸体赫然倒在电梯里。埃里克灵机一动，将房东的备用钥匙串消除指纹并藏入了博斯的口袋，然后以最快的速度从楼梯离开建筑物。他并没有注意到沉睡的丹身上始终带着一张足以定罪的照片复印件…</p><p>走廊血迹的分析。</p><p>血迹未端的朝向即为伤者的移动方向。故本案中的伤者是从西向东地在走廊移动的。</p><img src="/assets/images/crimaster/2021/04/20210424-ans-1.png" alt="图片" class="post-image half"><p>雷是怎么死的?电击伤为什么与丹相同?可不可能是雷死后被人为伪造出的勒痕?会不会博斯当时没把人杀死，埃里克后来补刀?</p><p>①雷是生前被埃里克用电击枪击晕，后在苏醒时被博斯用绳索从身后勒住脖子发生机械性窒息后死亡的。因为雷的脖颈处有挠抓痕迹，故其被袭击时是有一定行动能力的，但在首插入后未被拔出多次反抗说明雷当时已经用尽全身力气，行动能力较弱了，博斯此时受伤，定不会给雷有活过来害自己的机会，且在博斯逃出后雷并没有追击，也没有拨打报警电话，说明雷当时起码是处于昏迷状态，而尸检中有线索雷的脖颈处仅一圈勒无二次被勒痕迹。</p><p>②颈后为电击伤，并非雷的致死原因，其与丹的电击伤相同是因为两人受到的袭击都来自于埃里克。</p><p>③鉴别生前索沟或死后索沟，除生前索沟出血外，还可取索沟部皮肤作组织学、组织化学检查，以及作组织胺和5-羟色胺的生物化学测定，生前索沟含量明显增高，死后索沟的含量不增局。</p><p>④榑斯想要的是帮自己的黑帮兄弟复仇，一定会要雷偿命的。此外，如果埃里克想要雷死，在使用电击枪的时候就可以动手了。且埃里克如果杀害雷，动机是有证据在其手上，那么丹也知晓其事情，理应将二人同时杀害，且埃里克逃走时以为证据已被销毀，杀害雷对他无益。该部分详见案件还原。</p><p>尘封案件一与本案有联系吗?</p><p>分析有无联系的绝佳途径就是寻找两起案件的相似之处。我们分析后发现尘封案件一与本案最大的关联可能就在房东丹身上。</p><p>在此之前我们先把目光放在这幢公寓本身，这幢公寓目前由房东丹掌管。根据群众的说辞，公寓各方面都很好，但是租金却异常低廉，这现象显然不太符合现实。</p><p>根据丹的线索可以发现，其父亲因精神分裂症恶化被送往疗养院是在2015年11月，而分尸案发生的日期也是在该月。丹的父亲的入院无疑给丹造成了经济压力。而且我们知道，如果一处小区或住宅发生了影响恶劣的凶案，那么它的信誉度和口碑就会在周边地区降低，久而久之客人便不愿意租住。此处，便是由于凶案的影响，公寓五楼的客房在很长时间内都无人租住，这使得丹承担了经济损失。</p><p>①所以为了消除案发生地501号房对业务的影响，丹索性拆掉了门牌号。如此一来租户便难以分清传言的真伪。</p><p>②同时，凶案的影响使得房东丹精神失常，从而形成了喜欢检查他人垃圾袋的癖好，还给房东丹带来了恶劣的精神分裂症。</p><p>相比于尘案二，尘案一提供的线索并不多。故并案调查的主要方向应当在线索丰富的尘案二上面。</p><p>科普时间：</p><p>一、自1976年起，荷兰政府就把毒品分类为硬毒品和软毒品。对海洛因、可卡因这些严重危害公众身体健康的硬毒品实行严厉打击。而像“大麻”这种所谓的“软毒品”，则允许公开买卖。荷兰此举当然不是在鼓励或支持毒品合法，其主要目的在于将大麻与非法渠道隔离，从而减少人们接触硬毒品的机会。值得注意的是，目前荷兰硬毒品的成比例是欧盟平均水平的3/5;而其因静脉注射感染艾滋的人数比例为10％，低于欧盟平均水平40％。</p><p>二、遗传因素在精神分裂症的发病中起重要作用。研究显示，一级亲属中同患本病的危险率约为4％-14％，约为一般人群的10倍。若双亲均患精神分裂症，其危险率可高达40％。在患者的二级亲属中，患病的危险率约高于一般人口的3倍。国外研究显示(1974)，精神分裂症单卵孪生子的同病率较双卵孪生子高。单卵孪生子的同病率6％-73％;双卵孪生子的同病率2.1％-12.3％。研究显示，精神分裂症具有一定的遗传因素，且血缘关系越近，危险率越高;遗传因素的影响较环境及其他因素大。截止目前，精神分裂症的基因定位研究尚无定论，精神分裂症可能是多基因遗传，由若干基因的叠加作用所致。</p><p>温馨提示：</p><p>生活有诸多不易，但我们干万不能让自己对生活的美好初衷，随着时间的流逝而日衰老直到熄灭。谨记自己内心的温存，去感受生活的美好。笔者愿用雷蒙德·钱德勒《漫长的告别》书中的一句经典人物台词来做本案的结尾“你知道，故事的结尾并不重要，生活唯一确保我们的就是死亡。所以我们最好不要让那结尾，夺走了故事的光芒。”</p><p>另，本文在创作过程中，可能受到国内外多部优秀悬疑推理或文学经典作品的启发，在这里特别向约翰・迪克森・卡尔《三口棺材》、紫金陈《长夜难明》、伊恩・麦克尤恩《阿姆斯特丹》等大师与作品致敬!</p>]]></content>
    
    
    <summary type="html">20210424期疑案追凶《荷兰公寓杀人案》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="疑案追凶" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E7%96%91%E6%A1%88%E8%BF%BD%E5%87%B6/"/>
    
    
    <category term="疑案追凶-解答" scheme="http://yoursite.com/tags/%E7%96%91%E6%A1%88%E8%BF%BD%E5%87%B6-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
</feed>
