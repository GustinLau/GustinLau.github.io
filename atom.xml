<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星星杂货铺</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-22T07:37:35.474Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gustin Lau</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大学生失踪案-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-reasoning-disappearance-of-college-student-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-reasoning-disappearance-of-college-student-ans/</id>
    <published>2021-05-21T12:00:00.000Z</published>
    <updated>2021-05-22T07:37:35.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><ol><li>脚尖指向的具体方向是(本题略加照片显示的视觉偏差，运用知识限于中学阶段，脚尖的方向即当时太 阳所在的方向)?<br><font color="#56c596">A.东北</font><br> B.正东<br> C.东南</li></ol><ol start="2"><li>能否确定足迹的主人朝着房屋方向移动?(无故意伪造情况)<br> A.可以确定<br><font color="#56c596">B.无法确定</font></li></ol><ol start="3"><li>会面地点在哪？<br> A.辽宁大学蒲河校区食堂<br> B.辽宁大学崇山校区食堂<br><font color="#56c596">C.沈阳师范大学南区食堂</font><br> D.沈阳师范大学北区食堂</li></ol><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>前言：</p><p>今天的日子比较特殊，虽不是中国传统节日，但也算是个热门的日子，并且，也是 CRIMASTER正式上架一周年。</p><p>作为这款APP的负责人之一，通过这种方式和大家进行初次沟通，万望海涵。</p><p>首先，真挚的祝福大家，祝你们人生中的的每一天都不负时光，充实快乐。</p><p>CRIMASTER来源于《唐人街探案3》，作为一款影视社区现实化的应用，上线后不久便收获了干万级的注册用户，凭借着免费的体验和玩家自发织和功能上都做了较大的改动，可大家不离不弃，我们感恩，也感动。</p><p>CRIMASTERE的题目一直在做创新和改变，涉及的范围更广，触达的知识点也更多，一方面是为了让玩家了解更多的内容，另一方面，则是为了不断的去给大家出“难题”，正如APP消息推送说的那样，天文地理、五行八卦、推理解谜、风水算命，统统难不住你们，真的，发自内心的佩服。我们一直在成长，相信大家也是，有时候想一想，能陪伴诸位这么久，足矣。</p><p>我进入社区查看大家的讨论，发现了一个不好的现象，当看完很多玩家的推理解析后，才了解到一部人是在故意混淆视听，而一些不愿意去看题，不愿意去思考的玩家看到后却信以为真。不知何时，我们的社区竟变成了这番模样，同样怀揣着对侦探的梦想来到这里，却因经验或知识储备不同等，如今却成为了两种人。</p><p>如果你真的热爱推理，不要懒惰，动脑思考，查阅资料，在体验过程的同时，丰富自己的阅历和见识。如果你真的热爱推理，不要欺骗，恪守信仰，坚持初心，尽力去帮助那些疑惑的人，分享思路，携手共同进步。如果你真的热爱推理，由衷的期望您加入我们，努力让这个“又爱又恨”的圈子变的更加完善更加壮大，让更多的人知道中国，也有这么一群可爱正义、能力超群的侦探。</p><p>第一题：</p><p>太阳视运动:指的是在我们的眼中，太阳的运动规律，所以是以我们自身为坐标原点，使太阳相对运动，观察其运动趋势。在二分日(春分秋分)，太阳正东升正西落。夏半年(春分至秋分)太阳东北升，西北落;冬半年(秋分日至次年春分日)太阳东南升，西南落。在北半球观察太阳是自东向西顺时针运动，南半球太阳自东向西逆时针运动(与地球自转方向相反)。所以夏半年北半球昼长夜短，冬半年南半球昼长夜短。</p><p>北半球在太阳直射赤道(春秋分日)时太阳升起为时间为地方时6:00，方位为正东方向。</p><img src="/assets/images/crimaster/2021/05/20210521-ans-1.png" alt="图片" class="post-image half"><p>沈阳所处为北半球，在所处时间介于春分以及夏至之间(5月21日)大致可判断出太阳此时方位并未到达正东，而还处于东北。</p><img src="/assets/images/crimaster/2021/05/20210521-ans-2.png" alt="图片" class="post-image half"><p>但题中所给6:00为东八区中央经线经120°的时间(北京时间)，沈阳大致为东经123°，则沈阳地方时大致为6:12。我们通过精确计算来最终确定其方位。(可通过查询或自行公式计算得出)</p><p>东八区时上午6:00，沈阳大东区滂江街的太阳方位大致为77.37°(北方位角)以目标物正北方向为0°，顺时针逐渐变大，如正东为90°，77.37°介于北与东之间，故第一题选东北。</p><img src="/assets/images/crimaster/2021/05/20210521-ans-3.png" alt="图片" class="post-image half"><p>第二题：</p><p>本题无积分奖励，这里和大家道歉，因审核人员和作者存在一定争议，又查阅了很多材料，证实这道题有BUG，很难确定是否能伪造出此种脚印，线索也不全，客服人员在群内又会错意发送了“奇怪”的通知，所以不便于加分，请理解。</p><img src="/assets/images/crimaster/2021/05/20210521-ans-4.png" alt="图片" class="post-image half"><p>由于每个人的行走姿势和身体状况不同，所以遗留的足迹会各不相同，有磕痕、踏痕、推痕、跄痕、提痕、坐痕、迫痕、压痕、拧痕、抬痕、蹬痕、挖痕、抠痕、甩痕、挑痕、踢痕、划痕、扫痕和擦痕等。</p><img src="/assets/images/crimaster/2021/05/20210521-ans-5.png" alt="图片" class="post-image half"><p>第三题：</p><p>象牙塔指的是大学，桃李满天下用于形容教师，但选项中都是大学，同有老师教书育人，所以这句话并不能直接判断出是选项中的哪一所大学我们用后面一句坐北朝西来解题。</p><p>沈阳师范大学坐落在沈北新区，大门朝向西边。而选项中辽宁大学的两个校区一个正门朝南个正门朝东，都不符合。所以答案锁定在沈阳师范大学中。</p><img src="/assets/images/crimaster/2021/05/20210521-ans-6.png" alt="图片" class="post-image half"><p>后两句“民以食为天”，所以民之天指的是吃饭的地方，“火之位”，方位中能代表火的是南方，所以指的是沈阳师范大学南区食堂。</p>]]></content>
    
    
    <summary type="html">20210521期《大学生失踪案》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="刑侦推理-解答" scheme="http://yoursite.com/tags/%E5%88%91%E4%BE%A6%E6%8E%A8%E7%90%86-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>大学生失踪案</title>
    <link href="http://yoursite.com/2021/05/crimaster-reasoning-disappearance-of-college-student/"/>
    <id>http://yoursite.com/2021/05/crimaster-reasoning-disappearance-of-college-student/</id>
    <published>2021-05-21T00:00:00.000Z</published>
    <updated>2021-05-22T07:09:15.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="案件介绍"><a href="#案件介绍" class="headerlink" title="案件介绍"></a>案件介绍</h1><p>5月21日，CRIMASTER平台接到一桩委托，委托人是一名在沈阳的在校大学生。</p><p>其于昨夜23:00左右收到装有奇怪字条和一张照片的信封，向其发送字条和照片的人声称绑架了该名大学生的一个女同学，如果不能在24小时内来到指定位置，他将会永远见不到那个女孩。</p><p>委托人在受到恐吓后多次回拨电话，可始终联系不上。无奈之下他定将这件事情委托给CRIMASTER犯罪大师的侦探们!</p><h1 id="现场侦测"><a href="#现场侦测" class="headerlink" title="现场侦测"></a>现场侦测</h1><p>信封上面只有送信人和委托人的指纹，字条上面未采集到有效指纹字条内容为电脑打印。委托人询问过送信人，但追溯下去并没有找到相关线索，字条的作者可能拥有定的反侦察能力。</p><h1 id="纸条线索"><a href="#纸条线索" class="headerlink" title="纸条线索"></a>纸条线索</h1><h2 id="正面"><a href="#正面" class="headerlink" title="正面"></a>正面</h2><p>“照片上这个女人你一定很熟悉吧，她现在在我手上，如果你想要让她安然无恙，就在24小时之内，一个人来到我指定的位置。不然，你永远别想见到她了“。字条结尾有几滴红色液体溅落的痕迹。</p><h2 id="背面"><a href="#背面" class="headerlink" title="背面"></a>背面</h2><p>“象牙塔上挂桃李，生来坐北面朝西，火之位，民之天!地点告诉你了，抓紧时间，就在你所在的城市，记住，一个人来，否则…后果自负。</p><h2 id="照片线索"><a href="#照片线索" class="headerlink" title="照片线索"></a>照片线索</h2><p>信封中的照片为一个女孩被捆绑在椅子上的背影照，形似委托人的同学。</p><h2 id="足迹照片"><a href="#足迹照片" class="headerlink" title="足迹照片"></a>足迹照片</h2><p>委托人还附上了一张照片，据说是在其朋友所租房屋附近发现的，照片拍摄于5月21日06:00，照片上是一串足迹，其脚尖正好指向太阳所在方向，脚印前浅后深，在脚印前部分未发现抠痕、挖痕，在足迹后边沿出现月牙形痕迹，脚尖方向朝向现场方向，失踪者房屋所在地为大东区滂江街。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>脚尖指向的具体方向是(本题略加照片显示的视觉偏差，运用知识限于中学阶段，脚尖的方向即当时太 阳所在的方向)?<br> A.东北<br> B.正东<br> C.东南</li></ol><ol start="2"><li>能否确定足迹的主人朝着房屋方向移动?(无故意伪造情况)<br> A.可以确定<br> B.无法确定</li></ol><ol start="3"><li>会面地点在哪？<br> A.辽宁大学蒲河校区食堂<br> B.辽宁大学崇山校区食堂<br> C.沈阳师范大学南区食堂<br> D.沈阳师范大学北区食堂</li></ol>]]></content>
    
    
    <summary type="html">5月21日，CRIMASTER平台接到一桩委托，委托人是一名在沈阳的在校大学生……</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="刑侦推理" scheme="http://yoursite.com/tags/%E5%88%91%E4%BE%A6%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>枪弹痕迹科普篇-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-reasoning-bullet-marks-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-reasoning-bullet-marks-ans/</id>
    <published>2021-05-19T12:00:00.000Z</published>
    <updated>2021-05-22T03:06:58.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><ol><li>哪个伤口为射入口？<br><font color="#56c596">A.创口A</font><br>B.创口B</li></ol><ol start="2"><li>该案件中枪的射击距离更可能为?<br>A.接触射击<br><font color="#56c596">B.近距离射击</font><br>C.远距离射击</li></ol><ol start="3"><li>该案件所用枪支可能为?<br>A.54式手枪<br><font color="#56c596">B.64式手枪</font><br>C.伯塔92F<br>D.M1911手枪</li></ol><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>射入口指弹头穿入人体皮肤组织所形成的创口.基本形态呈圆形或椭圆形，与弹头直径相似或略小。最能反映枪弹射入口特征的是创口中心部位的皮肤、创口边缘及周边组织。按射击距离分为接触射入口、近似接触射入口、近距离射入口中距离射入口及远距离射入口。</p><p>射入口常有组织缺损，而使射入口处的皮肤不能完全合拢。射入口内缘皮肤上有弹头穿过时与皮肤摩擦碰撞形成的一圈擦伤和挫伤，习惯上称为冲撞轮或挫伤轮。</p><p>射出口是指进入体内的弹头穿破皮肤飞出体外形成的损伤。创口周围无烟晕和火药颗粒，无挫伤轮及擦试轮。</p><p>所以第一题选A</p><p>本题第二问为该篇章赛点题目，相对其他两题较有难度。其他两题通过查询资料即可找到相应答案，而本题设置了一个赛点混淆之处，首先根据伤口形态可直接排除远距离射击，远距离射击射入口难以发现烧伤、烟晕以及火药斑纹。再根据所描述创口周围未见烧灼、熏黑等形态，确定伤口更符合近距离射击。64式手枪是否能够贯穿人体成了一个不确定因素，我们回顾题目，题目中并未对尸体的年岭、性别、是否成年、健硕还是身体单薄有过描述，我们结合提问中的“更有可能”得出答案为B。<font style="color:#D9730D">(PS:64式手枪威力虽不大，但有实际研究证明在30cm以内64式手枪具有贯穿能力，图示来源贵州市公安干部学院以及浙江省仙居县人民检察院所作实验研究)</font></p><font style="color:#D9730D"><img src="/assets/images/crimaster/2021/05/20210519-ans-1.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210519-ans-2.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210519-ans-3.png" alt="图片" class="post-image half"><p>接触射击指枪口紧贴皮肤进行射击。形态为皮下及射创管起端的周围组织被熏黑、干焦，并有大量颗粒附着。创口周围组织可能被烧焦，而创口周围的皮肤上烟晕和火药颗粒沉着可能很轻，甚至缺失。当接触射击部位的皮肤下面即为密质骨时，可形成皮肤创口边缘不整、面积较大的星芒状或十字形缺损，呈“爆炸性”接触射入口，一般见于头部，常在前额、乳突、眉心或颞部等部位。接触射击发生在体腔(如腹腔)表面或软组织很丰富的部位时，高压气体有足够的空间膨胀，因而不会造成皮肤的较大的缺损和边缘不齐。创口周围的皮肤或衣着上可见到圆形或半月形印痕称枪口印痕。</p><p>第二题选B</p><p>注:例如北约7.62x51(7.62代表子弹的口径，51代表弹壳的长度，单位是毫米)</p><p>64式7.62mm手枪弹该弹也称7.62x17mm手枪弹，是建国后我国自行研制的第一种枪弹，于1964年设计定型，1980年完成生产定型。配用64式、77式手枪和67式7.62mm微声手枪时，用以杀伤50m内有生目标，主要供部队指挥员和公安人员自卫用。</p><p>中文名:64式手枪弹</p><p>该弹全弹质量7.2～7.7g，弹头直径7.80～7.85mm，全弹长24.4～25mm，弹头长12.5mm，初速290～310m/s，最大膛压平均值123MPa。25m处射击密集度R50不大于3cm，R100不大于7cm。</p><p>该弹弹头采用圆头、铅心、黄铜被甲结构，被甲较厚，底部为一半径5.3mm的半球面状凹底。采用无凸缘式底缘弹壳，弹壳底缘直径是8.44毫米，弹壳为筒形，无突缘，采用伯尔丹式无锈蚀底火。</p><p>此弹现为警用手枪六四式手枪专用弹。</p><img src="/assets/images/crimaster/2021/05/20210519-ans-4.png" alt="图片" class="post-image half"><p>线索中的尺寸符合该枪支，所以第三题选择B</p><p>其余介绍：</p><p>54式手枪采用7.62x25mm手枪弹，全弹质量9.9～10.7g，全弹长34.4～34.9mm，初速420～450m/s，最大膛压平均值210MPa。25m处射击密集度R50不大于5.0cm，R100不大于15cm。该弹弹壳原为黄铜材料，1964年改为覆铜钢。弹壳为瓶形，无突缘，采用伯尔丹式无锈蚀底火。弹头中的铅心换为钢心即DAP51B式7.62mm手枪弹。</p><img src="/assets/images/crimaster/2021/05/20210519-ans-5.png" alt="图片" class="post-image half"><p>伯莱塔92F采用9x19mm手枪弹即帕拉贝鲁姆9mm手枪弹，全弹质量12.05g，全弹长29.70mm，初速396m/s，平均最大膛压201MPa，散布精度(50m距离)平均散布半径7.6cm</p><p>弹头类别:普通弹，弹头结构:卵形平底、铅心、全被甲，弹头被甲材料：黄铜或覆铜钢。弹型式无凸缘、直筒形，弹壳材料:黄铜、覆铜钢、钢壳或铝壳。底火类型：伯丹式或博克塞式。</p><img src="/assets/images/crimaster/2021/05/20210519-ans-6.png" alt="图片" class="post-image half"><p>M1911手枪采用0.45in柯尔特自动手枪弹，口径0.45in(11.43mm)，全弹质量21.2g，全弹长 32.19mm，弹头直径11.48mm，弹头长17.46mm， 弹头质量15.16g，弹壳型式无凸缘、筒形，弹壳长22.79mm，初速250m/s，平均最大压131MPa，散布精度(距离射弹全散布面矩形对角线平均45.7m)值不大于19cm。</p><p>弹头类别:普通弹，弹头结构:圆头、平底、铅心、全被甲，弹壳材料:黄铜或钢，底火类型：博克塞式或伯丹式。</p><img src="/assets/images/crimaster/2021/05/20210519-ans-7.png" alt="图片" class="post-image half"></font>]]></content>
    
    
    <summary type="html">20210519期《枪弹痕迹科普篇》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="刑侦推理-解答" scheme="http://yoursite.com/tags/%E5%88%91%E4%BE%A6%E6%8E%A8%E7%90%86-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>枪弹痕迹科普篇</title>
    <link href="http://yoursite.com/2021/05/crimaster-reasoning-bullet-marks/"/>
    <id>http://yoursite.com/2021/05/crimaster-reasoning-bullet-marks/</id>
    <published>2021-05-19T00:00:00.000Z</published>
    <updated>2021-05-22T02:35:29.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="案件介绍"><a href="#案件介绍" class="headerlink" title="案件介绍"></a>案件介绍</h1><p>2021年5月19日早上05:00在云南边境处发生一场恶劣枪击案件。近日云南边境处有军火以及毒品交易，警方正调查之中，但犯罪团伙极其狡诈，警方一直未有进展。</p><h1 id="现场侦测"><a href="#现场侦测" class="headerlink" title="现场侦测"></a>现场侦测</h1><p>死者手中紧握一相机胶卷，对胶卷进行调查，该死者之前在广州，5月16日到云南旅行，相机内有大量犯罪团伙的犯罪照片，为警方提供了大量调查线索，但因其独自潜伏调查招致犯罪团伙袭击身亡。现场未检查到其余物品。</p><h1 id="伤口鉴定"><a href="#伤口鉴定" class="headerlink" title="伤口鉴定"></a>伤口鉴定</h1><h2 id="正面伤口"><a href="#正面伤口" class="headerlink" title="正面伤口"></a>正面伤口</h2><p>正面心脏处见一圆形创口(创口A)，创口中心皮肤缺失，直径0.7cm。周围有0.4cm挫伤轮。周围有烟晕以及火药斑纹。</p><h2 id="背面伤口"><a href="#背面伤口" class="headerlink" title="背面伤口"></a>背面伤口</h2><p>背面心脏处见一不规则创口(创口B)，创缘干燥，大小为1.1cm*0.9cm。</p><h1 id="子弹分析"><a href="#子弹分析" class="headerlink" title="子弹分析"></a>子弹分析</h1><h2 id="弹头详情"><a href="#弹头详情" class="headerlink" title="弹头详情"></a>弹头详情</h2><p>弹头直径7.84mm，弹头长12.5mm，弹头质量4.8g，圆头，黄铜被甲结构，铅心。</p><h2 id="弹壳详情"><a href="#弹壳详情" class="headerlink" title="弹壳详情"></a>弹壳详情</h2><p>弹壳长17mm，壳重2.5g，无凸缘式底缘弹壳，底缘直径8.44mm。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>哪个伤口为射入口？<br>A.创口A<br>B.创口B</li></ol><ol start="2"><li>该案件中枪的射击距离更可能为?<br> A.接触射击<br> B.近距离射击<br> C.远距离射击</li></ol><ol start="3"><li>该案件所用枪支可能为?<br> A.54式手枪<br> B.64式手枪<br> C.伯塔92F<br> D.M1911手枪</li></ol>]]></content>
    
    
    <summary type="html">2021年5月19日早上05:00在云南边境处发生一场恶劣枪击案件。近日云南边境处有军火以及毒品交易，警方正调查之中，但犯罪团伙极其狡诈，警方一直未有进展…</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="刑侦推理" scheme="http://yoursite.com/tags/%E5%88%91%E4%BE%A6%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>暴风雨之夜-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-reasoning-stormy-night-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-reasoning-stormy-night-ans/</id>
    <published>2021-05-16T12:00:00.000Z</published>
    <updated>2021-05-22T06:55:16.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><ol><li>死者左肩皮肤挫伤是什么伤?<br><font color="#56c596">A.生前伤</font><br> B.死后伤<br> C.无法判断</li></ol><ol start="2"><li>嫌疑人当中有几个人在口供中撒谎?<br> A.无人撒谎<br> B.1人<br> C.2人<br><font color="#56c596">D.3人</font>  </li></ol><ol start="3"><li>本案的凶手为?<br> A.方权<br><font color="#56c596">B.罗通</font><br> C.冯伟</li></ol><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>警方发现嫌疑人三人中罗通的穿着有些奇怪，修长宽松的长裤以及中筒靴子，深圳市的当日温度高达三十多度，其被审讯时一直在出汗，加之其家中的碘酒气味使警方对罗通产生了怀疑，在仔细调查后发现罗通脚踝处有抓伤，且死者左手指缝间的人体组织经检测为罗通，通过对罗通的审讯，最终罗通承认了自己的杀人事实。</p><p>推理过程： </p><p>首先看尸检报告</p><img src="/assets/images/crimaster/2021/05/20210516-ans-1.png" alt="图片" class="post-image half"><p>生活反应是判断生前伤和死后伤的重要标准，在此案中，上述黄色字体损伤皆可见明显出血，所以为生前伤，而绿色字体损伤未见液体渗出，无生活反应，所以为死后伤。</p><p>通过这个我们得知死者死后再一次遭受损害。</p><p>之后看现场情况</p><p>从现场公交车站损坏来看，可以发现公交车站主要损坏地方是公交车座椅(序号3)与公交站牌(序号1)，这里同样印证了上述死者受到多次损害的事实。</p><p>再来看监控1和2</p><p>通过两个监控信息以及嫌疑人汽车信息，我们可以判断出以下信息：</p><p>黑色车辆A，方权，中间时间10分钟<br>红色车辆B，罗通，中间时间10分钟<br>白色面包车C，冯伟，中间时间15分钟</p><p>而两监控相聚仅500米，在通畅的路面行驶根本用不上10分钟。所以三人的行驶时间都很可疑。</p><p>接下来，我们需要判断案发现场以及椅子与站牌损坏分别是由谁造成的</p><p>死者尸体是在花坛处发现，从尸检报告以及公交车站遗留血迹的情况，还有尸体上撞击痕迹，可以猜测第一案发现场为公交车站，事后有人进行挪动尸体，将尸体隐藏至花坛内。</p><p>从路面痕迹(序号5)以及汽车方权轮胎磨损来判断，而椅子(序号3)的剧烈变形以及椅子下的黑色汽车残符合方权汽车颜色和保险杠损伤，而前窗玻璃两处破损情况与死者损伤符合随着汽车前进的动能和人体后移惯性力的作用，人体向前窗玻璃方向滑动，并于前窗玻璃发生碰撞相吻合，汽车与小黄车发生碰撞，出现刮蹭痕迹，所以可以判断座椅损坏是方权造成，而公交站牌的玻璃破碎与冯伟面包车雨刷底端玻璃碎渣吻台，所以可以看出站牌损害是由冯伟开碎造成，再加上靠近站牌的椅子(序号2)左侧刮痕与冯伟汽车左侧门把手下方刮蹭吻合，我们可以猜测当时情况为冯伟因为某些原因导致面包车撞向公交车站，与椅子(序号2)发生刮蹭，最终撞向站牌。</p><p>同样冯伟车轮的人体组织与死者相吻合，符合碾压痕迹，而当时死者已经身亡，撞击造成的伤口皆为死后伤，冯伟去时死者已经遇害身亡，所以排除冯伟嫌疑。</p><p>从尸检上的后脑勺创伤以及伤口处碎渣，花坛边缘石块的鲁米诺反应可以看出死者被撞后有人用石块敲打其后脑勺，导致最后的死亡，这里将嫌疑人锁定在方权与罗通之间。</p><p>进一步锁定凶手</p><p>从死者左手手指弯曲僵直以及手指缝的人体组织，可以判断死者生前与凶手有过接触，方权身短袖短裤，如果身上有伤口应较容易观察到罗通在夏季身着长裤长靴，掩盖的寓意较为明显，加上家中的碘酒味道可判断死者生前对凶手造成的抓伤就在罗通身上，而经过尸检可知死者致命伤为后脑勺处创伤，且遭受伤害后立即死亡，所以方权的第一撞并没有让死者立即死亡而随后赶到的罗通才是真正的凶手。</p><p>当梳理出整个故事线后再来看第二题</p><p>嫌疑人的慌言，这里需要明确一点死者老公作为协助调查人员，并不属于嫌疑人，本案嫌疑人有三位，并且全部都有说谎。</p><p>人物行为逻辑</p><p>林倩</p><p>最近因为和老公吵架，再加上公司出了问题，心情一直不好，当天也没什么心情聚餐，所以早早离开，为躲雨在公交车站等待并接电话，因为没打到车，所以当方权驾驶小车过来时，林情尝试招停方权。</p><p>罗通</p><p>南星集团出现问题，另一家公司找上罗通说只要他能够拿着南星技术部的核心资料，就可以高工资录用他，而公司技术部资料一直由部门经理林倩个人保管，开始罗通想和林倩一起跳槽，但惨遭林倩拒绝，可他并没有放弃，还专门调查了资料储存位置，当天聚会知晓林倩离开后，立即给林倩打电话询问其地址，想试图说服林倩，也想趁机拿U盘，当他到达成华大道时，此时林倩已经被前面的方权撞至重伤，罗通前去拿u盘并没有料到林倩没有死，在被林倩抓住脚踝后，担心林倩被人救下说出U盘之事，于是心生杀意，并想借此嫁祸给车祸肇事主，眼瞧四下无人，在花坛里寻觅了一块石砖对林倩的后脑进行重击，导致了林倩最终的死亡，拿到U盘后，为了将其伪造成车祸现场，所以并没有对尸体进行掩盖，随手将石块丢到一旁的花坛处，第二天立马换上了宽松略长的长裤以及中筒靴子，都是为了掩盖伤痕，而在警方询问时，也为了不让警察怀疑自己，转移警方的注意力，所以主动承认了自己想要U盘的事实，将罪行嫁祸给方权，车上水渍皆表明当晚罗通下过车，鞋上沾水，车内雨伞表明当晚罗通打伞了，紧张是因为拿了死者U盘，并且是杀死死者的真凶，因脚踝被抓伤，罗通在家中使用了碘酒对伤进行处理，而这些细微的线索最终让警方察觉出端倪锁定了案件的真凶。</p><p>方权</p><p>年号科技公司程序员，前几天因父亲病逝近，回家处理后事，当天早上老板找他聊天，字里行间都是叫其赶紧来上班，不敢怠慢的方权，当即收抬好后事，又连夜赶回，连续六个小时的疲劳驾驶，使他在驾驶途中神智较不清醒，撞向死者发生了意外，下车后的方权看到倒在地下的死者误以为自己撞死了她，慌忙之下离开，而当警察找到自己的时候，因为以为自己是凶手所以极力想隐藏自己，甚至用撞树这种漏洞百出的谎话，因汽车损坏严重，方权只好先将汽车开至修车厂进行维修</p><p>冯伟</p><p>因为母亲病重疯狂接单，当天本是休息，约了兄弟们喝酒，随后接单，因为酒驾撞到公交车站牌，造成车前陷，下车后发现一旁的尸体，以为是自己撞死的，当警察找到自己时，因为以为自己是凶手，所以想隐瞒自己是凶手的事实，否认自己喝酒的事实，他的朋友怕警察知道冯伟当晚酒驾，所以说了谎，而以为自己撞死人的冯伟收行李准备安顿好还在医院的母亲便逃跑，被警方查到。</p><p>案件还原</p><p>死者林倩结束聚会后，骑着单车来到成华大道，00:20的时候听到手机铃声，老公打来的，此时暴雨开始下大，林倩想想还是停车接电话，顺便在一旁公交车站牌处躲雨，接了电话告诉自己老公自己在回去的路上，而另一边的罗通因为想要弄到林倩手中的核心资料，也没心思聚会，打电话给林倩问起目前地点，还以送她回家为由，让她在原地等待，但林倩本并不想麻烦罗通，打算自己骑车离去，可雨越下越大，林倩只好继续等待，并使用打车软件试图打车，可并没有人接单，此时经过六个小时疲劳驾驶的方权开着自己的车来到成华大道，00:40经过监控1，林倩看到车试图拦下，但方权因为疲劳驾驶，加上暴雨的故，酿成了一场悲剧，当他清醒过来的时候，方权下车望着倒在地下的林倩，慌了神，方权以为自己撞死了死者，当即慌张的开车逃逸，随后赶到的罗通来到成华大道，发现倒在血泊当中的林倩，上前准备拿U盘，但此时的林倩并没有死，求生欲望让她紧紧抓佳罗通的脚踝，罗通怕死者被救下，将自己盗取U盘的事情揭发，在花坛里寻觅了一块石砖对林倩的后脑进行重击，并嫁祸给车祸，最终导致林倩的死亡，罗通随手将石块丢到花坛边上，翻找出了挎包中的U盘，开车离开，最后深夜接单的冯伟赶到，因为刚喝完酒的原因，加上暴雨导致视线模糊，面包车撞向公交车站，导致站牌玻璃破碎，瞬间清醒的冯伟下车查看面包车，发现一旁的尸体，误以为是自己撞死的，情急之下将尸体拖至附近花坛，随后离开。</p><p>道路干万条，安全第一条，行车不规范，亲人两行泪。希望各位广大司机能够遵守交通规则，不疲劳驾驶，不酒驾，喝酒不开车，开车不喝酒，连续驾驶四个小时需停车休息，休息时间不能少于20分钟</p><p>《道路交通安全法》</p><p>第二十二条机动车驾驶人应当遵守道路交通安全法律、法规的规定，按照操作规范安全驾驶、文明驾驶。</p><p>饮酒、服用国家管制的精神药品或者麻醉药品，或者患有妨碍安全驾驶机动车的疾病，或者过度疲劳影响安全驾驶的，不得驾驶机动车。</p><p>任何人不得强迫、指使、纵容驾驶人违反道路交通安全法律、法规和机动车安全驾驶要求驾驶机动车。</p><p>公安部123号令有明确的规定：对连续驾驶中型以上载客汽车、危险物品运输车辆超过4小时未停车休息或者停车息时间少于20分钟的驾驶人记12分；对连续驾驶中型以上载客汽车、危险物品运输车辆以外的机动车超过4小时未停车休息或者停车休息时间少于20分钟的驾驶人记6分。</p>]]></content>
    
    
    <summary type="html">20210516期《暴风雨之夜》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="刑侦推理-解答" scheme="http://yoursite.com/tags/%E5%88%91%E4%BE%A6%E6%8E%A8%E7%90%86-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>暴风雨之夜</title>
    <link href="http://yoursite.com/2021/05/crimaster-reasoning-stormy-night/"/>
    <id>http://yoursite.com/2021/05/crimaster-reasoning-stormy-night/</id>
    <published>2021-05-16T00:00:00.000Z</published>
    <updated>2021-05-22T06:24:00.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="案件介绍"><a href="#案件介绍" class="headerlink" title="案件介绍"></a>案件介绍</h1><p>2021年5月16日上06:30，深圳市警方接到报案称在成华大道附近花坛发现一具尸体，警方很快赶到并封锁现场。由于昨晚下暴雨，现场痕迹被大雨冲刷，勘察陷入困境。由于案件性质恶劣，案情十分复杂，警方现決定将线索公布至CRIMASTER，希望各位侦探协助警方侦破案件……</p><h1 id="现场侦测"><a href="#现场侦测" class="headerlink" title="现场侦测"></a>现场侦测</h1><img src="/assets/images/crimaster/2021/05/20210516-1.png" alt="图片" class="post-image half"><p>成华大道是一条东西走向的单行道(由东向西)。</p><ul><li><p>案发现场没有监控，只有靠东边200米处有一监控以及西边300米处有监控。</p></li><li><p>尸体发现于花坛内，同时紧贴花坛外侧发现一块断裂石砖，石砖上检测到鲁米诺反应，距离尸体50米处公交车站内有一个橘黄色的单车，单车后轮剧烈变形，单车倾斜倒地，尾部有刮蹭痕迹。</p></li><li><p>公交车站处有并排的两个不锈钢座椅分别为(序号3)和(序号2)，其边角呈尖锐状，表面光滑。靠东边的不锈钢座椅(序号3)出现变形，尖锐部分凹陷。靠西边的座椅(序号2)左侧表面出现长条状刮痕。地面检测到鲁米诺反应，死者周围无石块等钝物。</p></li><li><p>座椅下发现若干汽车黑色塑料残骸。</p></li><li><p>公交车站牌(序号1)，表面玻璃破碎，碎渣大部分散落在站牌内部。广告牌(序号4)，外观玻璃无破损。</p></li><li><p>路面(序号5)有杂乱的轮胎滑印痕迹，大致方向如箭头所示。</p></li><li><p>死者身旁发现一部手机，屏幕碎裂无法开机。</p></li></ul><h1 id="林倩（死者）"><a href="#林倩（死者）" class="headerlink" title="林倩（死者）"></a>林倩（死者）</h1><h2 id="死者信息"><a href="#死者信息" class="headerlink" title="死者信息"></a>死者信息</h2><p>林倩，女，38岁，165cm，经调查死者独自来到这个城市工作。已婚，目前是南星集团技术部经理。</p><h2 id="案发当天"><a href="#案发当天" class="headerlink" title="案发当天"></a>案发当天</h2><p>据同事回忆最近部门完成了一个项目，所以昨晚部门组织聚会，吃完饭差不多十二点结束，本来约着一起去唱歌，但林倩说家里有事所以就自己先离开。</p><h2 id="天气预报"><a href="#天气预报" class="headerlink" title="天气预报"></a>天气预报</h2><p>当天夜里十二点到四点将出现持续大暴雨，温度26度～34度。(据市民所说，暴雨是00:20开始下的)</p><h2 id="尸检报告"><a href="#尸检报告" class="headerlink" title="尸检报告"></a>尸检报告</h2><p>尸体左胸下有淤青，左肩皮肤挫伤，创腔内有血枷附着，额头皮肤红肿腹部皮肤青紫，后脑处创伤，创面粗糙，创口大，伤口处有少量石头碎屑，上述损伤部位皮肤切开均见皮下组织出血;左手手肘皮肤挫伤，擦伤表面见油污祥物附着，后背有大程度的磨损，上述损伤表面未见液体渗出，切开未见皮下组织出血。死者衣物湿漉，衣物多处破损，大量软组织挫伤，多根肋骨断裂，内脏大出血，左手手指弯曲，指缝中检测出不属于死者本人的皮肤组织。经过解剖检查发现死者遭受后脑创伤后立即死亡，初步判断死亡时间为昨晚凌晨0:30到1:30</p><h2 id="挎包"><a href="#挎包" class="headerlink" title="挎包"></a>挎包</h2><p>警方在案发现场附近找到一个挎包，经确认为死者的，经同事回忆挎包内应该有死者私人物品:钱包，化妆品以及工作上的资料，和一个含有公司核心资料的U盘等。但在其包中并未发现U盘，警方扩大搜索范围无所获。</p><h2 id="公司处境"><a href="#公司处境" class="headerlink" title="公司处境"></a>公司处境</h2><p>经调查，死者所处公司近期因资金无法周转等问题拖欠员工数月工资，已有多人离职。</p><h2 id="监控录像"><a href="#监控录像" class="headerlink" title="监控录像"></a>监控录像</h2><p>警方调取监控，确定凌晨到两点之间只有三辆车经过此地，通过警方排查车牌号，确定三位嫌疑人。</p><p>距离案发现场东方向200米处有(监控1)  </p><p>00:15死者骑着单车经过<br>00:40黑色轿车A经过<br>00:50红色轿车B经过<br>01:10白色面包车C经过</p><p>距离案发现场西方向300米有(监控2)</p><p>00:50黑色轿车A经过<br>01:00红色轿车B经过<br>01:25白色面包车C经过</p><h2 id="死者老公口供"><a href="#死者老公口供" class="headerlink" title="死者老公口供"></a>死者老公口供</h2><p>“我今天早上收到消息就紧忙赶回来了，我们最近因为一些事情总吵架，我就趁着去外地出差出去散散心，昨晚我回了酒店就给她打电话，但她一直拒接，直到凌晨00:20的时候才接，电话里说她出去和同事聚会，已经在回去的路上了，没想到会发生这种事。对了警官，前段时间她和我说好像被人跟踪了，不知道和她的死有没有关系。”</p><h1 id="罗通"><a href="#罗通" class="headerlink" title="罗通"></a>罗通</h1><h2 id="嫌疑人信息"><a href="#嫌疑人信息" class="headerlink" title="嫌疑人信息"></a>嫌疑人信息</h2><p>罗通，男，32岁，178cm，南星集团技术部成员。</p><h2 id="车辆"><a href="#车辆" class="headerlink" title="车辆"></a>车辆</h2><p>罗通车辆为新款红色轿车，汽车表面无撞击痕迹，座位下有少量水渍，车内发现一把有水渍的雨伞。</p><h2 id="审问"><a href="#审问" class="headerlink" title="审问"></a>审问</h2><p><strong>警察</strong>：凌晨00:30到01:30你在干什么<br><strong>罗通</strong>：昨晚我们部门聚会，吃完饭一起去唱歌，唱歌没多久我不舒服就开车提前离开了，那个时间应该在路上。<br><strong>警察</strong>：你和死者有什么矛盾?<br><strong>罗通</strong>：倩姐是我上司，我和她能有什么矛盾。<br><strong>警察</strong>：据调查有同事说你想跳槽?<br><strong>罗通</strong>：好吧我实话实说吧，对手公司开出了高价想让我带着核心资料跳槽。昨晚我因为惦记着资料，也没什么心情唱歌。之后给林倩打电话询问地点，当时她说她在成华大道，我就过去了。我经过成华大道的时候，发现林倩就躺在那里，然后…然后我就把U盘拿走离开了。人不是我杀的!我到的时候她已经死了，我就想着搞点钱。</p><h2 id="案发调查"><a href="#案发调查" class="headerlink" title="案发调查"></a>案发调查</h2><p>警方调查时，罗通正在家中，警方在其家中闻到碘酒味道。在被询问时，罗通一直在擦汗。</p><h2 id="穿着"><a href="#穿着" class="headerlink" title="穿着"></a>穿着</h2><p>白色衬衫配套黑色长裤，以及中筒棕色靴子。</p><h2 id="手机通话"><a href="#手机通话" class="headerlink" title="手机通话"></a>手机通话</h2><p>00:25呼叫林倩，通话三分钟。</p><h2 id="聊天记录"><a href="#聊天记录" class="headerlink" title="聊天记录"></a>聊天记录</h2><p>聊天记录1：</p><p>5月12日晚20:00</p><p><strong>罗通</strong>：经理，对方开的条件可不低，反正现在公司也快撑不下去了，要不…<br><strong>死者</strong>：老罗，你知道你在说什么嘛，我们在公司待了那么久，老板可待我们不薄，这种背弃公司的事我可干不出来!<br><strong>罗通</strong>：倩姐，我也不想呀，可我上有一大家子要养活，公司已经几个月没发工资了。<br><strong>死者</strong>：这都只是暂时的，只要我们把手头上的这个项目做完一切都会好起来的。</p><p>聊天记录2:</p><p>5月15日晚22:30</p><p><strong>李老板</strong>：怎么样了?<br><strong>罗通</strong>：放心，我已经调查清楚核心资料的位置了，我肯定会带着核心资料来贵公司的，等我好消息吧。</p><h1 id="方权"><a href="#方权" class="headerlink" title="方权"></a>方权</h1><h2 id="嫌疑人信息-1"><a href="#嫌疑人信息-1" class="headerlink" title="嫌疑人信息"></a>嫌疑人信息</h2><p>方权，男，28岁，175cm，年号科技公司的一名程序员。</p><h2 id="车辆-1"><a href="#车辆-1" class="headerlink" title="车辆"></a>车辆</h2><p>方权的车为黑色轿车，车前保险杠受损，有几处残缺，车前盖中部凹陷变形，前窗玻璃有两处放射性裂纹，车左侧方有几道不明长条状刮痕，车窗处刮痕有停顿，出现明显轻微凹陷轮胎有一定程度的磨损，车辆内部驾驶位下有少量水渍。汽车外壳以及轮胎检测到鲁米诺反应。</p><h2 id="审问-1"><a href="#审问-1" class="headerlink" title="审问"></a>审问</h2><p><strong>警察</strong>：凌晨00:30到01:30你在哪?<br><strong>方权</strong>：警官，我昨晚在开车，前几天我父亲去世，我回去操办丧事，因为公司有点事，昨天连夜往这边赶。<br><strong>警官</strong>：你的车是什么情况?<br><strong>方权</strong>：你说那车呀，那个是我今天早上三点多快到家的时候有点迷糊，不小心撞到路边树上的。警官，你可要相信我，我和那人又不认识，我杀她干嘛啊。</p><h2 id="案发调查-1"><a href="#案发调查-1" class="headerlink" title="案发调查"></a>案发调查</h2><p>警方调查沿途监控发现该车辆当晚连续行驶六个小时，警方找到方权时，他正在一个汽车修车行。被询问时神情较紧张。</p><h2 id="穿着-1"><a href="#穿着-1" class="headerlink" title="穿着"></a>穿着</h2><p>短袖T恤与黑色短裤，黑色皮鞋。</p><h2 id="手机短信"><a href="#手机短信" class="headerlink" title="手机短信"></a>手机短信</h2><p>5月15日上午10:30</p><p><strong>上司</strong>：小方呀，那边的事处理的怎么样了<br><strong>方权</strong>：已经快处理完了<br><strong>上司</strong>：节哀啊，但人生还有很多事要做的呀<br><strong>方权</strong>：知道，我把这边忙完就赶回去<br><strong>上司</strong>：不急不急，你先忙去吧</p><h1 id="冯伟"><a href="#冯伟" class="headerlink" title="冯伟"></a>冯伟</h1><h2 id="嫌疑人信息-2"><a href="#嫌疑人信息-2" class="headerlink" title="嫌疑人信息"></a>嫌疑人信息</h2><p>冯伟，男，30岁，身高177cm，拉货公司的一名员工。</p><h2 id="审问-2"><a href="#审问-2" class="headerlink" title="审问"></a>审问</h2><p><strong>警察</strong>：凌晨0:30到1:30你在干嘛？<br><strong>冯伟</strong>：警官，当天晚上俺接了一单生意，就连忙往顾客那边赶了。<br><strong>警察</strong>：那你的车是什么情况?<br><strong>冯伟</strong>：那个车啊，干俺们这行的平时磕磕碰碰的不是很正常嘛，可能是搬货的时候不小心撞到的吧。<br><strong>警察</strong>：你昨晚喝酒了?<br><strong>冯伟</strong>：酒驾?可不敢可不敢，俺是老实人，你不信可以问俺兄弟。<br><strong>冯伟</strong>：警官，你快把我放了吧!俺已经错过好几个单了，俺还要挣钱给俺娘治病!</p><h2 id="车辆-2"><a href="#车辆-2" class="headerlink" title="车辆"></a>车辆</h2><p>冯伟车辆为中型面包车，是公司的车，车前盖出现多处凹陷变形，车辆左车门门把手下方处有轻微刮痕，白色漆脱落，前轮提取到人体组织样物，车窗雨刷底端缝隙发现少量玻璃碎渣，轮胎有一定程度的磨损，车辆内部驾驶位下有少量水渍。</p><h2 id="警方调查"><a href="#警方调查" class="headerlink" title="警方调查"></a>警方调查</h2><p>警方在其家中将其带回警局，被发现时其家中贵重物品已被打包，警方询问时也显的坐立不安。</p><h2 id="订单信息"><a href="#订单信息" class="headerlink" title="订单信息"></a>订单信息</h2><p>5月16日00:30在平台接了一运货订单，5月16日01:50主动取消。</p><h2 id="穿着-2"><a href="#穿着-2" class="headerlink" title="穿着"></a>穿着</h2><p>黑色短袖配上黑色八分裤，灰色运动鞋。</p><h2 id="朋友口供"><a href="#朋友口供" class="headerlink" title="朋友口供"></a>朋友口供</h2><p>冯伟这小子这段时间和疯了一样，拼命接单，我也都知道他母亲住院得动手术，需要钱，想帮他，但这小子倔的很，怎么说也不收，当天本来是他休息，可他看到订单就接。警官，他可没喝酒啊，我是一滴都没让他喝。</p><h2 id="医院通知单"><a href="#医院通知单" class="headerlink" title="医院通知单"></a>医院通知单</h2><p>请尽快交齐手术费用48000元，5月12日</p><h2 id="聊天记录-1"><a href="#聊天记录-1" class="headerlink" title="聊天记录"></a>聊天记录</h2><p>5月15日23:15</p><p><strong>兄弟</strong>：老冯，今天晚上不出来整一杯?难得休息一天<br><strong>冯伟</strong>：搞就搞，怕你不成!<br><strong>兄弟</strong>：行，老地方见。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>死者左肩皮肤挫伤是什么伤?<br> A.生前伤<br> B.死后伤<br> C.无法判断</li></ol><ol start="2"><li>嫌疑人当中有几个人在口供中撒谎?<br> A.无人撒谎<br> B.1人<br> C.2人<br> D.3人  </li></ol><ol start="3"><li>本案的凶手为?<br> A.方权<br> B.罗通<br> C.冯伟</li></ol>]]></content>
    
    
    <summary type="html">2021年5月16日上06:30，深圳市警方接到报案称在成华大道附近花坛发现一具尸体，警方很快赶到并封锁现场。由于昨晚下暴雨，现场痕迹被大雨冲刷，勘察陷入困境。由于案件性质恶劣，案情十分复杂，警方现決定将线索公布至CRIMASTER，希望各位侦探协助警方侦破案件……</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="刑侦推理" scheme="http://yoursite.com/tags/%E5%88%91%E4%BE%A6%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>古国文明-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-civilization-of-ancient-country-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-civilization-of-ancient-country-ans/</id>
    <published>2021-05-14T12:00:00.000Z</published>
    <updated>2021-05-17T15:10:49.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>次声波</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>1、辨认出的文字中，“法老”对应古埃及、“婆罗多”对应古印度、“黄河”对应中国，可以联想到四大文明古国，“楔形”、“阿卡德”和“乌尔”对应古巴比伦王国之前的苏美尔王朝、阿卡德王国和乌尔王朝，由此推断老人原本推开的书应该与古巴比伦有关。</p><img src="/assets/images/crimaster/2021/05/20210514-ans-1.png" alt="图片" class="post-image half"><p>2、老人最后留下的文字是古希腊字母，根据每个字母名称开头解得”MARDUK”，即马杜克，巴比伦城邦之神，对应视频日期“2009/03/02”可联想到“马杜克神像迷案”，该案件的发生正是缘于<font style="color:#D9730D">次声波</font>。</p><p>3、老人视频中的表现符合人体受到次声波影响后表现。</p><img src="/assets/images/crimaster/2021/05/20210514-ans-2.png" alt="图片" class="post-image half"><p>马杜克神像之谜的揭秘:马杜克神像是空心结构，在神像的內侧，布满了一圈圈奇怪的水波纹线条，就好似现代镭射唱片一般，而在神像外侧，以一种奇怪的规则，分布着几个风口。当风自这些风口灌入，通过这些波纹的震荡，就会形成声波振动，达到播放唱片一般的效果</p><p>由于根本无法把握风吹入侧的规律，研究者也无法再现这尊马杜克神像所可能发出来的声音。只不过可以确定的一点就是，这些声音根本就不是放给人听的。因为人耳所能接受的声波频率为20～20000赫兹，而马杜克神像所可能发出来的声音，却属于频率低于20赫兹的次声波，而这些次声波就是引发前面一系列离奇案件的”凶器”</p><img src="/assets/images/crimaster/2021/05/20210515-1.png" alt="图片" class="post-image half">]]></content>
    
    
    <summary type="html">20210514期《古国文明》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密-解答" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>古国文明</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-civilization-of-ancient-country/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-civilization-of-ancient-country/</id>
    <published>2021-05-14T00:00:00.000Z</published>
    <updated>2021-05-17T13:56:02.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>“叮咚。”电脑响了，是哥哥发来的消息。</p><p>“来找找这次的’凶器’吧。”</p><p>你的哥哥小粥是一名侦探，因为你也很热爱推理，哥哥经常会自己制作谜题发给你，来锻炼你的能力。</p><p>这次发来的谜题是视频形式，你点开全屏观察了下，看样子是装在房里的监控录制下来的，右下角的日期是<font color="#56c596">“2009/03/02”</font>，房间整体布局可以看出是一间书房，书桌上堆了一摞书，你仔细看了看，辨认出<font style="color:#D9730D">“法老”、”婆罗多”、”黄河”</font>、<font color="#5874dc">“楔形”、”阿卡德”、”乌尔”</font>、<font color="#b482c0">“古希腊文明”</font>等字眼，有一个老头在笔记本上写字，旁边还有一本推开的书，但因为那一摞书遮挡，你看不清楚。</p><p>你点击播放键，老头正在笔记本上写着什么，2、3秒后老头的手忽然颤抖起来，手里的笔也掉落在纸上，按住胸口，张开嘴呼吸急促的样子，随后老头撑着桌子起来，跌跌撞撞地奔向门口，途中摔倒了几次，看得你都担惊受怕，按了几次门把却打不开房门，随即扶着墙摇摇晃晃走到书桌，剧烈发抖的手拿起笔写了些什么，之后腿一软就倒地了。</p><p>视频到这就结束了。你反复看了几遍，发消息问哥哥:”他最后写了些什么?”</p><p>哥哥发来一张图片:</p><img src="/assets/images/crimaster/2021/05/20210514-1.png" alt="图片" class="post-image half"><p>视频中所有信息暗示着一件事件，请问该事件发生的真正原因，即哥哥所说的’凶器’!</p><p>请认真推敲剧情中的细节!</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>“凶器”的名称 三个汉字</p>]]></content>
    
    
    <summary type="html">你的哥哥小粥是一名侦探，因为你也很热爱推理，哥哥经常会自己制作谜题发给你，来锻炼你的能力。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>你是谁-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-reasoning-who-are-you-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-reasoning-who-are-you-ans/</id>
    <published>2021-05-12T12:00:00.000Z</published>
    <updated>2021-05-17T14:15:48.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><ol><li>这个房子除了你是否有其他人居住？<br>A.有<br><font color="#56c596">B.没有</font></li></ol><ol start="2"><li>相对于以下选项，哪个最不可能是你的职业？<br>A.心理学教授<br><font color="#56c596">B.医生</font><br>C.作家  </li></ol><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>最终你选择报警，警察赶到你家中发现地下室的尸体，通过调查，确定你便是那个雨夜屠夫!</p><p>你患有DID，也就是多重人格障碍，在调查中警方发现你患有DID和你从小经历脱不开关系，你从小受到父亲的虐待，和母亲相依为命，喝醉酒的父亲常常殴打母亲，有一天暴风雨夜，你亲眼看到父亲将母亲残忍的杀害，从那天开始你的身体就慢慢有了另一个人格，但他一直在沉睡，直到三个月前开始苏醒。你不知道他的存在，但他却知道你的所有事，昨天晚上你的次人格像往常样出门开车寻找猎物下手，但由于暴雨以及晚间开车，在一个红绿灯处，一个疲劳驾驶的司机开着一辆卡车从侧面撞向了你，导致你受伤并且失忆。</p><p>第一题</p><p>从日记你被人跟踪的线索，以及被删除的录像，以及书桌的计划便签习惯都说明好像房子里的确存在另一个人，但只有仔细观察便会发现这其中的矛盾。</p><p>首先计划上的打猎，可纵观房子其中并没有任何打猎用的工具，可以猜测这里写的打猎并非真的打猎，更像是“狩猎”，也就是另一个人格雨夜屠夫的计划，他的杀人计划。</p><p>日记中那句“只有我知道密码”表明能打开电脑的只有你。</p><p>卫生间的洗漱用品也只有一个人的。</p><p>家中有一个地下室，里面有许多的尸体，而你家中十分整洁，想要做到这一切需要大量的时间，而你离职经常待在家中，家中布局也较简单，如果是有另外一个人做的这些你很难不察觉。</p><p>第二题</p><p>你最不可能的职业，从书架上来看，从上到下分别对应心理学教授、医生、作家。</p><p>手机短信表明了自己作者身份，在第一题的前提下得知自己便是雨夜屠夫，地下室的被剥了人皮的尸体线索中，每一具人皮都被精致处理，连手部、面部的表皮都完整无损，这不是一般人能够做到，且不是几日便能够熟练掌握，可以说明你可能是医生，或者曾经是一名医生，并且还是个技术高超的外科医生。从线索中可以观察到心理学书籍在书架的最上层并且并不专业，连《天オ在左疯子在右》的这种小说也有，也并没有其他线索指明你心理学教授的身份，且你长时间处于一个精神不正常的状态，但在日记中你从未怀疑自己的心理状况出现问题，且心理学家大多有细微的观察能力，而你身边的各种细节你并未很迅速的察觉到。所以，相对于选项中你最不可能的身份为心理学教授。</p>]]></content>
    
    
    <summary type="html">20210512期《你是谁》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="刑侦推理-解答" scheme="http://yoursite.com/tags/%E5%88%91%E4%BE%A6%E6%8E%A8%E7%90%86-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>你是谁</title>
    <link href="http://yoursite.com/2021/05/crimaster-reasoning-who-are-you/"/>
    <id>http://yoursite.com/2021/05/crimaster-reasoning-who-are-you/</id>
    <published>2021-05-12T00:00:00.000Z</published>
    <updated>2021-05-17T13:57:56.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="案件介绍"><a href="#案件介绍" class="headerlink" title="案件介绍"></a>案件介绍</h1><p>你从医院的病床上醒来，抬眼望着周围陌生的一切，脑海里充满了疑:我是谁?我为什么会来到这里?你望着身上几处被医生缠好的绷带，脑中企图开始回忆，但一阵尖锐的疼痛不得不让你停止思考医生和你身边自称是你朋友的人见状走来，询问了你的状况并向你解释了你来到医院的原因。据医生所说，你是昨晚因为出车祸被送到医院的，但车祸并不严重，除了你的脑部受到了撞击，身体的其它部位都只是轻伤，既然醒来应该就已无大碍，再做几项检查观察一下便可出院。你对医生所说的车祸经过没有一点印象，对所有事情都失去记忆的恐惧慢慢压迫着你，你不等检查便匆匆离开了医院，想要找回记忆，你的朋友来不及劝阻，只能带着你回到你的家里，你望着这栋有些熟悉但又很陌生的房子内的种种，试图从这个地方找到一点关于自己的信息。</p><h1 id="现场侦测"><a href="#现场侦测" class="headerlink" title="现场侦测"></a>现场侦测</h1><p>你望着镜子中的自己，一张陌生的脸庞，笔直又挺拔的身材，体型中等偏瘦，戴着一副黑色眼镜，你尝试着拿下眼镜，发现这并不影响你的视力，你望着身上已经包扎过的伤口，脑海中似是有些记忆，画面忽然闪现在你的脑海，画面中是一辆汽车，你坐在汽车的驾驶位等待着红绿灯，雨刷器扑闪着刮走车前窗的雨水，副驾驶上似是有个身影，但你却如何也记不起他的长相，一束亮光从方照来，越来越刺眼，突然，画面混沌，整个世界都仿佛在晃动，随后一切重归于黑暗之中…</p><p>房间布局：</p><img src="/assets/images/crimaster/2021/05/20210512-1.png" alt="" class="post-image half"><h1 id="初始线索"><a href="#初始线索" class="headerlink" title="初始线索"></a>初始线索</h1><h2 id="车祸备案"><a href="#车祸备案" class="headerlink" title="车祸备案"></a>车祸备案</h2><p>2021年05月11日晚上22:39一辆卡车与一辆轿车于某某路段发生撞击，因现场路段无监控，车辆已被警方处理，带回相关部门做车祸鉴定。</p><h2 id="朋友谈话"><a href="#朋友谈话" class="headerlink" title="朋友谈话"></a>朋友谈话</h2><p><strong>朋友</strong>：你最近很奇怪，总说有人跟踪你，还说那个人潜入了你的家里。<br><strong>你</strong>：我有没有跟你说那个人是谁?<br><strong>朋友</strong>：没有，你好像一直也没把人找出来。以后开车可小心点，还有，你已经辞职快一个月了，从来也没跟我说过你有什么计划，想要干点什么总在家里闷着，把你一个人放在这儿我不是很放心，要不你跟我回我家住段时间?<br><strong>你</strong>：不了，我没事。<br><strong>朋友</strong>：好吧，我还有点事，你照顾好自己，有事给我打电话，我先走了。<br><strong>你</strong>：嗯，放心。</p><p>（我究竟是谁?这是我的家吗?等这人走了到屋里去看看吧……）</p><h1 id="房间线索"><a href="#房间线索" class="headerlink" title="房间线索"></a>房间线索</h1><h2 id="台历和照片"><a href="#台历和照片" class="headerlink" title="台历和照片"></a>台历和照片</h2><p>书房的书桌上有个台历和一张照片，台历上有着一个便签，上面写着:“计划安排:1.打猎 2.购买装备”照片年代有些老旧，上面是一个面庞慈善大概三十岁左右的女人正抱着一个眉眼与你有些相似的六七岁的小男孩。</p><h2 id="书架"><a href="#书架" class="headerlink" title="书架"></a>书架</h2><p>书桌的背后是一个书架，书架总共有三层，书从左到右都是从小书到大书的排列，十分整洁。<br>最上面一层有《爱的艺术》，《拆掉思维里的墙》，《天才在左，疯子在右》《怪诞心理学》…<br>中间一层有《人体断层解剖学图谱》，《人体系统解剖学》…<br>最下面一层有《小说的艺术》《百年孤独》《文学讲稿》…</p><h2 id="电脑"><a href="#电脑" class="headerlink" title="电脑"></a>电脑</h2><p>书桌上有一台台式电脑，打开需要密码，你几次尝试输入，一直显示密码错误。</p><h2 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h2><p>桌子上摆着一个牛皮封面的日记本，你翻着日记本，发现自己有每天写日记的习惯，但最近这段时间不知是有事还是想要偷懒，日记并没有每一天都写，而是断断续续，且最近的日记内容极其诡异。<br>日记部分较不正常内容：</p><p>04月02日<br>最近过的昏昏沉沉的，好像总是在睡觉，就像被人下了药一样，一觉醒来什么都不记得，日记竟然都忘记写了。</p><p>04月21日<br>家里最近是因为下雨太潮湿了吗?怎么这么多水渍下雨天我明明没有出门…</p><p>05月08日<br>他就和幽灵一样，他到底是谁，他想干嘛，他就像生活在我身边一样，甚至是住在我的家里，最近我的家里总是莫名出现一些奇怪的东西，我知道那些东西不属于我，可我却没有发现过他，但我坚信他一定存在，别人都觉得我疯了，但我清楚的知道他的存在，我准备在家里安装摄像头，我倒要看看他到底是谁!</p><p>05月10日<br>怎么可能，摄像头拍下的录像竟然失效被删除了，不可能的，电脑密码他怎么可能知道，怎么可能……这密码只有我一个人知道，只有我知道!</p><h2 id="卫生间"><a href="#卫生间" class="headerlink" title="卫生间"></a>卫生间</h2><p>洗漱台上摆放着一个漱口杯，里面有一只牙刷和一支牙膏、旁边有一支洗面奶以及一个刮胡刀。</p><h1 id="其他线索"><a href="#其他线索" class="headerlink" title="其他线索"></a>其他线索</h1><h2 id="手机线索"><a href="#手机线索" class="headerlink" title="手机线索"></a>手机线索</h2><p>你拿起了手机，想要在手机里寻找线索，一个被你单独收藏的软件《 CRIMASTER犯罪大师》引起了你的注意，其中有唯一一条被你点赞以及评论的帖子：<br>最近网络上沸沸扬扬的雨夜屠夫案，连续三个月，已有十余名女性遇，害据说这个雨夜屠夫只会在下雨的日子出现，专挑那些三十几岁的女性下手，还有很多受害者没有被找到，估计凶多吉少，这个案子你们怎么看？<br>评论：<br>据我推理，凶手专挑下雨天下手，估计是雨天对凶手本人有什么不一样的意义吧。</p><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p>5月10号<br>您的文章《你的身体里流淌着杀人犯的血液》已被收录至“鹿先森”杂志，稿费将于月底统一发送。</p><h2 id="卧室"><a href="#卧室" class="headerlink" title="卧室"></a>卧室</h2><p>室中十分整洁，但有一股淡淡的香料味道以及一股消毒水的味道，你仔细观察着卧室，并没有发现卧室里其他有异常的地方，味道好像是从衣柜里传出，你打开了衣柜，发现里面衣服都是西服，左边是浅蓝色，右边是黑色，你扒开衣服，竟发现卧室里衣柜里存在一个隐藏的密道门!你打开了门，顺着密道往下，发现了一间地下室…</p><h2 id="地下室"><a href="#地下室" class="headerlink" title="地下室"></a>地下室</h2><p>里面是一小段阶梯，你顺着阶梯走下不久便来到了地下室的房门前，打开房门，一股腐烂的味道直冲而来，抬眼望去，地下室的墙壁上悬挂着十几具血淋淋的尸体，水龙头未拧紧正朝下落着水滴，滴答滴答的声音刺激着你的灵魂，每具尸体前都摆着一张人皮，活生生的从尸体上剥下的人皮!每一具人皮都被精致处理，连手部、面部的表皮都完整无损，头皮上还连接着长发，一个个摆的整整齐齐，犹如一个个珍宝。<br>你忍住呕吐从地下室疯了一样跑了出来，瘫坐在卧室地上，你的脑海里只有一个想法，那就是报警!报警!你拿起手机刚准备按下最后的零，突然，停在了那个按键上。你…真的决定要报警嘛?</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>这个房子除了你是否有其他人居住？<br>A.有<br>B.没有</li></ol><ol start="2"><li>相对于以下选项，哪个最不可能是你的职业？<br>A.心理学教授<br>B.医生<br>C.作家</li></ol>]]></content>
    
    
    <summary type="html">你从医院的病床上醒来，抬眼望着周围陌生的一切，脑海里充满了疑:我是谁?我为什么会来到这里?你望着身上几处被医生缠好的绷带，脑中企图开始回忆，但一阵尖锐的疼痛不得不让你停止思考医生和你身边自称是你朋友的人见状走来，询问了你的状况并向你解释了你来到医院的原因…</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="刑侦推理" scheme="http://yoursite.com/tags/%E5%88%91%E4%BE%A6%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>极速破译-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-speed-decipher-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-speed-decipher-ans/</id>
    <published>2021-05-09T12:00:00.000Z</published>
    <updated>2021-05-17T14:15:48.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>春丛认取双蝶</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><font style="color:#D9730D">后续:似乎警队只是抓到了被嫁祸之人，真正的手与被嫁祸人有深仇大恨，身边至亲人的离世与被嫁祸者有关!</font></p><p>本题有多种解法，需一一尝试，因诗词的提示所以其它皆为乱序，无法得出答案。</p><p>正确解题过程：</p><p>内华达州机密区域为51区，因此所需步骤为24即所有白格都要走一遍。天空到地狱，意为自上 而下的顺序，下面有R和E，但是右下角的E只有 一条能单向通向它的路，而且又要求所有格子都走完，所以E必定是起始点或终点(所以把极高处到底端理解为字母表中从A到Z的也可以通过观察这一点排除)，同理左上角的C也能这样确定是起始或终点，所以最终只能是左上角的C到右下角的E。</p><p>提示一为“王，皇后，战车与主教”，意为国际象棋，赤兔是马，马走L型，根据提示需要走24步，从头到尾走完所经历的字母，便是答案。</p><p>(即<font style="color:#D9730D">CHUNCONGRENQUSHUANGQIDIE</font>，根据答案要求的七个汉字加上诗词的提示得到:<font style="color:#D9730D">春丛认取双栖蝶</font>)</p><img src="/assets/images/crimaster/2021/05/20210509-ans-1.png" alt="图片" class="post-image half">]]></content>
    
    
    <summary type="html">20210509期《极速破译》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密-解答" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>极速破译</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-speed-decipher/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-speed-decipher/</id>
    <published>2021-05-09T00:00:00.000Z</published>
    <updated>2021-05-17T13:56:02.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>近日刑警平次和其团队告破了一起重大连环杀人案，但最终本该庆祝的时刻，平次忽然意识到案发时凶手使用某物件所对应的身高区间，与所抓嫌疑人不符，他急忙赶回现场，在隐秘角落里发现这样一条奇怪的图文。</p><img src="/assets/images/crimaster/2021/05/20210509-1.png" alt="图片" class="post-image half"><p>文：自天空极高处直至地狱的底端，追寻赤兔的足迹。(所需步骤为内华达州机密区域所对应数字减3的一半)</p><p><font style="color:#D9730D">提示1:王、皇后、战车与主教</font></p><p><font style="color:#D9730D">提示2:诗词</font></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>七个汉字</p>]]></content>
    
    
    <summary type="html">近日刑警平次和其团队告破了一起重大连环杀人案，但最终本该庆祝的时刻，平次忽然意识到案发时凶手使用某物件所对应的身高区间，与所抓嫌疑人不符，他急忙赶回现场，在隐秘角落里发现这样一条奇怪的图文。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>哥哥的礼物-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-brother&#39;s-gift-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-brother&#39;s-gift-ans/</id>
    <published>2021-05-08T12:00:00.000Z</published>
    <updated>2021-05-17T14:15:48.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>cop</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>密码箱打开了，哥哥居然送了我一本CRIMASTERA解密本，上面还有一段哥哥写给我的话:</p><p>努力的苦读，就为这一刻！把你的实力全部发挥，所有关爱着你的人，都会为你祝福祈祷，相信你一定会考出满意的成绩！</p><p><font style="color:#D9730D">(作者在此祝愿莘莘学子们都能够金榜题名)</font></p><p>解题过程：</p><p>将连接处折叠形成一个正十二面体(提示降维打击指从三维立体到二维平面，需将平面还原成立体)十二面体中距离X最远的面是它的对面就是2，所以2就是O。骆驼英文是camel，与O相邻的面是3、5、6、7、8，所以3、5、6、7、8是camel但是具体对应还不明确。Z的一圈是X、1、5、8、4，5和8已经有字母了，所以1，4就是I、P，因为P不和Y相邻，所以1是P、4是。和Z、P都相邻的面是X和5，所以5是C，顺时针排一圈，5是C、8是A、7是M、6是E、3是L。再用和L是对面验证，成立。就剩下9，所以9是N。</p><img src="/assets/images/crimaster/2021/05/20210508-ans-1.png" alt="" class="post-image half no-limit-height"><p>按照1到9排列得policeman(警察)，将其镜像反转得到</p><img src="/assets/images/crimaster/2021/05/20210508-ans-2.png" alt="" class="post-image half no-limit-height"><p>台球中1-黄色，2-蓝色，3-红色，4-紫色，5桔色，6-绿色，7酱色，8-黑色，9-黄/白色，10-蓝/白色，11-红/白色，12-紫/白色，13-桔/白色，14-绿/白色，15-酱/白色对应就是589，即cop(警察)。</p>]]></content>
    
    
    <summary type="html">20210508期《哥哥的礼物》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密-解答" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>哥哥的礼物</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-brother&#39;s-gift/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-brother&#39;s-gift/</id>
    <published>2021-05-08T00:00:00.000Z</published>
    <updated>2021-05-17T13:56:02.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>今天是哥哥从警校回家的日子，好在他还记得我这个妹妹还有几十天就要中考了，破天荒的为我准备了一份礼物，但是需要解开密码箱才能够拿到。</p><p>箱子上的一副图和一段话如下：</p><img src="/assets/images/crimaster/2021/05/20210508-1.png" alt="图片" class="post-image half"><p>提示：</p><p>整个世界被降维打击，请准确还原。Z有两边是 I、P，骆驼顺时绕O转一圈，P、Y吵架不相邻， Z、P也和C相邻，离X最远的是O，I、L是对面，最后一处就是N。</p><p>球杆依次击中正义之职在镜子中的桔、黑及黄白寻找答案。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>三个字母的单词</p>]]></content>
    
    
    <summary type="html">今天是哥哥从警校回家的日子，好在他还记得我这个妹妹还有几十天就要中考了，破天荒的为我准备了一份礼物，但是需要解开密码箱才能够拿到。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>地球保卫战-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-earth-defense-force-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-earth-defense-force-ans/</id>
    <published>2021-05-05T12:00:00.000Z</published>
    <updated>2021-05-17T14:15:48.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>skullisland</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>观察第一幅图可知，这和猪圈密码有关</p><img src="/assets/images/crimaster/2021/05/20210505-ans-1.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210505-ans-2.png" alt="图片" class="post-image half"><p>则根据密码表根据观察得到，红对应的为M，蓝对应的为Z，紫对应的为H，根据第二张图可知， 第一张图的三个字母与第二张图的三个字母有某种正确对应关系。根据提示(找到正确的字母)，意思是告诉我们将进行字母按字母表顺序将对应。接下来将进行试错，若M对应V，H就将对应A，Z对应N，将无法按字母表顺序得到新的关系。</p><p>以此类推，最终确认M对应A，H对应V，Z对应N。如图，我们得到了新的对应表。</p><img src="/assets/images/crimaster/2021/05/20210505-ans-3.png" alt="图片" class="post-image half"><p>此时看第三张图，发现所给音素为元音音素，提示为元音密码，根据/将数字进行几个为一组的分组则可以得到</p><p>2/52/22/53/53/5/2/53/34/55/41</p><p>此时用元音密码则可以解出EWGXXUEXMZP</p><img src="/assets/images/crimaster/2021/05/20210505-ans-4.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210505-ans-5.png" alt="图片" class="post-image half"><p>此时得到的EWGXXUEXMZP带回对应表中，此时并不知道正确的明文密文对应方向，将进行两次试错：</p><p>1.若M为开头的为明文，A开头的为密文则，可得到qisjjgqjylb</p><p>2.若A开头的为明文，M开头的为密文，则可得到skullisland</p><p>综上所述，第2种有明显意义，所以答案为skull island</p><p>珂欣说:“让我们去骷髅岛？可那里不是已经沦陷了？”</p><p>浩玥说:“我们不能失去诗吟，想办法一定要去救她！”</p><p>LL说:“基地里的装备应该足以抵御那里的变异物种了！”</p><p>三人立即收拾了装备以及物资前往了骷髅岛。</p>]]></content>
    
    
    <summary type="html">20210505期《地球保卫战》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密-解答" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>地球保卫战</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-earth-defense-force/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-earth-defense-force/</id>
    <published>2021-05-05T00:00:00.000Z</published>
    <updated>2021-05-17T14:15:48.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>时间:六十世纪</p><p>地点:地球</p><p>背景:能源危机，地球生灵涂炭。</p><p>团队:地球守护小组</p><p>LL，浩玥，珂欣三人在进行飞船的研制与新能源的研究。</p><p>LL说:“诗吟去哪了?”</p><p>珂欣说:“大概三小时前，超级电波就联系不上她了。”</p><p>浩玥说:“马上进入紧急状态，去诗吟家找她”</p><p>三人带上武器装备，立即前往诗吟家。可诗吟家中的景象让三人瞠目结舌，房间凌乱不堪，有过被入侵的迹象，在一番仔细搜査后，一个用高分子纳米科技的码锁被发现，LL熟练的输入了密码。里面存放着三张图片，三人便对着图片思索起来。“她一定是要告诉我们什么信息!”</p><img src="/assets/images/crimaster/2021/05/20210505-1.png" alt="图片" class="post-image half"><p>请找到正确的对照表格并解出数字所表达的一处地点。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入答案11个字母不区分大小写及空格</p>]]></content>
    
    
    <summary type="html">LL，浩玥，珂欣三人在进行飞船的研制与新能源的研究。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>全民挑战第一期测试题-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-challenge-test-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-challenge-test-ans/</id>
    <published>2021-05-04T06:23:40.061Z</published>
    <updated>2021-05-17T14:15:47.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>狄仁杰</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>marple小姐，翻译成中文最为广泛的版本就是简・马普尔。</p><p>根据线索:在马普尔小姐的指示下。</p><p>简可拆分为三个字，竹，门，日。诗集主编为，两张图片右下有角标，分别是竹和日。按照写字顺序先竹，然后门，再者是日。</p><p>竹的图</p><img src="/assets/images/crimaster/2021/05/20210503-ans-1.png" alt="图片" class="post-image half"><p>下有一句话:字母化数，把marple在十六位字母表中的序号化出来得1311816125。接下来写”门”</p><p>诗有五首，我们把数字化成五份13/11/81/61/25。</p><p>与査询的古诗对应(在其中可能会拿数字有人去对应诗的题目，但是每一首诗都有说明作者，说明我们应该查询古诗)</p><img src="/assets/images/crimaster/2021/05/20210503-ans-2.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-ans-3.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-ans-4.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-ans-5.png" alt="图片" class="post-image half"><p>按照13/11/81/61/25尝试各种的方式对应，得出唯一合理的答案，不计算撇捺</p><p>接下来就是日的图片:</p><img src="/assets/images/crimaster/2021/05/20210503-ans-6.png" alt="图片" class="post-image half"><p>把不计算撇捺的方式带入进去:(笔画可以上各大搜索引擎查询，基本无异议</p><p>只:竖、横折、横、撇、点。</p><p>雁:橫、撇、撇、竖、撇、竖、点、横、横、橫、竖、横。</p><p>躁:竖、横折、横、竖、橫、竖、提、竖、横折、橫、竖、横折、横、竖、横折、横、横、竖、撇、捺。</p><p>年:撇、横、横、竖、横、竖。</p><p>靠:撇、横、竖、橫、竖、横折、横、竖、横、橫、橫、竖、横、横、横。</p><p>就:点、横、竖、橫折、横、竖钩、撇、点、橫、撇、竖弯钩、点。</p><p>思:竖、橫折、横、竖、横、点、斜钩、点、点。</p><p>民:横折、横、竖提、橫、斜钩。</p><p>去除撇捺，计算得:4.9.18.5.14.10.9.5。再次转 变成字母可得: DIRENJIE</p><p>答案即为狄仁杰。</p><p>我们中国著名的侦探例如宋慈，狄仁杰，包拯等，在历史上，他们是古代封建社会統治下平民的希望寄托。 </p><p>公正严明，铁面无私———包拯</p><p>公元676至679年，升为了大理寺寺丞，解決了大量积压的案件，涉案人员高达1.7万人，却没有任何人状告他判決有误———狄仁杰</p><p>中外法医界普遍认为是宋慈于公元1235年开创了“法医鉴定学”，因此宋慈被尊为世界法医学鼻祖———宋慈</p><p>我们向先人致敬。</p><p>同时，向马普尔小姐致敬。侦探精神不分年不分性别，不分国界，有的，只是你和我心中那份对推理的热爱。</p>]]></content>
    
    
    <summary type="html">202103期《全民挑战第一期测试题》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密-解答" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>全民挑战第一期测试题</title>
    <link href="http://yoursite.com/2021/05/crimaster-puzzle-challenge-test/"/>
    <id>http://yoursite.com/2021/05/crimaster-puzzle-challenge-test/</id>
    <published>2021-05-03T00:00:00.000Z</published>
    <updated>2021-05-17T14:15:47.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>我收到了一份神秘的信件，貌似是一位我在网络上结识的好友给我发来的，希望大家帮我一同破解这一份神秘的信件。信件容如下:</p><p><font style="color:#D9730D">听说你是马普尔(Jane Marple)小姐的忠实粉丝，我也是。而且我也特别喜欢中华文化，希望通过你的帮助，在marple小姐的指示下，寻找 一位我同样喜欢的侦探。</font></p><p>信中附带一本诗集，名称为“<font style="color:#D9730D">门</font>”。内容如下：</p><p><font style="color:#D9730D">古朗月行(唐・李白)</font><br><font style="color:#D9730D">摸鱼儿·春光(宋・李裕翁)</font><br><font style="color:#D9730D">暗香日时月色(宋·姜)</font><br><font style="color:#D9730D">与孟郊洛北野泉上煎茶(唐·刘言史)</font><br><font style="color:#D9730D">颂古一首其一(宋・释师一)</font></p><p>还有两张纸条：</p><img src="/assets/images/crimaster/2021/05/20210503-1.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-2.png" alt="图片" class="post-image half"><p>图下有一行字:<font style="color:#D9730D">字母化数</font></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入一位人物名称 （例:野田吴）</p>]]></content>
    
    
    <summary type="html">我收到了一份神秘的信件，貌似是一位我在网络上结识的好友给我发来的，希望大家帮我一同破解这一份神秘的信件。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="谜之解密" scheme="http://yoursite.com/tags/%E8%B0%9C%E4%B9%8B%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【转】字节跳动最爱考的64道算法题(JS版)</title>
    <link href="http://yoursite.com/2021/05/byte-dance-top-64-algorithm-problems-js-version/"/>
    <id>http://yoursite.com/2021/05/byte-dance-top-64-algorithm-problems-js-version/</id>
    <published>2021-05-02T00:00:00.000Z</published>
    <updated>2021-05-17T14:34:51.599Z</updated>
    
    <content type="html"><![CDATA[<p>本文来源于图雀社区，作者一只图雀。<br>原文链接： <a href="https://mp.weixin.qq.com/s/HsZo757NDNV-3xnGQjPtAQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HsZo757NDNV-3xnGQjPtAQ</a></p><p><font style="color:#D9730D">欢迎关注公众号：图雀社区。 如果你想从零开始以实战的方式学习一门技术，亦或是想动手做一个比较完整的项目以准备面试，相信 「图雀社区」 的内容都能够帮助到你，成为初入前端的你成长路上的指南针。</font></p><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>现在大厂面试中，算法题几乎为必考项，且近几年频现 LeetCode 真题，此篇为拿到字节、腾讯、京东 Offer 的笔者本人在准备面试过程中亲自刷过以及遇到过高频算法题。文章内容会分模块整理，对于笔者在面试过程中遇到的真题，会给予着重 【🔥】标出。</p><p>同时，可以毫不客气的说，如果你准备时间有限，又想追求算法题准备效率最大化，那么你只需要按照大纲把下面的题目刷完，并把代码烂熟于心，就几乎可以应对 90% 的面试算法考题了。</p><p>整理这篇内容的目的一个是笔者在之前准备面试时的一点积累，而它确实也帮助笔者在面试算法题中过关斩将，同时呢，也希望能够在金三银四给予拼搏的你，一点点帮助就好！💪</p><p>本篇内容包括如下模块：</p><ul><li>高频算法题系列：链表</li><li>高频算法题系列：字符串【🔥】【有真题】</li><li>高频算法题系列：数组问题【🔥】【有真题】</li><li>高频算法题系列：二叉树</li><li>高频算法题系列：排序算法【🔥】</li><li>高频算法题系列：二分查找【🔥】</li><li>高频算法题系列：动态规划【🔥】</li><li>高频算法题系列：BFS</li><li>高频算法题系列：栈【🔥】</li><li>高频算法题系列：DFS【🔥】</li><li>高频算法题系列：回溯算法【🔥】</li></ul><p>其中标🔥的部分代表非常高频的考题，其中不乏笔者遇到的原题。其中对于每一类，首先会列出包含的考题，然后针对每一道考题会给出难度、考察知识点、是否是面试真题，在每道题详细介绍时，还会给出每道题的 LeetCode 链接，帮助读者理解题意，以及能够进行实际的测验，还可以观看其他人的答案，更好的帮助准备。</p><h1 id="高频算法题系列：链表"><a href="#高频算法题系列：链表" class="headerlink" title="高频算法题系列：链表"></a>高频算法题系列：链表</h1><p>笔者遇到的高频链表题主要包含这几道：</p><ul><li>通过快慢指针寻找链表中点 【简单】</li><li>通过链表的后续遍历判断回文链表问题 【简单】</li><li>链表的反向输出 【简单】</li><li>合并 K 个升序链表 【困难】</li><li>K个一组翻转链表 【困难】</li><li>环形链表 【简单】</li><li>排序链表 【中等】</li><li>相交链表 【简单】</li></ul><h2 id="寻找链表中点"><a href="#寻找链表中点" class="headerlink" title="寻找链表中点"></a>寻找链表中点</h2><p>题解</p><p>通过快慢指针寻找链表中点</p><pre><code class="javascript">function findCenter(head) {  let slower = head, faster = head;  while (faster &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;  }  // 如果 faster 不等于 null，说明是奇数个，slower 再移动一格  if (faster != null) {    slower = slower.next;  }  return slower;}</code></pre><h2 id="前序遍历判断回文链表"><a href="#前序遍历判断回文链表" class="headerlink" title="前序遍历判断回文链表"></a>前序遍历判断回文链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234 回文链表（简单）</a><sup>[1]</sup></p><p>题解1</p><p>利用链表的后续遍历，使用函数调用栈作为后序遍历栈，来判断是否回文</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {boolean} */var isPalindrome = function (head) {  let left = head;  function traverse(right) {    if (right == null) return true;    let res = traverse(right.next);    res = res &amp;&amp; (right.val === left.val);    left = left.next;    return res;  }  return traverse(head);};</code></pre><p>题解2</p><p>通过快、慢指针找链表中点，然后反转链表，比较两个链表两侧是否相等，来判断是否是回文链表</p><pre><code class="javascript">var isPalindrome = function (head) {  // 反转 slower 链表  let right = reverse(findCenter(head));  let left = head;  // 开始比较  while (right != null) {    if (left.val !== right.val) {      return false;    }    left = left.next;    right = right.next;  }  return true;}function findCenter(head) {  let slower = head, faster = head;  while (faster &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;  }  // 如果 faster 不等于 null，说明是奇数个，slower 再移动一格  if (faster != null) {    slower = slower.next;  }  return slower;}function reverse(head) {  let prev = null, cur = head, nxt = head;  while (cur != null) {    nxt = cur.next;    cur.next = prev;    prev = cur;    cur = nxt;  }  return prev;}</code></pre><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206 反转链表（简单）</a><sup>[2]</sup></p><p>题解1</p><p>迭代</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function (head) {  let prev = null, curr = head  while (curr) {    const node = curr.next    curr.next = prev    prev = curr    curr = node  }  return prev};</code></pre><p>解题2</p><p>递归</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function (head) {  if (head == null || head.next == null) return head;  let last = reverseList(head.next);  head.next.next = head;  head.next = null;  return last;};</code></pre><h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23 合并K个升序链表（困难）</a><sup>[3]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode[]} lists * @return {ListNode} */var mergeKLists = function (lists) {    if (lists.length === 0) return null;    return mergeArr(lists);};function mergeArr(lists) {    if (lists.length &lt;= 1) return lists[0];    let index = Math.floor(lists.length / 2);    const left = mergeArr(lists.slice(0, index))    const right = mergeArr(lists.slice(index));    return merge(left, right);}function merge(l1, l2) {    if (l1 == null &amp;&amp; l2 == null) return null;    if (l1 != null &amp;&amp; l2 == null) return l1;    if (l1 == null &amp;&amp; l2 != null) return l2;    let newHead = null, head = null;    while (l1 != null &amp;&amp; l2 != null) {        if (l1.val &lt; l2.val) {            if (!head) {                newHead = l1;                head = l1;            } else {                newHead.next = l1;                newHead = newHead.next;            }            l1 = l1.next;        } else {            if (!head) {                newHead = l2;                head = l2;            } else {                newHead.next = l2;                newHead = newHead.next;            }            l2 = l2.next;        }    }    newHead.next = l1 ? l1 : l2;    return head;}</code></pre><h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25 K 个一组翻转链表（困难）</a><sup>[4]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @param {number} k * @return {ListNode} */var reverseKGroup = function (head, k) {    let a = head, b = head;    for (let i = 0; i &lt; k; i++) {        if (b == null) return head;        b = b.next;    }    const newHead = reverse(a, b);    a.next = reverseKGroup(b, k);    return newHead;};function reverse(a, b) {    let prev = null, cur = a, nxt = a;    while (cur != b) {        nxt = cur.next;        cur.next = prev;        prev = cur;        cur = nxt;    }    return prev;}</code></pre><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141 环形链表（简单）</a><sup>[5]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @return {boolean} */var hasCycle = function (head) {  if (head == null || head.next == null) return false;  let slower = head, faster = head;  while (faster != null &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;    if (slower === faster) return true;  }  return false;};</code></pre><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148 排序链表（中等）</a><sup>[6]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var sortList = function (head) {  if (head == null) return null;  let newHead = head;  return mergeSort(head);};function mergeSort(head) {  if (head.next != null) {    let slower = getCenter(head);    let nxt = slower.next;    slower.next = null;    // console.log(head, slower, nxt);    const left = mergeSort(head);    const right = mergeSort(nxt);    head = merge(left, right);  }  return head;}function merge(left, right) {  let newHead = null, head = null;  while (left != null &amp;&amp; right != null) {    if (left.val &lt; right.val) {      if (!head) {        newHead = left;        head = left;      } else {        newHead.next = left;        newHead = newHead.next;      }      left = left.next;    } else {      if (!head) {        newHead = right;        head = right;      } else {        newHead.next = right;        newHead = newHead.next;      }      right = right.next;    }  }  newHead.next = left ? left : right;  return head;}function getCenter(head) {  let slower = head, faster = head.next;  while (faster != null &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;  }  return slower;}</code></pre><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160 相交链表（简单）</a><sup>[7]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} headA * @param {ListNode} headB * @return {ListNode} */var getIntersectionNode = function (headA, headB) {    let lastHeadA = null;    let lastHeadB = null;    let originHeadA = headA;    let originHeadB = headB;    if (!headA || !headB) {        return null;    }    while (true) {        if (headB == headA) {            return headB;        }        if (headA &amp;&amp; headA.next == null) {            lastHeadA = headA;            headA = originHeadB;        } else {            headA = headA.next;        }        if (headB &amp;&amp; headB.next == null) {            lastHeadB = headB            headB = originHeadA;        } else {            headB = headB.next;        }        if (lastHeadA &amp;&amp; lastHeadB &amp;&amp; lastHeadA != lastHeadB) {            return null;        }    }    return null;};</code></pre><h1 id="高频算法题系列：字符串【🔥】"><a href="#高频算法题系列：字符串【🔥】" class="headerlink" title="高频算法题系列：字符串【🔥】"></a>高频算法题系列：字符串【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>最长回文子串 【中等】【双指针】【面试真题】</li><li>最长公共前缀 【简单】【双指针】</li><li>无重复字符的最长子串【中等】【双指针】</li><li>最小覆盖子串 【困难】【滑动窗口】【面试真题】</li></ul><h2 id="【面试真题】最长回文子串【双指针】"><a href="#【面试真题】最长回文子串【双指针】" class="headerlink" title="【面试真题】最长回文子串【双指针】"></a>【面试真题】最长回文子串【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5 最长回文子串（中等）</a><sup>[8]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {string} */var longestPalindrome = function (s) {          if (s.length === 1) return s;          let maxRes = 0, maxStr = '';          for (let i = 0; i &lt; s.length; i++) {            let str1 = palindrome(s, i, i);            let str2 = palindrome(s, i, i + 1);            if (str1.length &gt; maxRes) {              maxStr = str1;              maxRes = str1.length;            }            if (str2.length &gt; maxRes) {              maxStr = str2;              maxRes = str2.length;            }          }          return maxStr;        };function palindrome(s, l, r) {  while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s[l] === s[r]) {    l--;    r++;  }  return s.slice(l + 1, r);}</code></pre><h2 id="最长公共前缀【双指针】"><a href="#最长公共前缀【双指针】" class="headerlink" title="最长公共前缀【双指针】"></a>最长公共前缀【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14 最长公共前缀（简单）</a><sup>[9]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string[]} strs * @return {string} */var longestCommonPrefix = function (strs) {    if (strs.length === 0) return "";    let first = strs[0];    if (first === "") return "";    let minLen = Number.MAX_SAFE_INTEGER;    for (let i = 1; i &lt; strs.length; i++) {        const len = twoStrLongestCommonPrefix(first, strs[i]);        minLen = Math.min(len, minLen);    }    return first.slice(0, minLen);};function twoStrLongestCommonPrefix(s, t) {    let i = 0, j = 0;    let cnt = 0;    while (i &lt; s.length &amp;&amp; j &lt; t.length) {        console.log(s[i], t[j], cnt)        if (s[i] === t[j]) {            cnt++;        } else {            return cnt;        }        i++;        j++;    }    return cnt;}</code></pre><h2 id="无重复字符的最长子串【双指针】"><a href="#无重复字符的最长子串【双指针】" class="headerlink" title="无重复字符的最长子串【双指针】"></a>无重复字符的最长子串【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3 无重复字符的最长子串（中等）</a><sup>[10]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function (s) {    let window = {};    let left = 0, right = 0;    let maxLen = 0, maxStr = '';    while (right &lt; s.length) {        let c = s[right];        right++;        if (window[c]) window[c]++;        else window[c] = 1        while (window[c] &gt; 1) {            let d = s[left];            left++;            window[d]--;        }        if (maxLen &lt; right - left) {            maxLen = right - left;        }    }    return maxLen;};</code></pre><h2 id="【面试真题】-最小覆盖子串【滑动窗口】"><a href="#【面试真题】-最小覆盖子串【滑动窗口】" class="headerlink" title="【面试真题】 最小覆盖子串【滑动窗口】"></a>【面试真题】 最小覆盖子串【滑动窗口】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76 最小覆盖子串（困难）</a><sup>[11]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @param {string} t * @return {string} */var minWindow = function (s, t) {    let need = {}, window = {};    for (let c of t) {        if (!need[c]) need[c] = 1;        else need[c]++;    }    let left = 0, right = 0;    let valid = 0, len = Object.keys(need).length;    let minLen = s.length + 1, minStr = '';    while (right &lt; s.length) {        const d = s[right];        right++;        if (!window[d]) window[d] = 1;        else window[d]++;        if (need[d] &amp;&amp; need[d] === window[d]) {            valid++;        }        console.log('left - right', left, right);        while (valid === len) {            if (right - left &lt; minLen) {                minLen = right - left;                minStr = s.slice(left, right);            }            console.lo            let c = s[left];            left++;            window[c]--;            if (need[c] &amp;&amp; window[c] &lt; need[c]) {                valid--;            }        }    }    return minStr;};</code></pre><h1 id="高频算法题系列：数组问题【🔥】"><a href="#高频算法题系列：数组问题【🔥】" class="headerlink" title="高频算法题系列：数组问题【🔥】"></a>高频算法题系列：数组问题【🔥】</h1><p>主要有几类高频考题：</p><ul><li>俄罗斯套娃信封问题【困难】【排序+最长上升子序列】【面试真题】</li><li>最长连续递增序列 【简单】【双指针】</li><li>最长连续序列【困难】【哈希表】</li><li>盛最多水的容器【困难】【面试真题】</li><li>寻找两个正序数组的中位数【困难】【双指针】</li><li>删除有序数组中的重复项【简单】【快慢指针】</li><li>和为K的子数组【中等】【哈希表】</li><li>nSum 问题【系列】【简单】【哈希表】</li><li>接雨水【困难】【暴力+备忘录优化】【面试真题】</li><li>跳跃游戏【系列】【中等】【贪心算法】</li></ul><h2 id="【面试真题】俄罗斯套娃信封问题【排序-最长上升子序列】"><a href="#【面试真题】俄罗斯套娃信封问题【排序-最长上升子序列】" class="headerlink" title="【面试真题】俄罗斯套娃信封问题【排序+最长上升子序列】"></a>【面试真题】俄罗斯套娃信封问题【排序+最长上升子序列】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354 俄罗斯套娃信封问题（困难）</a><sup>[12]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} envelopes * @return {number} */var maxEnvelopes = function (envelopes) {    if (envelopes.length === 1) return 1;    envelopes.sort((a, b) =&gt; {        if (a[0] !== b[0]) return a[0] - b[0];        else return b[1] - a[1];    });    let LISArr = [];    for (let [key, value] of envelopes) {        LISArr.push(value);    }    console.log(LISArr);    return LIS(LISArr);};function LIS(arr) {    let dp = [];    let maxAns = 0;    for (let i = 0; i &lt; arr.length; i++) {        dp[i] = 1;    }    for (let i = 1; i &lt; arr.length; i++) {        for (let j = i; j &gt;= 0; j--) {            if (arr[i] &gt; arr[j]) {                dp[i] = Math.max(dp[i], dp[j] + 1)            }            maxAns = Math.max(maxAns, dp[i]);        }    }    return maxAns;}</code></pre><h2 id="最长连续递增序列【快慢指针】"><a href="#最长连续递增序列【快慢指针】" class="headerlink" title="最长连续递增序列【快慢指针】"></a>最长连续递增序列【快慢指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674 最长连续递增序列（简单）</a><sup>[13]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var findLengthOfLCIS = function (nums) {    if (nums.length === 0) return 0;    const n = nums.length;    let left = 0, right = 1;    let globalMaxLen = 1, maxLen = 1;    while (right &lt; n) {        if (nums[right] &gt; nums[left]) maxLen++;        else {            maxLen = 1;        }        left++;        right++;        globalMaxLen = Math.max(globalMaxLen, maxLen);    }    return globalMaxLen;};</code></pre><h2 id="最长连续序列-【哈希表】"><a href="#最长连续序列-【哈希表】" class="headerlink" title="最长连续序列 【哈希表】"></a>最长连续序列 【哈希表】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128 最长连续序列（困难）</a><sup>[14]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var longestConsecutive = function (nums) {    if (nums.length === 0) return 0;    const set = new Set(nums);    const n = nums.length;    let globalLongest = 1;    for (let i = 0; i &lt; n; i++) {        if (!set.has(nums[i] - 1)) {            let longest = 1;            let currentNum = nums[i];            while (set.has(currentNum + 1)) {                currentNum += 1;                longest++;            }            globalLongest = Math.max(globalLongest, longest);        }    }    return globalLongest;};</code></pre><h2 id="【面试真题】盛最多水的容器【哈希表】"><a href="#【面试真题】盛最多水的容器【哈希表】" class="headerlink" title="【面试真题】盛最多水的容器【哈希表】"></a>【面试真题】盛最多水的容器【哈希表】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11 盛最多水的容器（中等）</a><sup>[15]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} height * @return {number} */var maxArea = function (height) {    let n = height.length;    let left = 0, right = n - 1;    let maxOpacity = 0;    while (left &lt; right) {        let res = Math.min(height[left], height[right]) * (right - left);        maxOpacity = Math.max(maxOpacity, res);        if (height[left] &lt; height[right]) left++        else right--;    }    return maxOpacity;};</code></pre><h2 id="寻找两个正序数组的中位数【双指针】"><a href="#寻找两个正序数组的中位数【双指针】" class="headerlink" title="寻找两个正序数组的中位数【双指针】"></a>寻找两个正序数组的中位数【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4 寻找两个正序数组的中位数（困难）</a><sup>[16]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */var findMedianSortedArrays = function (nums1, nums2) {    let m = nums1.length, n = nums2.length;    let i = 0, j = 0;    let newArr = [];    while (i &lt; m &amp;&amp; j &lt; n) {        if (nums1[i] &lt; nums2[j]) {            newArr.push(nums1[i++]);        } else {            newArr.push(nums2[j++]);        }    }    newArr = newArr.concat(i &lt; m ? nums1.slice(i) : nums2.slice(j));    const len = newArr.length;    console.log(newArr)    if (len % 2 === 0) {        return (newArr[len / 2] + newArr[len / 2 - 1]) / 2;    } else {        return newArr[Math.floor(len / 2)];    }};</code></pre><h2 id="删除有序数组中的重复项【快慢指针】"><a href="#删除有序数组中的重复项【快慢指针】" class="headerlink" title="删除有序数组中的重复项【快慢指针】"></a>删除有序数组中的重复项【快慢指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26 删除有序数组中的重复项（简单）</a><sup>[17]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var removeDuplicates = function (nums) {    if (nums.length &lt;= 1) return nums.length;    let lo = 0, hi = 0;    while (hi &lt; nums.length) {        while (nums[lo] === nums[hi] &amp;&amp; hi &lt; nums.length) hi++;        if (nums[lo] !== nums[hi] &amp;&amp; hi &lt; nums.length) {            lo++;            nums[lo] = nums[hi];        }        hi++;    }    return lo + 1;};</code></pre><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">695 岛屿的最大面积（中等）</a><sup>[18]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} grid * @return {number} */let maxX, maxY;let visited;let globalMaxArea;var maxAreaOfIsland = function (grid) {    visited = new Set();    maxX = grid.length;    maxY = grid[0].length;    globalMaxArea = 0;    for (let i = 0; i &lt; maxX; i++) {        for (let j = 0; j &lt; maxY; j++) {            if (grid[i][j] === 1) {                visited.add(`(${i}, ${j})`);                globalMaxArea = Math.max(globalMaxArea, dfs(grid, i, j));            }            visited.clear();        }    }    return globalMaxArea;};function dfs(grid, x, y) {    let res = 1;    for (let i = -1; i &lt;= 1; i++) {        for (let j = -1; j &lt;= 1; j++) {            if (Math.abs(i) === Math.abs(j)) continue;            const newX = x + i;            const newY = y + j;            if (newX &gt;= maxX || newX &lt; 0 || newY &gt;= maxY || newY &lt; 0) continue;            if (visited.has(`(${newX}, ${newY})`)) continue;            visited.add(`(${newX}, ${newY})`);            const areaCnt = grid[newX][newY]            if (areaCnt === 1) {                const cnt = dfs(grid, newX, newY);                res += cnt;            }        }    }    return res;}</code></pre><h2 id="和为K的子数组【哈希表】"><a href="#和为K的子数组【哈希表】" class="headerlink" title="和为K的子数组【哈希表】"></a>和为K的子数组【哈希表】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560 和为K的子数组（中等）</a><sup>[19]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @param {number} k * @return {number} */var subarraySum = function (nums, k) {    let cnt = 0;    let sum0_i = 0, sum0_j = 0;    let map = new Map();    map.set(0, 1);    for (let i = 0; i &lt;= nums.length; i++) {        sum0_i += nums[i];        sum0_j = sum0_i - k;        console.log('map', sum0_j, map.get(sum0_j))        if (map.has(sum0_j)) {            cnt += map.get(sum0_j);        }        let sumCnt = map.get(sum0_i) || 0;        map.set(sum0_i, sumCnt + 1);    }    return cnt;};</code></pre><h2 id="nSum问题【哈希表】【系列】"><a href="#nSum问题【哈希表】【系列】" class="headerlink" title="nSum问题【哈希表】【系列】"></a>nSum问题【哈希表】【系列】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1 两数之和（简单）</a><sup>[20]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167 两数之和 II - 输入有序数组（简单）</a><sup>[21]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15 三数之和（中等）</a><sup>[22]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18 四数之和（中等）</a><sup>[23]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题。</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @param {number} target * @return {number[]} */var twoSum = function (nums, target) {    let map2 = new Map();    for (let i = 0; i &lt; nums.length; i++) {        map2.set(nums[i], i);    }    for (let i = 0; i &lt; nums.length; i++) {        if (map2.has(target - nums[i]) &amp;&amp; map2.get(target - nums[i]) !== i) return [i, map2.get(target - nums[i])]    }};</code></pre><h2 id="接雨水【暴力-备忘录优化】"><a href="#接雨水【暴力-备忘录优化】" class="headerlink" title="接雨水【暴力+备忘录优化】"></a>接雨水【暴力+备忘录优化】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42 接雨水（困难）</a><sup>[24]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} height * @return {number} */var trap = function (height) {    let l_max = [], r_max = [];    let len = height.length;    let maxCapacity = 0;    for (let i = 0; i &lt; len; i++) {        l_max[i] = height[i];        r_max[i] = height[i];    }    for (let i = 1; i &lt; len; i++) {        l_max[i] = Math.max(l_max[i - 1], height[i]);    }    for (let j = len - 2; j &gt;= 0; j--) {        r_max[j] = Math.max(r_max[j + 1], height[j]);    }    for (let i = 0; i &lt; len; i++) {        maxCapacity += Math.min(l_max[i], r_max[i]) - height[i];    }    return maxCapacity;};</code></pre><h2 id="跳跃游戏【贪心算法】【系列】"><a href="#跳跃游戏【贪心算法】【系列】" class="headerlink" title="跳跃游戏【贪心算法】【系列】"></a>跳跃游戏【贪心算法】【系列】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55 跳跃游戏（中等）</a><sup>[25]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45 跳跃游戏 II（中等）</a><sup>[26]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题。</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {boolean} */var canJump = function(nums) {    let faster = 0;    for (let i = 0; i &lt; nums.length - 1; i++) {        faster = Math.max(faster, i + nums[i]);        if (faster &lt;= i) return false;    }    return faster &gt;= nums.length - 1;};</code></pre><h1 id="高频算法题系列：二叉树"><a href="#高频算法题系列：二叉树" class="headerlink" title="高频算法题系列：二叉树"></a>高频算法题系列：二叉树</h1><p>主要有以下几类高频考题：</p><ul><li>二叉树的最近公共祖先【简单】【二叉树】</li><li>二叉搜索树中的搜索【简单】【二叉树】</li><li>删除二叉搜索树中的节点【中等】【二叉树】</li><li>完全二叉树的节点个数【中等】【二叉树】</li><li>二叉树的锯齿形层序遍历【中等】【二叉树】</li></ul><h2 id="二叉树的最近公共祖先【二叉树】"><a href="#二叉树的最近公共祖先【二叉树】" class="headerlink" title="二叉树的最近公共祖先【二叉树】"></a>二叉树的最近公共祖先【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236 二叉树的最近公共祖先（简单）</a><sup>[27]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} */let visited;let parent;var lowestCommonAncestor = function (root, p, q) {  visited = new Set();  parent = new Map();  dfs(root);  while (p != null) {    visited.add(p.val);    p = parent.get(p.val);  }  while (q != null) {    if (visited.has(q.val)) {      return q;    }    q = parent.get(q.val);  }  return null;};function dfs(root) {  if (root.left != null) {    parent.set(root.left.val, root);    dfs(root.left);  }  if (root.right != null) {    parent.set(root.right.val, root);    dfs(root.right);  }}</code></pre><h2 id="二叉搜索树中的搜索【二叉树】"><a href="#二叉搜索树中的搜索【二叉树】" class="headerlink" title="二叉搜索树中的搜索【二叉树】"></a>二叉搜索树中的搜索【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700 二叉搜索树中的搜索（简单）</a><sup>[28]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {number} val * @return {TreeNode} */var searchBST = function (root, val) {    if (root == null) return null;    if (root.val === val) return root;    if (root.val &gt; val) {        return searchBST(root.left, val);    } else if (root.val &lt; val) {        return searchBST(root.right, val);    }};</code></pre><h2 id="删除二叉搜索树中的节点【二叉树】"><a href="#删除二叉搜索树中的节点【二叉树】" class="headerlink" title="删除二叉搜索树中的节点【二叉树】"></a>删除二叉搜索树中的节点【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450 删除二叉搜索树中的节点（中等）</a><sup>[29]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {number} key * @return {TreeNode} */var deleteNode = function (root, key) {    if (root == null) return null;    if (root.val === key) {        if (root.left == null &amp;&amp; root.right == null) return null;        if (root.left == null) return root.right;        if (root.right == null) return root.left;        if (root.left != null &amp;&amp; root.right != null) {            let target = getMinTreeMaxNode(root.left);            root.val = target.val;            root.left = deleteNode(root.left, target.val);        }    }    if (root.val &lt; key) {        root.right = deleteNode(root.right, key);    } else if (root.val &gt; key) {        root.left = deleteNode(root.left, key);    }    return root;};function getMinTreeMaxNode(root) {    if (root.right == null) return root;    return getMinTreeMaxNode(root.right);}</code></pre><h2 id="完全二叉树的节点个数【二叉树】"><a href="#完全二叉树的节点个数【二叉树】" class="headerlink" title="完全二叉树的节点个数【二叉树】"></a>完全二叉树的节点个数【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222 完全二叉树的节点个数（中等）</a><sup>[30]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */var countNodes = function (root) {    if (root == null) return 0;    let l = root, r = root;    let lh = 0, rh = 0;    while (l != null) {        l = l.left;        lh++;    }    while (r != null) {        r = r.right;        rh++;    }    if (lh === rh) {        return Math.pow(2, lh) - 1;    }    return 1 + countNodes(root.left) + countNodes(root.right);};</code></pre><h2 id="二叉树的锯齿形层序遍历【二叉树】"><a href="#二叉树的锯齿形层序遍历【二叉树】" class="headerlink" title="二叉树的锯齿形层序遍历【二叉树】"></a>二叉树的锯齿形层序遍历【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103 二叉树的锯齿形层序遍历（中等）</a><sup>[31]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[][]} */let res;var zigzagLevelOrder = function (root) {    if (root == null) return [];    res = [];    BFS(root, true);    return res;};function BFS(root, inOrder) {    let arr = [];    let resItem = [];    let node;    let stack1 = new Stack();    let stack2 = new Stack();    // 判断交换时机    let flag;    stack1.push(root);    res.push([root.val]);    inOrder = !inOrder;    while (!stack1.isEmpty() || !stack2.isEmpty()) {        if (stack1.isEmpty()) {            flag = 'stack1';        } else if (stack2.isEmpty()) {            flag = 'stack2';        }        // 决定取那个栈里面的元素        if (flag === 'stack2' &amp;&amp; !stack1.isEmpty()) node = stack1.pop();        else if (flag === 'stack1' &amp;&amp; !stack2.isEmpty()) node = stack2.pop();        if (inOrder) {            if (node.left) {                if (flag === 'stack1') {                    stack1.push(node.left);                } else {                    stack2.push(node.left);                }                resItem.push(node.left.val);            }            if (node.right) {                if (flag === 'stack1') {                    stack1.push(node.right);                } else {                    stack2.push(node.right);                }                resItem.push(node.right.val);            }        } else {            if (node.right) {                if (flag === 'stack1') {                    stack1.push(node.right);                } else {                    stack2.push(node.right);                }                resItem.push(node.right.val);            }            if (node.left) {                if (flag === 'stack1') {                    stack1.push(node.left);                } else {                    stack2.push(node.left);                }                resItem.push(node.left.val);            }        }        // 判断下次翻转的时机        if ((flag === 'stack2' &amp;&amp; stack1.isEmpty()) || (flag === 'stack1' &amp;&amp; stack2.isEmpty())) {            inOrder = !inOrder;            // 需要翻转了，就加一轮值            if (resItem.length &gt; 0) {                res.push(resItem);            }            resItem = [];        }    }}class Stack {    constructor() {        this.count = 0;        this.items = [];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return undefined;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    size() {        return this.count;    }    isEmpty() {        return this.size() === 0;    }}</code></pre><h1 id="高频算法题系列：排序算法【🔥】"><a href="#高频算法题系列：排序算法【🔥】" class="headerlink" title="高频算法题系列：排序算法【🔥】"></a>高频算法题系列：排序算法【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>用最少数量的箭引爆气球【中等】【排序】</li><li>合并区间【中等】【排序算法+区间问题】【面试真题】</li></ul><h2 id="用最少数量的箭引爆气球【排序算法】"><a href="#用最少数量的箭引爆气球【排序算法】" class="headerlink" title="用最少数量的箭引爆气球【排序算法】"></a>用最少数量的箭引爆气球【排序算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452 用最少数量的箭引爆气球（中等）</a><sup>[32]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} points * @return {number} */var findMinArrowShots = function (points) {    if (points.length === 0) return 0;    points.sort((a, b) =&gt; a[1] - b[1]);    let cnt = 1;    let resArr = [points[0]];    let curr, last;    for (let i = 1; i &lt; points.length; i++) {        curr = points[i];        last = resArr[resArr.length - 1];        if (curr[0] &gt; last[1]) {            resArr.push(curr);            cnt++;        }    }    return cnt;};</code></pre><h2 id="合并区间【排序算法-区间问题】"><a href="#合并区间【排序算法-区间问题】" class="headerlink" title="合并区间【排序算法+区间问题】"></a>合并区间【排序算法+区间问题】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56 合并区间（中等）</a><sup>[33]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} intervals * @return {number[][]} */var merge = function (intervals) {    if (intervals.length === 0) return [];    intervals.sort((a, b) =&gt; a[0] - b[0]);    let mergeArr = [intervals[0]];    let last, curr;    for (let j = 1; j &lt; intervals.length; j++) {        last = mergeArr[mergeArr.length - 1];        curr = intervals[j];        if (last[1] &gt;= curr[0]) {            last[1] = Math.max(curr[1], last[1]);        } else {            mergeArr.push(curr);        }    }    return mergeArr;};</code></pre><h1 id="高频算法题系列：二分查找"><a href="#高频算法题系列：二分查找" class="headerlink" title="高频算法题系列：二分查找"></a>高频算法题系列：二分查找</h1><p>主要有以下几类高频考题：</p><ul><li>寻找两个正序数组的中位数【困难】【二分查找】</li><li>判断子序列【简单】【二分查找】</li><li>在排序数组中查找元素的第一个和最后一个位置【中等】【二分查找】</li></ul><h2 id="寻找两个正序数组的中位数【二分查找】"><a href="#寻找两个正序数组的中位数【二分查找】" class="headerlink" title="寻找两个正序数组的中位数【二分查找】"></a>寻找两个正序数组的中位数【二分查找】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4 寻找两个正序数组的中位数（困难）</a><sup>[34]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */var findMedianSortedArrays = function (nums1, nums2) {    let m = nums1.length, n = nums2.length;    let i = 0, j = 0;    let newArr = [];    while (i &lt; m &amp;&amp; j &lt; n) {        if (nums1[i] &lt; nums2[j]) {            newArr.push(nums1[i++]);        } else {            newArr.push(nums2[j++]);        }    }    newArr = newArr.concat(i &lt; m ? nums1.slice(i) : nums2.slice(j));    const len = newArr.length;    console.log(newArr)    if (len % 2 === 0) {        return (newArr[len / 2] + newArr[len / 2 - 1]) / 2;    } else {        return newArr[Math.floor(len / 2)];    }};</code></pre><h2 id="判断子序列【二分查找】"><a href="#判断子序列【二分查找】" class="headerlink" title="判断子序列【二分查找】"></a>判断子序列【二分查找】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392 判断子序列（简单）</a><sup>[35]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @param {string} t * @return {boolean} */var isSubsequence = function (s, t) {    let hash = {};    for (let i = 0; i &lt; t.length; i++) {        if (!hash[t[i]]) hash[t[i]] = [];        hash[t[i]].push(i);    }    let lastMaxIndex = 0;    for (let i = 0; i &lt; s.length; i++) {        if (hash[s[i]]) {            const index = binarySearch(hash[s[i]], lastMaxIndex);            console.log('index', index, hash[s[i]]);            if (index === -1) return false;            lastMaxIndex = hash[s[i]][index] + 1;        } else return false;    }    return true;};function binarySearch(array, targetIndex) {    let left = 0, right = array.length;    while (left &lt; right) {        let mid = left + Math.floor((right - left) / 2);        if (array[mid] &gt;= targetIndex) {            right = mid;        } else if (array[mid] &lt; targetIndex) {            left = mid + 1;        }    }    if (left &gt;= array.length || array[left] &lt; targetIndex) return -1;    return left;}</code></pre><h2 id="在排序数组中查找元素的第一个和最后一个位置【二分搜索】"><a href="#在排序数组中查找元素的第一个和最后一个位置【二分搜索】" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置【二分搜索】"></a>在排序数组中查找元素的第一个和最后一个位置【二分搜索】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34 在排序数组中查找元素的第一个和最后一个位置（中等）</a><sup>[36]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @param {number} target * @return {number[]} */var searchRange = function (nums, target) {    const left = leftBound(nums, target);    const right = rightBound(nums, target);    return [left, right];};function leftBound(nums, target) {    let left = 0;    let right = nums.length - 1;    while (left &lt;= right) {        let mid = Math.floor(left + (right - left) / 2);        if (nums[mid] === target) {            right = mid - 1;        } else if (nums[mid] &lt; target) {            left = mid + 1;        } else if (nums[mid] &gt; target) {            right = mid - 1;        }    }    if (left &gt;= nums.length || nums[left] !== target) {        return -1;    }    return left;}function rightBound(nums, target) {    let left = 0;    let right = nums.length - 1;    while (left &lt;= right) {        let mid = Math.floor(left + (right - left) / 2);        if (nums[mid] === target) {            left = mid + 1;        } else if (nums[mid] &lt; target) {            left = mid + 1;        } else if (nums[mid] &gt; target) {            right = mid - 1;        }    }    if (right &lt; 0 || nums[right] !== target) {        return -1;    }    return right;}</code></pre><h1 id="高频算法题系列：动态规划【🔥】"><a href="#高频算法题系列：动态规划【🔥】" class="headerlink" title="高频算法题系列：动态规划【🔥】"></a>高频算法题系列：动态规划【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>最长递增子序列【中等】【动态规划】</li><li>零钱兑换【中等】【动态规划】【面试真题】</li><li>最长公共子序列 【中等】【动态规划】【面试真题】</li><li>编辑距离 【困难】【动态规划】</li><li>最长回文子序列【中等】【动态规划】【面试真题】</li><li>最大子序和【简单】【动态规划】【面试真题】</li><li>买卖股票的最佳时机系列【系列】【动态规划】【面试真题】</li></ul><h2 id="最长递增子序列【动态规划】"><a href="#最长递增子序列【动态规划】" class="headerlink" title="最长递增子序列【动态规划】"></a>最长递增子序列【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300 最长递增子序列（中等）</a><sup>[37]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var lengthOfLIS = function (nums) {    let maxLen = 0, n = nums.length;    let dp = [];    for (let i = 0; i &lt; n; i++) {        dp[i] = 1;    }    for (let i = 0; i &lt; n; i++) {        for (let j = 0; j &lt; i; j++) {            if (nums[i] &gt; nums[j]) {                dp[i] = Math.max(dp[i], dp[j] + 1);            }        }        maxLen = Math.max(maxLen, dp[i]);    }    return maxLen;};</code></pre><h2 id="【面试真题】-零钱兑换【动态规划】"><a href="#【面试真题】-零钱兑换【动态规划】" class="headerlink" title="【面试真题】 零钱兑换【动态规划】"></a>【面试真题】 零钱兑换【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322 零钱兑换（中等）</a><sup>[38]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} coins * @param {number} amount * @return {number} */var coinChange = function (coins, amount) {    if (amount === 0) return 0;    let dp = [];    for (let i = 0; i &lt;= amount; i++) {        dp[i] = amount + 1;    }    dp[0] = 0;    for (let i = 0; i &lt;= amount; i++) {        for (let j = 0; j &lt; coins.length; j++) {            if (i &gt;= coins[j]) {                dp[i] = Math.min(dp[i - coins[j]] + 1, dp[i])            }        }    }    return dp[amount] === amount + 1 ? -1 : dp[amount];};</code></pre><h2 id="【面试真题】-最长公共子序列【动态规划】"><a href="#【面试真题】-最长公共子序列【动态规划】" class="headerlink" title="【面试真题】 最长公共子序列【动态规划】"></a>【面试真题】 最长公共子序列【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143 最长公共子序列（中等）</a><sup>[39]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} text1 * @param {string} text2 * @return {number} */var longestCommonSubsequence = function (text1, text2) {    let n1 = text1.length, n2 = text2.length;    let dp = [];    for (let i = -1; i &lt; n1; i++) {        dp[i] = [];        for (let j = -1; j &lt; n2; j++) {            dp[i][j] = 0;        }    }    for (let i = 0; i &lt; n1; i++) {        for (let j = 0; j &lt; n2; j++) {            if (text1[i] === text2[j]) {                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);            } else {                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])            }        }    }    return dp[n1 - 1][n2 - 1];};</code></pre><h2 id="编辑距离【动态规划】"><a href="#编辑距离【动态规划】" class="headerlink" title="编辑距离【动态规划】"></a>编辑距离【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72 编辑距离（困难）</a><sup>[40]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} word1 * @param {string} word2 * @return {number} */var minDistance = function (word1, word2) {    let len1 = word1.length, len2 = word2.length;    let dp = [];    for (let i = 0; i &lt;= len1; i++) {        dp[i] = [];        for (let j = 0; j &lt;= len2; j++) {            dp[i][j] = 0;            if (i === 0) {                dp[i][j] = j;            }            if (j === 0) {                dp[i][j] = i;            }        }    }    for (let i = 1; i &lt;= len1; i++) {        for (let j = 1; j &lt;= len2; j++) {            if (word1[i - 1] === word2[j - 1]) {                dp[i][j] = dp[i - 1][j - 1];            } else {                dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1);            }        }    }    return dp[len1][len2];};</code></pre><h2 id="【面试真题】最长回文子序列【动态规划】"><a href="#【面试真题】最长回文子序列【动态规划】" class="headerlink" title="【面试真题】最长回文子序列【动态规划】"></a>【面试真题】最长回文子序列【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516 最长回文子序列（中等）</a><sup>[41]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {number} */var longestPalindromeSubseq = function (s) {    let dp = [];    for (let i = 0; i &lt; s.length; i++) {        dp[i] = [];        for (let j = 0; j &lt; s.length; j++) {            dp[i][j] = 0;        }        dp[i][i] = 1;    }    for (let i = s.length - 1; i &gt;= 0; i--) {        for (let j = i + 1; j &lt; s.length; j++) {            if (s[i] === s[j]) {                dp[i][j] = dp[i + 1][j - 1] + 2;            } else {                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);            }        }    }    return dp[0][s.length - 1];};</code></pre><h2 id="【面试真题】最大子序和【动态规划】"><a href="#【面试真题】最大子序和【动态规划】" class="headerlink" title="【面试真题】最大子序和【动态规划】"></a>【面试真题】最大子序和【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53 最大子序和（简单）</a><sup>[42]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var maxSubArray = function (nums) {    let maxSum = -Infinity;    let dp = [], n = nums.length;    for (let i = -1; i &lt; n; i++) {        dp[i] = 0;    }    for (let i = 0; i &lt; n; i++) {        dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);        maxSum = Math.max(maxSum, dp[i]);    }    return maxSum;};</code></pre><h2 id="【面试真题】买卖股票的最佳时机【动态规划】"><a href="#【面试真题】买卖股票的最佳时机【动态规划】" class="headerlink" title="【面试真题】买卖股票的最佳时机【动态规划】"></a>【面试真题】买卖股票的最佳时机【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121 买卖股票的最佳时机（简单）</a><sup>[43]</sup>【面试真题】</p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122 买卖股票的最佳时机 II（简单）</a><sup>[44]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123 买卖股票的最佳时机 III（困难）</a><sup>[45]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188 买卖股票的最佳时机IV（困难）</a><sup>[46]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309 买卖股票的最佳时机含冷冻期（中等）</a><sup>[47]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714 买卖股票的最佳时机含手续费（中等）</a><sup>[48]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题，笔者在面试字节跳动时就遇到过。</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} prices * @return {number} */var maxProfit = function (prices) {    let dp = [];    for (let i = -1; i &lt; prices.length; i++) {        dp[i] = []        for (let j = 0; j &lt;= 1; j++) {            dp[i][j] = [];            dp[i][j][0] = 0;            dp[i][j][1] = 0;            if (i === -1) {                dp[i][j][1] = -Infinity;            }            if (j === 0) {                dp[i][j][1] = -Infinity;            }            if (j === -1) {                dp[i][j][1] = -Infinity;            }        }    }    for (let i = 0; i &lt; prices.length; i++) {        for (let j = 1; j &lt;= 1; j++) {            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);        }    }    return dp[prices.length - 1][1][0];};</code></pre><h1 id="高频算法题系列：BFS"><a href="#高频算法题系列：BFS" class="headerlink" title="高频算法题系列：BFS"></a>高频算法题系列：BFS</h1><p>主要有以下几类高频考题：</p><ul><li>打开转盘锁【中等】【BFS】</li><li>二叉树的最小深度【简单】【BFS】</li></ul><h2 id="打开转盘锁【BFS】"><a href="#打开转盘锁【BFS】" class="headerlink" title="打开转盘锁【BFS】"></a>打开转盘锁【BFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">752 打开转盘锁（中等）</a><sup>[49]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string[]} deadends * @param {string} target * @return {number} */var openLock = function (deadends, target) {    let queue = new Queue();    let visited = new Set();    let step = 0;    queue.push('0000');    visited.add('0000');    while (!queue.isEmpty()) {        let size = queue.size();        for (let i = 0; i &lt; size; i++) {            let str = queue.pop();            if (deadends.includes(str)) continue;            if (target === str) {                return step;            }            for (let j = 0; j &lt; 4; j++) {                let plusStr = plusOne(str, j);                let minusStr = minusOne(str, j);                if (!visited.has(plusStr)) {                    queue.push(plusStr);                    visited.add(plusStr)                }                if (!visited.has(minusStr)) {                    queue.push(minusStr);                    visited.add(minusStr)                }            }        }        step++;    }    return -1;};function plusOne(str, index) {    let strArr = str.split('');    if (strArr[index] === '9') {        strArr[index] = '0'    } else {        strArr[index] = (Number(strArr[index]) + 1).toString()    }    return strArr.join('');}function minusOne(str, index) {    let strArr = str.split('');    if (strArr[index] === '0') {        strArr[index] = '9'    } else {        strArr[index] = (Number(strArr[index]) - 1).toString()    }    return strArr.join('');}class Queue {    constructor() {        this.items = [];        this.count = 0;        this.lowerCount = 0;    }    push(elem) {        this.items[this.count++] = elem;    }    pop() {        if (this.isEmpty()) {            return;        }        const elem = this.items[this.lowerCount];        delete this.items[this.lowerCount];        this.lowerCount++;        return elem;    }    isEmpty() {        if (this.size() === 0) return true;        return false;    }    size() {        return this.count - this.lowerCount;    }}</code></pre><h2 id="二叉树的最小深度【BFS】"><a href="#二叉树的最小深度【BFS】" class="headerlink" title="二叉树的最小深度【BFS】"></a>二叉树的最小深度【BFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111 二叉树的最小深度（简单）</a><sup>[50]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */var minDepth = function (root) {    if (root == null) return 0;    let depth = 1;    let queue = new Queue();    queue.push(root);    while (!queue.isEmpty()) {        let size = queue.size();        for (let i = 0; i &lt; size; i++) {            const node = queue.pop();            if (node.left == null &amp;&amp; node.right == null) return depth;            if (node.left) {                queue.push(node.left);            }            if (node.right) {                queue.push(node.right);            }        }        depth++;    }    return depth;};class Queue {    constructor() {        this.items = [];        this.count = 0;        this.lowerCount = 0;    }    push(elem) {        this.items[this.count++] = elem;    }    pop() {        if (this.isEmpty()) {            return;        }        const elem = this.items[this.lowerCount];        delete this.items[this.lowerCount];        this.lowerCount++;        return elem;    }    isEmpty() {        if (this.size() === 0) return true;        return false;    }    size() {        return this.count - this.lowerCount;    }}</code></pre><h1 id="高频算法题系列：栈【🔥】"><a href="#高频算法题系列：栈【🔥】" class="headerlink" title="高频算法题系列：栈【🔥】"></a>高频算法题系列：栈【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>最小栈【简单】【栈】</li><li>有效的括号【中等】【栈】【面试真题】</li><li>简化路径【中等】【栈】</li><li>下一个更大元素 【系列】【栈】</li></ul><h2 id="最小栈【栈】"><a href="#最小栈【栈】" class="headerlink" title="最小栈【栈】"></a>最小栈【栈】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/min-stack/submissions/" target="_blank" rel="noopener">155 最小栈（简单）</a><sup>[51]</sup></p><p>题解</p><pre><code class="javascript">/** * initialize your data structure here. */var MinStack = function () {    this.stack = [];    this.minArr = [];    this.count = 0;    this.min = Number.MAX_SAFE_INTEGER;};/** * @param {number} x * @return {void} */MinStack.prototype.push = function (x) {    this.min = Math.min(this.min, x);    this.minArr[this.count] = this.min;    this.stack[this.count] = x;    this.count++;};/** * @return {void} */MinStack.prototype.pop = function () {    const element = this.stack[this.count - 1];    if (this.count - 2 &gt;= 0) this.min = this.minArr[this.count - 2];    else this.min = Number.MAX_SAFE_INTEGER;    delete this.stack[this.count - 1];    delete this.minArr[this.count - 1];    this.count--;    return element;};/** * @return {number} */MinStack.prototype.top = function () {    if (this.count &gt;= 1) {        return this.stack[this.count - 1];    }    return null;};/** * @return {number} */MinStack.prototype.getMin = function () {    const element = this.minArr[this.count - 1];    return element;};/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */</code></pre><h2 id="【系列】下一个更大元素-【栈】"><a href="#【系列】下一个更大元素-【栈】" class="headerlink" title="【系列】下一个更大元素 【栈】"></a>【系列】下一个更大元素 【栈】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496 下一个更大元素 I（简单）</a><sup>[52]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503 下一个更大元素 II（中等）</a><sup>[53]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number[]} */var nextGreaterElements = function (nums) {    let ans = [];    let stack = new Stack();    const n = nums.length;    for (let i = 2 * n - 1; i &gt;= 0; i--) {        while (!stack.isEmpty() &amp;&amp; stack.top() &lt;= nums[i % n]) {            stack.pop();        }        ans[i % n] = stack.isEmpty() ? -1 : stack.top();        stack.push(nums[i % n]);    }    return ans;};class Stack {    constructor() {        this.count = 0;        this.items = [];    }    top() {        if (this.isEmpty()) return undefined;        return this.items[this.count - 1];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return undefined;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    isEmpty() {        return this.size() === 0;    }    size() {        return this.count;    }}</code></pre><p>##【面试真题】有效的括号【栈】</p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20 有效的括号（中等）</a><sup>[54]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {boolean} */var isValid = function (s) {          if (s.length === 0) {            return true;          }          if (s.length % 2 !== 0) {            return false;          }          let map = {            ')': '(',            ']': '[',            '}': '{',          };          let left = ['(', '[', '{'];          let right = [')', ']', '}'];          let stack = new Stack();          for (let i = 0; i &lt; s.length; i++) {            if (!right.includes(s[i])) {              stack.push(s[i]);            } else {              const matchStr = map[s[i]];              while (!stack.isEmpty()) {                const element = stack.pop();                if (left.includes(element) &amp;&amp; matchStr !== element) return false;                if (element === matchStr) break;              }            }          }          return stack.isEmpty();        };class Stack {  constructor() {    this.count = 0;    this.items = [];  }  push(element) {    this.items[this.count] = element;    this.count++;  }  pop() {    if (this.isEmpty()) return undefined;    const element = this.items[this.count - 1];    delete this.items[this.count - 1];    this.count--;    return element;  }  isEmpty() {    return this.size() === 0;  }  size() {    return this.count;  }}</code></pre><h2 id="简化路径【栈】"><a href="#简化路径【栈】" class="headerlink" title="简化路径【栈】"></a>简化路径【栈】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71 简化路径（中等）</a><sup>[55]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} path * @return {string} */var simplifyPath = function (path) {    let newPath = path.split('/');    newPath = newPath.filter(item =&gt; item !== "");    const stack = new Stack();    for (let s of newPath) {        if (s === '..') stack.pop();        else if (s !== '.') stack.push(s);    }    if (stack.isEmpty()) return '/';    let str = '';    while (!stack.isEmpty()) {        const element = stack.pop();        str = '/' + element + str;    }    return str;};function handleBack(stack, tag, num) {    if (!stack.isEmpty()) return num;    const element = stack.pop();    if (element === '..') return handleBack(stack, tag, num + 1);    else {        stack.push(element);        return num;    }}class Stack {    constructor() {        this.count = 0;        this.items = [];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return undefined;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    size() {        return this.count;    }    isEmpty() {        return this.size() === 0;    }}</code></pre><h1 id="高频算法题系列：DFS【🔥】"><a href="#高频算法题系列：DFS【🔥】" class="headerlink" title="高频算法题系列：DFS【🔥】"></a>高频算法题系列：DFS【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>岛屿的最大面积【中等】【DFS】</li><li>相同的树【简单】【DFS】</li></ul><h2 id="岛屿的最大面积【DFS】"><a href="#岛屿的最大面积【DFS】" class="headerlink" title="岛屿的最大面积【DFS】"></a>岛屿的最大面积【DFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">695 岛屿的最大面积（中等）</a><sup>[56]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} grid * @return {number} */let maxX, maxY;let visited;let globalMaxArea;var maxAreaOfIsland = function (grid) {    visited = new Set();    maxX = grid.length;    maxY = grid[0].length;    globalMaxArea = 0;    for (let i = 0; i &lt; maxX; i++) {        for (let j = 0; j &lt; maxY; j++) {            if (grid[i][j] === 1) {                visited.add(`(${i}, ${j})`);                globalMaxArea = Math.max(globalMaxArea, dfs(grid, i, j));            }            visited.clear();        }    }    return globalMaxArea;};function dfs(grid, x, y) {    let res = 1;    for (let i = -1; i &lt;= 1; i++) {        for (let j = -1; j &lt;= 1; j++) {            if (Math.abs(i) === Math.abs(j)) continue;            const newX = x + i;            const newY = y + j;            if (newX &gt;= maxX || newX &lt; 0 || newY &gt;= maxY || newY &lt; 0) continue;            if (visited.has(`(${newX}, ${newY})`)) continue;            visited.add(`(${newX}, ${newY})`);            const areaCnt = grid[newX][newY]            if (areaCnt === 1) {                const cnt = dfs(grid, newX, newY);                res += cnt;            }        }    }    return res;}</code></pre><h2 id="相同的树【DFS】"><a href="#相同的树【DFS】" class="headerlink" title="相同的树【DFS】"></a>相同的树【DFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100 相同的树（简单）</a><sup>[57]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */var isSameTree = function (p, q) {    if (p == null &amp;&amp; q == null) return true;    if (p == null || q == null) return false;    if (p.val !== q.val) return false;    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);};</code></pre><h1 id="高频算法题系列：回溯算法【🔥】"><a href="#高频算法题系列：回溯算法【🔥】" class="headerlink" title="高频算法题系列：回溯算法【🔥】"></a>高频算法题系列：回溯算法【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>N皇后【困难】【回溯算法】【面试真题】</li><li>全排列【中等】【回溯算法】</li><li>括号生成【中等】【回溯算法】</li><li>复原 IP 地址【中等】【回溯算法】</li><li>子集 【简单】【回溯算法】</li></ul><h2 id="【面试真题】N皇后【回溯算法】"><a href="#【面试真题】N皇后【回溯算法】" class="headerlink" title="【面试真题】N皇后【回溯算法】"></a>【面试真题】N皇后【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51 N皇后（困难）</a><sup>[58]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number} n * @return {string[][]} */let result = [];var solveNQueens = function (n) {    result = [];    let board = [];    for (let i = 0; i &lt; n; i++) {        board[i] = [];        for (let j = 0; j &lt; n; j++) {            board[i][j] = '.'        }    }    backtrack(0, board, n);    return result;};function deepClone(board) {    let res = [];    for (let i = 0; i &lt; board.length; i++) {        res.push(board[i].join(''));    }    return res;}function backtrack(row, board, n) {    if (row === n) {        result.push(deepClone(board));        return;    }    for (let j = 0; j &lt; n; j++) {        if (checkInValid(board, row, j, n)) continue;        board[row][j] = 'Q';        backtrack(row + 1, board, n);        board[row][j] = '.';    }}function checkInValid(board, row, column, n) {    // 行    for (let i = 0; i &lt; n; i++) {        if (board[i][column] === 'Q') return true;    }    for (let i = row - 1, j = column + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {        if (board[i][j] === 'Q') return true;    }    for (let i = row - 1, j = column - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {        if (board[i][j] === 'Q') return true;    }    return false;}</code></pre><h2 id="全排列【回溯算法】"><a href="#全排列【回溯算法】" class="headerlink" title="全排列【回溯算法】"></a>全排列【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46 全排列（中等）</a><sup>[59]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number[][]} */let results = [];var permute = function (nums) {    results = [];    backtrack(nums, []);    return results;};function backtrack(nums, track) {    if (nums.length === track.length) {        results.push(track.slice());        return;    }    for (let i = 0; i &lt; nums.length; i++) {        if (track.includes(nums[i])) continue;        track.push(nums[i]);        backtrack(nums, track);        track.pop();    }}</code></pre><h2 id="括号生成【回溯算法】"><a href="#括号生成【回溯算法】" class="headerlink" title="括号生成【回溯算法】"></a>括号生成【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22 括号生成（中等）</a><sup>[60]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number} n * @return {string[]} */var generateParenthesis = function (n) {    let validRes = [];    backtrack(n * 2, validRes, '');    return validRes;};function backtrack(len, validRes, bracket) {    if (bracket.length === len) {        if (isValidCombination(bracket)) {            validRes.push(bracket);        }        return;    }    for (let str of ['(', ')']) {        bracket += str;        backtrack(len, validRes, bracket);        bracket = bracket.slice(0, bracket.length - 1);    }}function isValidCombination(bracket) {    let stack = new Stack();    for (let i = 0; i &lt; bracket.length; i++) {        const str = bracket[i];        if (str === '(') {            stack.push(str);        } else if (str === ')') {            const top = stack.pop();            if (top !== '(') return false;        }    }    return stack.isEmpty();}class Stack {    constructor() {        this.count = 0;        this.items = [];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    size() {        return this.count;    }    isEmpty() {        return this.size() === 0;    }}</code></pre><h2 id="复原-IP-地址【回溯算法】"><a href="#复原-IP-地址【回溯算法】" class="headerlink" title="复原 IP 地址【回溯算法】"></a>复原 IP 地址【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93 复原 IP 地址（中等）</a><sup>[61]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {string[]} */var restoreIpAddresses = function (s) {    if (s.length &gt; 12) return [];    let res = [];    const track = [];    backtrack(s, track, res);    return res;};function backtrack(s, track, res) {    if (track.length === 4 &amp;&amp; s.length === 0) {        res.push(track.join('.'));        return;    }    let len = s.length &gt;= 3 ? 3 : s.length;    for (let i = 0; i &lt; len; i++) {        const c = s.slice(0, i + 1);        if (parseInt(c) &gt; 255) continue;        if (i &gt;= 1 &amp;&amp; parseInt(c) &lt; parseInt((1 + '0'.repeat(i)))) continue;        track.push(c);        backtrack(s.slice(i + 1), track, res);        track.pop();    }}</code></pre><p>##　子集【回溯算法】</p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78 子集（中等）</a><sup>[62]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number[][]} */var subsets = function (nums) {    if (nums.length === 0) return [[]];    let resArr = [];    backtrack(nums, 0, [], resArr);    return resArr;};function backtrack(nums, index, subArr, resArr) {    if (Array.isArray(subArr)) {        resArr.push(subArr.slice());    }    if (index === nums.length) {        return;    }    for (let i = index; i &lt; nums.length; i++) {        subArr.push(nums[i]);        backtrack(nums, i + 1, subArr, resArr);        subArr.pop(nums[i]);    }}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<br>【LeetCode 直通车】：234 回文链表（简单）: <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p><p>[2]<br>【LeetCode 直通车】：206 反转链表（简单）: <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>[3]<br>【LeetCode 直通车】：23 合并K个升序链表（困难）: <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p><p>[4]<br>【LeetCode 直通车】：25 K 个一组翻转链表（困难）: <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p><p>[5]<br>【LeetCode 直通车】：141 环形链表（简单）: <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p>[6]<br>【LeetCode 直通车】：148 排序链表（中等）: <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/</a></p><p>[7]<br>【LeetCode 直通车】：160 相交链表（简单）: <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><p>[8]<br>【LeetCode 直通车】：5 最长回文子串（中等）: <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>[9]<br>【LeetCode 直通车】：14 最长公共前缀（简单）: <a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p><p>[10]<br>【LeetCode 直通车】：3 无重复字符的最长子串（中等）: <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>[11]<br>【LeetCode 直通车】：76 最小覆盖子串（困难）: <a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-window-substring/</a></p><p>[12]<br>【LeetCode 直通车】：354 俄罗斯套娃信封问题（困难）: <a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/russian-doll-envelopes/</a></p><p>[13]<br>【LeetCode 直通车】：674 最长连续递增序列（简单）: <a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/</a></p><p>[14]<br>【LeetCode 直通车】：128 最长连续序列（困难）: <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence/</a></p><p>[15]<br>【LeetCode 直通车】：11 盛最多水的容器（中等）: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>[16]<br>【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）: <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><p>[17]<br>【LeetCode 直通车】：26 删除有序数组中的重复项（简单）: <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><p>[18]<br>【LeetCode 直通车】：695 岛屿的最大面积（中等）: <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island/</a></p><p>[19]<br>【LeetCode 直通车】：560 和为K的子数组（中等）: <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p><p>[20]<br>【LeetCode 直通车】：1 两数之和（简单）: <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p><p>[21]<br>【LeetCode 直通车】：167 两数之和 II - 输入有序数组（简单）: <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p><p>[22]<br>【LeetCode 直通车】：15 三数之和（中等）: <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p><p>[23]<br>【LeetCode 直通车】：18 四数之和（中等）: <a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum/</a></p><p>[24]<br>【LeetCode 直通车】：42 接雨水（困难）: <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water/</a></p><p>[25]<br>【LeetCode 直通车】：55 跳跃游戏（中等）: <a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game/</a></p><p>[26]<br>【LeetCode 直通车】：45 跳跃游戏 II（中等）: <a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game-ii/</a></p><p>[27]<br>【LeetCode 直通车】：236 二叉树的最近公共祖先（简单）: <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><p>[28]<br>【LeetCode 直通车】：700 二叉搜索树中的搜索（简单）: <a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/</a></p><p>[29]<br>【LeetCode 直通车】：450 删除二叉搜索树中的节点（中等）: <a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-bst/</a></p><p>[30]<br>【LeetCode 直通车】：222 完全二叉树的节点个数（中等）: <a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></p><p>[31]<br>【LeetCode 直通车】：103 二叉树的锯齿形层序遍历（中等）: <a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/</a></p><p>[32]<br>【LeetCode 直通车】：452 用最少数量的箭引爆气球（中等）: <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><p>[33]<br>【LeetCode 直通车】：56 合并区间（中等）: <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-intervals/</a></p><p>[34]<br>【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）: <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><p>[35]<br>【LeetCode 直通车】：392 判断子序列（简单）: <a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/is-subsequence/</a></p><p>[36]<br>【LeetCode 直通车】：34 在排序数组中查找元素的第一个和最后一个位置（中等）: <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><p>[37]<br>【LeetCode 直通车】：300 最长递增子序列（中等）: <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><p>[38]<br>【LeetCode 直通车】：322 零钱兑换（中等）: <a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p><p>[39]<br>【LeetCode 直通车】：1143 最长公共子序列（中等）: <a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p><p>[40]<br>【LeetCode 直通车】：72 编辑距离（困难）: <a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/</a></p><p>[41]<br>【LeetCode 直通车】：516 最长回文子序列（中等）: <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-subsequence/</a></p><p>[42]<br>【LeetCode 直通车】：53 最大子序和（简单）: <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p>[43]<br>【LeetCode 直通车】：121 买卖股票的最佳时机（简单）: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>[44]<br>【LeetCode 直通车】：122 买卖股票的最佳时机 II（简单）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>[45]<br>【LeetCode 直通车】：123 买卖股票的最佳时机 III（困难）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>[46]<br>【LeetCode 直通车】：188 买卖股票的最佳时机IV（困难）: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>[47]<br>【LeetCode 直通车】：309 买卖股票的最佳时机含冷冻期（中等）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p>[48]<br>【LeetCode 直通车】：714 买卖股票的最佳时机含手续费（中等）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><p>[49]<br>【LeetCode 直通车】：752 打开转盘锁（中等）: <a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/open-the-lock/</a></p><p>[50]<br>【LeetCode 直通车】：111 二叉树的最小深度（简单）: <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><p>[51]<br>【LeetCode 直通车】：155 最小栈（简单）: <a href="https://leetcode-cn.com/problems/min-stack/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack/submissions/</a></p><p>[52]<br>【LeetCode 直通车】：496 下一个更大元素 I（简单）: <a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-i/</a></p><p>[53]<br>【LeetCode 直通车】：503 下一个更大元素 II（中等）: <a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-ii/</a></p><p>[54]<br>【LeetCode 直通车】：20 有效的括号（中等）: <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a></p><p>[55]<br>【LeetCode 直通车】：71 简化路径（中等）: <a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/simplify-path/</a></p><p>[56]<br>【LeetCode 直通车】：695 岛屿的最大面积（中等）: <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island/</a></p><p>[57]<br>【LeetCode 直通车】：100 相同的树（简单）: <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p><p>[58]<br>【LeetCode 直通车】：51 N皇后（困难）: <a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p><p>[59]<br>【LeetCode 直通车】：46 全排列（中等）: <a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p><p>[60]<br>【LeetCode 直通车】：22 括号生成（中等）: <a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/</a></p><p>[61]<br>【LeetCode 直通车】：93 复原 IP 地址（中等）: <a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/restore-ip-addresses/</a></p><p>[62]<br>【LeetCode 直通车】：78 子集（中等）: <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p>]]></content>
    
    
    <summary type="html">现在大厂面试中，算法题几乎为必考项，且近几年频现 LeetCode 真题，此篇为拿到字节、腾讯、京东 Offer 的笔者本人在准备面试过程中亲自刷过以及遇到过高频算法题。文章内容会分模块整理，对于笔者在面试过程中遇到的真题，会给予着重 【🔥】标出。</summary>
    
    
    
    <category term="编程技术" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>202104赛季晋级赛第一关-答案</title>
    <link href="http://yoursite.com/2021/05/crimaster-trace-battle-for-promotion-202104-1-ans/"/>
    <id>http://yoursite.com/2021/05/crimaster-trace-battle-for-promotion-202104-1-ans/</id>
    <published>2021-05-01T12:00:00.000Z</published>
    <updated>2021-05-17T13:56:02.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>中国香港港铁东铁线</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>网络迷踪由于线索取景真实，所以解题思路并不唯一，但答案唯一。本题解析仅为其中一种方法。</p><p>本关的歧义主要在于轨道交通系统名称，港铁是由九广铁路与香港地铁合并而成，随后注册名称叫做港铁。示例中的澳门轻轨是一个意思。</p><div class="text-center"><img src="/assets/images/crimaster/2021/05/20210501-ans-1.png" alt="港铁" class="post-image inline" style="width:30%"><img src="/assets/images/crimaster/2021/05/20210501-ans-2.png" alt="澳门轻轨" class="post-image inline" style="width:30%"></div><p>单看视频可能没有什么特定的头绪。不妨筛选出有用的线索。</p><p>仔细聆听声音，可以在视频末端聆听到一则语音播报:</p><video controls="" class="post-video half"><source src="/assets/videos/crimaster/2021/05/20210501-1.mp4" type="video/mp4"></video><p>利用音频翻译搜寻可以得出，此为广东话:下一站。车行走缓慢均匀且在路轨上行驶，说明即将抵达站台，由此可以大致确定为使用广东话为播报的某地铁内所拍摄。</p><p>语音播报为广东话，而使用广东话为语音播报的城市有:中国广东省，中国香港，中国澳门。</p><p>中国广东省车内语音播报提示顺序为先普通话后广东话(语)，视频中先是粵语，所以排除中国广东省</p><p>中国澳门轻铁以及中国香港港铁均是使用广东话(粵语)为主语的城市，列车语言播报顺序为:先粤语，后普通话，再英语。</p><p>我们需要进行进一步排除，当进行谷歌搜索了解港铁与澳门轻铁车语音播报内容时发现:中国香港的港铁播报方式为:“下一站x”，而中国澳门的轻铁播报方式为:“即将到达x”。视频内播报为:“下一站”，由此我们仅从视频中的一句播报，便可锁定该列车为中国香港港</p><p>铁: HK MTR</p><p>根据视频里的风景可以推断出这是在地上的线路。利用谷歌实景地图翻阅香港各大站可以筛选出地上站台有:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-3.png" alt="" class="post-image"><p>线路站点</p><table><thead><tr><th>线路</th><th>站点</th></tr></thead><tbody><tr><td>东铁线</td><td>全线</td></tr><tr><td>西铁线</td><td>屯门、兆康、天水围、郎屏、元朗、锦上路</td></tr><tr><td>观塘线</td><td>彩虹、九龙湾、牛头角、观塘、蓝田</td></tr><tr><td>荃湾线</td><td>荃湾、葵兴、葵芳、荔景</td></tr><tr><td>迪士尼线</td><td>欣澳、迪士尼</td></tr><tr><td>东涌线</td><td>荔景、欣澳、东涌</td></tr><tr><td>机场快线</td><td>荔景、机场、欣澳</td></tr><tr><td>南港岛线</td><td>海洋公园、黄竹坑、利东、海怡丰岛</td></tr><tr><td>马鞍山线</td><td>全线</td></tr></tbody></table><p>符合条件的站台太多，这样一一排査太费时间，我们需要再缩小范围。</p><p>从视频里我们可以发现这样一景</p><img src="/assets/images/crimaster/2021/05/20210501-ans-4.png" alt="" class="post-image"><p>一排排房子。我们可以借此确定列车方位。香港位于中国，太阳日出东方，日落西方，视频中右侧可看到房屋的阳光照射角度，用太阳方位推断列车自西向东行驶。</p><p>香港是沿海城市，视频里的走向没有经过海，且一般铁路设计不会靠着海行驶，中间会隔着马路。所以可以确定这段路程非沿海所行。结合以上两点，我们可以排除许多车站，只剩下:</p><div class="text-center"><img src="/assets/images/crimaster/2021/05/20210501-ans-5.png" alt="" style="height: 55px" class="post-image inline"><img src="/assets/images/crimaster/2021/05/20210501-ans-6.png" alt="" style="height: 55px" class="post-image inline"><img src="/assets/images/crimaster/2021/05/20210501-ans-7.png" alt="" style="height: 55px" class="post-image inline"></div><p>这里再次涉及到香港车内播报的一个习俗:除两头终点站外，车内语音播报会在快到下一站时才会播报。而观塘线的彩虹站至九龙湾站以及南港岛线的黄竹坑至海洋公园站快到站台都已经分别为北南走向及南北走向。所以排除。因此也可以排除东铁线的罗湖/落马洲站至上水站以及大学至火炭站。</p><p>推理至此，符合条件的仅剩下东铁线，此时答案已经明确，当然如果我们足够耐心，甚至可以进一步推测出该列车下一站的站点。</p><p>至此，为推测列车下一站站点，我们可以锁定到:上水至粉岭站，粉岭至太和站，太和至大埔墟站，大埔墟至大学站这些路线进行排查。</p><p>路程较远我们依旧无法很好的锁定。视频里又可以为我们提供信息。视频先后为我们提供了:</p><p>公交车:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-8.png" alt="" class="post-image half"><p>高速公路:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-9.png" alt="" class="post-image half"><p>高压线缆:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-10.png" alt="" class="post-image half"><p>房屋:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-11.png" alt="" class="post-image half"><p>小马路:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-12.png" alt="" class="post-image half"><p>由此可以推断后来的房屋与铁路成直线。高压线缆，与铁路交汇。高速公路可能开始呈一直线，后来分岔。以及沿途涉及公交路线。这给我们进行实景搜索提供很多信息。</p><p>只要足够耐心，最后经过谷歌地球实景，我们可以在通往大埔墟的线段里发现这一风景。</p><p>本次网络迷踪的挑战可以让我们知道，一句简单的语音播报也能蕴含许多信息，类似于此类信息的还有车牌号，电话号等具有区域性及规律性的讯息，这些都是让我们突破惯性思维，得到真相的关键。通过一句语音播报，一段风景视频，利用互联网各类工具及知识，便可查找出视频拍摄者的具体位置，即便在这过程中些许枯燥，但每一次新的突破口涌入脑中，都会是一次思维风暴，这便是网络迷踪中逻辑及推理的魅力!</p>]]></content>
    
    
    <summary type="html">202104赛季晋级赛第一关答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    
    <category term="网络迷踪-解答" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
</feed>
