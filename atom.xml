<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星星杂货铺</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-10T11:27:45.891Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gustin Lau</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>极速破译-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Speed-Decipher-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Speed-Decipher-Ans/</id>
    <published>2021-05-09T12:00:00.000Z</published>
    <updated>2021-05-10T11:27:45.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>春丛认取双蝶</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><font style="color:#D9730D">后续:似乎警队只是抓到了被嫁祸之人，真正的手与被嫁祸人有深仇大恨，身边至亲人的离世与被嫁祸者有关!</font></p><p>本题有多种解法，需一一尝试，因诗词的提示所以其它皆为乱序，无法得出答案。</p><p>正确解题过程：</p><p>内华达州机密区域为51区，因此所需步骤为24即所有白格都要走一遍。天空到地狱，意为自上 而下的顺序，下面有R和E，但是右下角的E只有 一条能单向通向它的路，而且又要求所有格子都走完，所以E必定是起始点或终点(所以把极高处到底端理解为字母表中从A到Z的也可以通过观察这一点排除)，同理左上角的C也能这样确定是起始或终点，所以最终只能是左上角的C到右下角的E。</p><p>提示一为“王，皇后，战车与主教”，意为国际象棋，赤兔是马，马走L型，根据提示需要走24步，从头到尾走完所经历的字母，便是答案。</p><p>(即<font style="color:#D9730D">CHUNCONGRENQUSHUANGQIDIE</font>，根据答案要求的七个汉字加上诗词的提示得到:<font style="color:#D9730D">春丛认取双栖蝶</font>)</p><img src="/assets/images/crimaster/2021/05/20210509-ans-1.png" alt="图片" class="post-image half">]]></content>
    
    
    <summary type="html">20210509期侦探委托《神秘交易》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>极速破译</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Speed-Decipher/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Speed-Decipher/</id>
    <published>2021-05-09T00:00:00.000Z</published>
    <updated>2021-05-09T02:44:22.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>近日刑警平次和其团队告破了一起重大连环杀人案，但最终本该庆祝的时刻，平次忽然意识到案发时凶手使用某物件所对应的身高区间，与所抓嫌疑人不符，他急忙赶回现场，在隐秘角落里发现这样一条奇怪的图文。</p><img src="/assets/images/crimaster/2021/05/20210509-1.png" alt="图片" class="post-image half"><p>文：自天空极高处直至地狱的底端，追寻赤兔的足迹。(所需步骤为内华达州机密区域所对应数字减3的一半)</p><p><font style="color:#D9730D">提示1:王、皇后、战车与主教</font></p><p><font style="color:#D9730D">提示2:诗词</font></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>七个汉字</p>]]></content>
    
    
    <summary type="html">近日刑警平次和其团队告破了一起重大连环杀人案，但最终本该庆祝的时刻，平次忽然意识到案发时凶手使用某物件所对应的身高区间，与所抓嫌疑人不符，他急忙赶回现场，在隐秘角落里发现这样一条奇怪的图文。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>哥哥的礼物-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Brother&#39;s-Gift-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Brother&#39;s-Gift-Ans/</id>
    <published>2021-05-08T12:00:00.000Z</published>
    <updated>2021-05-09T02:36:48.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>cop</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>密码箱打开了，哥哥居然送了我一本CRIMASTERA解密本，上面还有一段哥哥写给我的话:</p><p>努力的苦读，就为这一刻！把你的实力全部发挥，所有关爱着你的人，都会为你祝福祈祷，相信你一定会考出满意的成绩！</p><p><font style="color:#D9730D">(作者在此祝愿莘莘学子们都能够金榜题名)</font></p><p>解题过程：</p><p>将连接处折叠形成一个正十二面体(提示降维打击指从三维立体到二维平面，需将平面还原成立体)十二面体中距离X最远的面是它的对面就是2，所以2就是O。骆驼英文是camel，与O相邻的面是3、5、6、7、8，所以3、5、6、7、8是camel但是具体对应还不明确。Z的一圈是X、1、5、8、4，5和8已经有字母了，所以1，4就是I、P，因为P不和Y相邻，所以1是P、4是。和Z、P都相邻的面是X和5，所以5是C，顺时针排一圈，5是C、8是A、7是M、6是E、3是L。再用和L是对面验证，成立。就剩下9，所以9是N。</p><img src="/assets/images/crimaster/2021/05/20210508-ans-1.png" alt="" class="post-image half no-limit-height"><p>按照1到9排列得policeman(警察)，将其镜像反转得到</p><img src="/assets/images/crimaster/2021/05/20210508-ans-2.png" alt="" class="post-image half no-limit-height"><p>台球中1-黄色，2-蓝色，3-红色，4-紫色，5桔色，6-绿色，7酱色，8-黑色，9-黄/白色，10-蓝/白色，11-红/白色，12-紫/白色，13-桔/白色，14-绿/白色，15-酱/白色对应就是589，即cop(警察)。</p>]]></content>
    
    
    <summary type="html">20210508期侦探委托《哥哥的礼物》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托-解答" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>哥哥的礼物</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Delegate-Brother&#39;s-Gift/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Delegate-Brother&#39;s-Gift/</id>
    <published>2021-05-08T00:00:00.000Z</published>
    <updated>2021-05-09T02:31:57.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>今天是哥哥从警校回家的日子，好在他还记得我这个妹妹还有几十天就要中考了，破天荒的为我准备了一份礼物，但是需要解开密码箱才能够拿到。</p><p>箱子上的一副图和一段话如下：</p><img src="/assets/images/crimaster/2021/05/20210508-1.png" alt="图片" class="post-image half"><p>提示：</p><p>整个世界被降维打击，请准确还原。Z有两边是 I、P，骆驼顺时绕O转一圈，P、Y吵架不相邻， Z、P也和C相邻，离X最远的是O，I、L是对面，最后一处就是N。</p><p>球杆依次击中正义之职在镜子中的桔、黑及黄白寻找答案。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>三个字母的单词</p>]]></content>
    
    
    <summary type="html">今天是哥哥从警校回家的日子，好在他还记得我这个妹妹还有几十天就要中考了，破天荒的为我准备了一份礼物，但是需要解开密码箱才能够拿到。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>地球保卫战-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Challenge-Earth-Defense-Force-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Challenge-Earth-Defense-Force-Ans/</id>
    <published>2021-05-05T12:00:00.000Z</published>
    <updated>2021-05-05T14:42:44.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>skullisland</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>观察第一幅图可知，这和猪圈密码有关</p><img src="/assets/images/crimaster/2021/05/20210505-ans-1.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210505-ans-2.png" alt="图片" class="post-image half"><p>则根据密码表根据观察得到，红对应的为M，蓝对应的为Z，紫对应的为H，根据第二张图可知， 第一张图的三个字母与第二张图的三个字母有某种正确对应关系。根据提示(找到正确的字母)，意思是告诉我们将进行字母按字母表顺序将对应。接下来将进行试错，若M对应V，H就将对应A，Z对应N，将无法按字母表顺序得到新的关系。</p><p>以此类推，最终确认M对应A，H对应V，Z对应N。如图，我们得到了新的对应表。</p><img src="/assets/images/crimaster/2021/05/20210505-ans-3.png" alt="图片" class="post-image half"><p>此时看第三张图，发现所给音素为元音音素，提示为元音密码，根据/将数字进行几个为一组的分组则可以得到</p><p>2/52/22/53/53/5/2/53/34/55/41</p><p>此时用元音密码则可以解出EWGXXUEXMZP</p><img src="/assets/images/crimaster/2021/05/20210505-ans-4.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210505-ans-5.png" alt="图片" class="post-image half"><p>此时得到的EWGXXUEXMZP带回对应表中，此时并不知道正确的明文密文对应方向，将进行两次试错：</p><p>1.若M为开头的为明文，A开头的为密文则，可得到qisjjgqjylb</p><p>2.若A开头的为明文，M开头的为密文，则可得到skullisland</p><p>综上所述，第2种有明显意义，所以答案为skull island</p><p>珂欣说:“让我们去骷髅岛？可那里不是已经沦陷了？”</p><p>浩玥说:“我们不能失去诗吟，想办法一定要去救她！”</p><p>LL说:“基地里的装备应该足以抵御那里的变异物种了！”</p><p>三人立即收拾了装备以及物资前往了骷髅岛。</p>]]></content>
    
    
    <summary type="html">202103期全民挑战《地球保卫战》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="全民挑战" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
    
    <category term="全民挑战-解答" scheme="http://yoursite.com/tags/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>地球保卫战</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Challenge-Earth-Defense-Force/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Challenge-Earth-Defense-Force/</id>
    <published>2021-05-05T00:00:00.000Z</published>
    <updated>2021-05-05T14:31:14.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>时间:六十世纪</p><p>地点:地球</p><p>背景:能源危机，地球生灵涂炭。</p><p>团队:地球守护小组</p><p>LL，浩玥，珂欣三人在进行飞船的研制与新能源的研究。</p><p>LL说:“诗吟去哪了?”</p><p>珂欣说:“大概三小时前，超级电波就联系不上她了。”</p><p>浩玥说:“马上进入紧急状态，去诗吟家找她”</p><p>三人带上武器装备，立即前往诗吟家。可诗吟家中的景象让三人瞠目结舌，房间凌乱不堪，有过被入侵的迹象，在一番仔细搜査后，一个用高分子纳米科技的码锁被发现，LL熟练的输入了密码。里面存放着三张图片，三人便对着图片思索起来。“她一定是要告诉我们什么信息!”</p><img src="/assets/images/crimaster/2021/05/20210505-1.png" alt="图片" class="post-image half"><p>请找到正确的对照表格并解出数字所表达的一处地点。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入答案11个字母不区分大小写及空格</p>]]></content>
    
    
    <summary type="html">LL，浩玥，珂欣三人在进行飞船的研制与新能源的研究。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="全民挑战" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
    
    <category term="全民挑战" scheme="http://yoursite.com/tags/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>第一期测试题-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Challenge-Test-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Challenge-Test-Ans/</id>
    <published>2021-05-04T06:23:40.061Z</published>
    <updated>2021-05-04T06:37:13.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>狄仁杰</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>marple小姐，翻译成中文最为广泛的版本就是简・马普尔。</p><p>根据线索:在马普尔小姐的指示下。</p><p>简可拆分为三个字，竹，门，日。诗集主编为，两张图片右下有角标，分别是竹和日。按照写字顺序先竹，然后门，再者是日。</p><p>竹的图</p><img src="/assets/images/crimaster/2021/05/20210503-ans-1.png" alt="图片" class="post-image half"><p>下有一句话:字母化数，把marple在十六位字母表中的序号化出来得1311816125。接下来写”门”</p><p>诗有五首，我们把数字化成五份13/11/81/61/25。</p><p>与査询的古诗对应(在其中可能会拿数字有人去对应诗的题目，但是每一首诗都有说明作者，说明我们应该查询古诗)</p><img src="/assets/images/crimaster/2021/05/20210503-ans-2.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-ans-3.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-ans-4.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-ans-5.png" alt="图片" class="post-image half"><p>按照13/11/81/61/25尝试各种的方式对应，得出唯一合理的答案，不计算撇捺</p><p>接下来就是日的图片:</p><img src="/assets/images/crimaster/2021/05/20210503-ans-6.png" alt="图片" class="post-image half"><p>把不计算撇捺的方式带入进去:(笔画可以上各大搜索引擎查询，基本无异议</p><p>只:竖、横折、横、撇、点。</p><p>雁:橫、撇、撇、竖、撇、竖、点、横、横、橫、竖、横。</p><p>躁:竖、横折、横、竖、橫、竖、提、竖、横折、橫、竖、横折、横、竖、横折、横、横、竖、撇、捺。</p><p>年:撇、横、横、竖、横、竖。</p><p>靠:撇、横、竖、橫、竖、横折、横、竖、横、橫、橫、竖、横、横、横。</p><p>就:点、横、竖、橫折、横、竖钩、撇、点、橫、撇、竖弯钩、点。</p><p>思:竖、橫折、横、竖、横、点、斜钩、点、点。</p><p>民:横折、横、竖提、橫、斜钩。</p><p>去除撇捺，计算得:4.9.18.5.14.10.9.5。再次转 变成字母可得: DIRENJIE</p><p>答案即为狄仁杰。</p><p>我们中国著名的侦探例如宋慈，狄仁杰，包拯等，在历史上，他们是古代封建社会統治下平民的希望寄托。 </p><p>公正严明，铁面无私———包拯</p><p>公元676至679年，升为了大理寺寺丞，解決了大量积压的案件，涉案人员高达1.7万人，却没有任何人状告他判決有误———狄仁杰</p><p>中外法医界普遍认为是宋慈于公元1235年开创了“法医鉴定学”，因此宋慈被尊为世界法医学鼻祖———宋慈</p><p>我们向先人致敬。</p><p>同时，向马普尔小姐致敬。侦探精神不分年不分性别，不分国界，有的，只是你和我心中那份对推理的热爱。</p>]]></content>
    
    
    <summary type="html">202103期全民挑战《第一期测试题》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="全民挑战" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
    
    <category term="全民挑战-解答" scheme="http://yoursite.com/tags/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>第一期测试题</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Challenge-Test/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Challenge-Test/</id>
    <published>2021-05-03T00:00:00.000Z</published>
    <updated>2021-05-04T06:23:40.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>我收到了一份神秘的信件，貌似是一位我在网络上结识的好友给我发来的，希望大家帮我一同破解这一份神秘的信件。信件容如下:</p><p><font style="color:#D9730D">听说你是马普尔(Jane Marple)小姐的忠实粉丝，我也是。而且我也特别喜欢中华文化，希望通过你的帮助，在marple小姐的指示下，寻找 一位我同样喜欢的侦探。</font></p><p>信中附带一本诗集，名称为“<font style="color:#D9730D">门</font>”。内容如下：</p><p><font style="color:#D9730D">古朗月行(唐・李白)</font><br><font style="color:#D9730D">摸鱼儿·春光(宋・李裕翁)</font><br><font style="color:#D9730D">暗香日时月色(宋·姜)</font><br><font style="color:#D9730D">与孟郊洛北野泉上煎茶(唐·刘言史)</font><br><font style="color:#D9730D">颂古一首其一(宋・释师一)</font></p><p>还有两张纸条：</p><img src="/assets/images/crimaster/2021/05/20210503-1.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/05/20210503-2.png" alt="图片" class="post-image half"><p>图下有一行字:<font style="color:#D9730D">字母化数</font></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入一位人物名称 （例:野田吴）</p>]]></content>
    
    
    <summary type="html">我收到了一份神秘的信件，貌似是一位我在网络上结识的好友给我发来的，希望大家帮我一同破解这一份神秘的信件。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="全民挑战" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
    
    <category term="全民挑战" scheme="http://yoursite.com/tags/%E5%85%A8%E6%B0%91%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>【转】字节跳动最爱考的64道算法题(JS版)</title>
    <link href="http://yoursite.com/2021/05/byte-dance-top-64-algorithm-problems-js-version/"/>
    <id>http://yoursite.com/2021/05/byte-dance-top-64-algorithm-problems-js-version/</id>
    <published>2021-05-02T00:00:00.000Z</published>
    <updated>2021-05-03T14:44:13.137Z</updated>
    
    <content type="html"><![CDATA[<p>本文来源于图雀社区，作者一只图雀。<br>原文链接： <a href="https://mp.weixin.qq.com/s/HsZo757NDNV-3xnGQjPtAQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HsZo757NDNV-3xnGQjPtAQ</a></p><p><font style="color:#D9730D">欢迎关注公众号：图雀社区。 如果你想从零开始以实战的方式学习一门技术，亦或是想动手做一个比较完整的项目以准备面试，相信 「图雀社区」 的内容都能够帮助到你，成为初入前端的你成长路上的指南针。</font></p><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>现在大厂面试中，算法题几乎为必考项，且近几年频现 LeetCode 真题，此篇为拿到字节、腾讯、京东 Offer 的笔者本人在准备面试过程中亲自刷过以及遇到过高频算法题。文章内容会分模块整理，对于笔者在面试过程中遇到的真题，会给予着重 【🔥】标出。</p><p>同时，可以毫不客气的说，如果你准备时间有限，又想追求算法题准备效率最大化，那么你只需要按照大纲把下面的题目刷完，并把代码烂熟于心，就几乎可以应对 90% 的面试算法考题了。</p><p>整理这篇内容的目的一个是笔者在之前准备面试时的一点积累，而它确实也帮助笔者在面试算法题中过关斩将，同时呢，也希望能够在金三银四给予拼搏的你，一点点帮助就好！💪</p><p>本篇内容包括如下模块：</p><ul><li>高频算法题系列：链表</li><li>高频算法题系列：字符串【🔥】【有真题】</li><li>高频算法题系列：数组问题【🔥】【有真题】</li><li>高频算法题系列：二叉树</li><li>高频算法题系列：排序算法【🔥】</li><li>高频算法题系列：二分查找【🔥】</li><li>高频算法题系列：动态规划【🔥】</li><li>高频算法题系列：BFS</li><li>高频算法题系列：栈【🔥】</li><li>高频算法题系列：DFS【🔥】</li><li>高频算法题系列：回溯算法【🔥】</li></ul><p>其中标🔥的部分代表非常高频的考题，其中不乏笔者遇到的原题。其中对于每一类，首先会列出包含的考题，然后针对每一道考题会给出难度、考察知识点、是否是面试真题，在每道题详细介绍时，还会给出每道题的 LeetCode 链接，帮助读者理解题意，以及能够进行实际的测验，还可以观看其他人的答案，更好的帮助准备。</p><h1 id="高频算法题系列：链表"><a href="#高频算法题系列：链表" class="headerlink" title="高频算法题系列：链表"></a>高频算法题系列：链表</h1><p>笔者遇到的高频链表题主要包含这几道：</p><ul><li>通过快慢指针寻找链表中点 【简单】</li><li>通过链表的后续遍历判断回文链表问题 【简单】</li><li>链表的反向输出 【简单】</li><li>合并 K 个升序链表 【困难】</li><li>K个一组翻转链表 【困难】</li><li>环形链表 【简单】</li><li>排序链表 【中等】</li><li>相交链表 【简单】</li></ul><h2 id="寻找链表中点"><a href="#寻找链表中点" class="headerlink" title="寻找链表中点"></a>寻找链表中点</h2><p>题解</p><p>通过快慢指针寻找链表中点</p><pre><code class="javascript">function findCenter(head) {  let slower = head, faster = head;  while (faster &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;  }  // 如果 faster 不等于 null，说明是奇数个，slower 再移动一格  if (faster != null) {    slower = slower.next;  }  return slower;}</code></pre><h2 id="前序遍历判断回文链表"><a href="#前序遍历判断回文链表" class="headerlink" title="前序遍历判断回文链表"></a>前序遍历判断回文链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234 回文链表（简单）</a><sup>[1]</sup></p><p>题解1</p><p>利用链表的后续遍历，使用函数调用栈作为后序遍历栈，来判断是否回文</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {boolean} */var isPalindrome = function (head) {  let left = head;  function traverse(right) {    if (right == null) return true;    let res = traverse(right.next);    res = res &amp;&amp; (right.val === left.val);    left = left.next;    return res;  }  return traverse(head);};</code></pre><p>题解2</p><p>通过快、慢指针找链表中点，然后反转链表，比较两个链表两侧是否相等，来判断是否是回文链表</p><pre><code class="javascript">var isPalindrome = function (head) {  // 反转 slower 链表  let right = reverse(findCenter(head));  let left = head;  // 开始比较  while (right != null) {    if (left.val !== right.val) {      return false;    }    left = left.next;    right = right.next;  }  return true;}function findCenter(head) {  let slower = head, faster = head;  while (faster &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;  }  // 如果 faster 不等于 null，说明是奇数个，slower 再移动一格  if (faster != null) {    slower = slower.next;  }  return slower;}function reverse(head) {  let prev = null, cur = head, nxt = head;  while (cur != null) {    nxt = cur.next;    cur.next = prev;    prev = cur;    cur = nxt;  }  return prev;}</code></pre><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206 反转链表（简单）</a><sup>[2]</sup></p><p>题解1</p><p>迭代</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function (head) {  let prev = null, curr = head  while (curr) {    const node = curr.next    curr.next = prev    prev = curr    curr = node  }  return prev};</code></pre><p>解题2</p><p>递归</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var reverseList = function (head) {  if (head == null || head.next == null) return head;  let last = reverseList(head.next);  head.next.next = head;  head.next = null;  return last;};</code></pre><h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23 合并K个升序链表（困难）</a><sup>[3]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode[]} lists * @return {ListNode} */var mergeKLists = function (lists) {    if (lists.length === 0) return null;    return mergeArr(lists);};function mergeArr(lists) {    if (lists.length &lt;= 1) return lists[0];    let index = Math.floor(lists.length / 2);    const left = mergeArr(lists.slice(0, index))    const right = mergeArr(lists.slice(index));    return merge(left, right);}function merge(l1, l2) {    if (l1 == null &amp;&amp; l2 == null) return null;    if (l1 != null &amp;&amp; l2 == null) return l1;    if (l1 == null &amp;&amp; l2 != null) return l2;    let newHead = null, head = null;    while (l1 != null &amp;&amp; l2 != null) {        if (l1.val &lt; l2.val) {            if (!head) {                newHead = l1;                head = l1;            } else {                newHead.next = l1;                newHead = newHead.next;            }            l1 = l1.next;        } else {            if (!head) {                newHead = l2;                head = l2;            } else {                newHead.next = l2;                newHead = newHead.next;            }            l2 = l2.next;        }    }    newHead.next = l1 ? l1 : l2;    return head;}</code></pre><h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25 K 个一组翻转链表（困难）</a><sup>[4]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @param {number} k * @return {ListNode} */var reverseKGroup = function (head, k) {    let a = head, b = head;    for (let i = 0; i &lt; k; i++) {        if (b == null) return head;        b = b.next;    }    const newHead = reverse(a, b);    a.next = reverseKGroup(b, k);    return newHead;};function reverse(a, b) {    let prev = null, cur = a, nxt = a;    while (cur != b) {        nxt = cur.next;        cur.next = prev;        prev = cur;        cur = nxt;    }    return prev;}</code></pre><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141 环形链表（简单）</a><sup>[5]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @return {boolean} */var hasCycle = function (head) {  if (head == null || head.next == null) return false;  let slower = head, faster = head;  while (faster != null &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;    if (slower === faster) return true;  }  return false;};</code></pre><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148 排序链表（中等）</a><sup>[6]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var sortList = function (head) {  if (head == null) return null;  let newHead = head;  return mergeSort(head);};function mergeSort(head) {  if (head.next != null) {    let slower = getCenter(head);    let nxt = slower.next;    slower.next = null;    // console.log(head, slower, nxt);    const left = mergeSort(head);    const right = mergeSort(nxt);    head = merge(left, right);  }  return head;}function merge(left, right) {  let newHead = null, head = null;  while (left != null &amp;&amp; right != null) {    if (left.val &lt; right.val) {      if (!head) {        newHead = left;        head = left;      } else {        newHead.next = left;        newHead = newHead.next;      }      left = left.next;    } else {      if (!head) {        newHead = right;        head = right;      } else {        newHead.next = right;        newHead = newHead.next;      }      right = right.next;    }  }  newHead.next = left ? left : right;  return head;}function getCenter(head) {  let slower = head, faster = head.next;  while (faster != null &amp;&amp; faster.next != null) {    slower = slower.next;    faster = faster.next.next;  }  return slower;}</code></pre><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160 相交链表（简单）</a><sup>[7]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} headA * @param {ListNode} headB * @return {ListNode} */var getIntersectionNode = function (headA, headB) {    let lastHeadA = null;    let lastHeadB = null;    let originHeadA = headA;    let originHeadB = headB;    if (!headA || !headB) {        return null;    }    while (true) {        if (headB == headA) {            return headB;        }        if (headA &amp;&amp; headA.next == null) {            lastHeadA = headA;            headA = originHeadB;        } else {            headA = headA.next;        }        if (headB &amp;&amp; headB.next == null) {            lastHeadB = headB            headB = originHeadA;        } else {            headB = headB.next;        }        if (lastHeadA &amp;&amp; lastHeadB &amp;&amp; lastHeadA != lastHeadB) {            return null;        }    }    return null;};</code></pre><h1 id="高频算法题系列：字符串【🔥】"><a href="#高频算法题系列：字符串【🔥】" class="headerlink" title="高频算法题系列：字符串【🔥】"></a>高频算法题系列：字符串【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>最长回文子串 【中等】【双指针】【面试真题】</li><li>最长公共前缀 【简单】【双指针】</li><li>无重复字符的最长子串【中等】【双指针】</li><li>最小覆盖子串 【困难】【滑动窗口】【面试真题】</li></ul><h2 id="【面试真题】最长回文子串【双指针】"><a href="#【面试真题】最长回文子串【双指针】" class="headerlink" title="【面试真题】最长回文子串【双指针】"></a>【面试真题】最长回文子串【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5 最长回文子串（中等）</a><sup>[8]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {string} */var longestPalindrome = function (s) {          if (s.length === 1) return s;          let maxRes = 0, maxStr = '';          for (let i = 0; i &lt; s.length; i++) {            let str1 = palindrome(s, i, i);            let str2 = palindrome(s, i, i + 1);            if (str1.length &gt; maxRes) {              maxStr = str1;              maxRes = str1.length;            }            if (str2.length &gt; maxRes) {              maxStr = str2;              maxRes = str2.length;            }          }          return maxStr;        };function palindrome(s, l, r) {  while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s[l] === s[r]) {    l--;    r++;  }  return s.slice(l + 1, r);}</code></pre><h2 id="最长公共前缀【双指针】"><a href="#最长公共前缀【双指针】" class="headerlink" title="最长公共前缀【双指针】"></a>最长公共前缀【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14 最长公共前缀（简单）</a><sup>[9]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string[]} strs * @return {string} */var longestCommonPrefix = function (strs) {    if (strs.length === 0) return "";    let first = strs[0];    if (first === "") return "";    let minLen = Number.MAX_SAFE_INTEGER;    for (let i = 1; i &lt; strs.length; i++) {        const len = twoStrLongestCommonPrefix(first, strs[i]);        minLen = Math.min(len, minLen);    }    return first.slice(0, minLen);};function twoStrLongestCommonPrefix(s, t) {    let i = 0, j = 0;    let cnt = 0;    while (i &lt; s.length &amp;&amp; j &lt; t.length) {        console.log(s[i], t[j], cnt)        if (s[i] === t[j]) {            cnt++;        } else {            return cnt;        }        i++;        j++;    }    return cnt;}</code></pre><h2 id="无重复字符的最长子串【双指针】"><a href="#无重复字符的最长子串【双指针】" class="headerlink" title="无重复字符的最长子串【双指针】"></a>无重复字符的最长子串【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3 无重复字符的最长子串（中等）</a><sup>[10]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function (s) {    let window = {};    let left = 0, right = 0;    let maxLen = 0, maxStr = '';    while (right &lt; s.length) {        let c = s[right];        right++;        if (window[c]) window[c]++;        else window[c] = 1        while (window[c] &gt; 1) {            let d = s[left];            left++;            window[d]--;        }        if (maxLen &lt; right - left) {            maxLen = right - left;        }    }    return maxLen;};</code></pre><h2 id="【面试真题】-最小覆盖子串【滑动窗口】"><a href="#【面试真题】-最小覆盖子串【滑动窗口】" class="headerlink" title="【面试真题】 最小覆盖子串【滑动窗口】"></a>【面试真题】 最小覆盖子串【滑动窗口】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76 最小覆盖子串（困难）</a><sup>[11]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @param {string} t * @return {string} */var minWindow = function (s, t) {    let need = {}, window = {};    for (let c of t) {        if (!need[c]) need[c] = 1;        else need[c]++;    }    let left = 0, right = 0;    let valid = 0, len = Object.keys(need).length;    let minLen = s.length + 1, minStr = '';    while (right &lt; s.length) {        const d = s[right];        right++;        if (!window[d]) window[d] = 1;        else window[d]++;        if (need[d] &amp;&amp; need[d] === window[d]) {            valid++;        }        console.log('left - right', left, right);        while (valid === len) {            if (right - left &lt; minLen) {                minLen = right - left;                minStr = s.slice(left, right);            }            console.lo            let c = s[left];            left++;            window[c]--;            if (need[c] &amp;&amp; window[c] &lt; need[c]) {                valid--;            }        }    }    return minStr;};</code></pre><h1 id="高频算法题系列：数组问题【🔥】"><a href="#高频算法题系列：数组问题【🔥】" class="headerlink" title="高频算法题系列：数组问题【🔥】"></a>高频算法题系列：数组问题【🔥】</h1><p>主要有几类高频考题：</p><ul><li>俄罗斯套娃信封问题【困难】【排序+最长上升子序列】【面试真题】</li><li>最长连续递增序列 【简单】【双指针】</li><li>最长连续序列【困难】【哈希表】</li><li>盛最多水的容器【困难】【面试真题】</li><li>寻找两个正序数组的中位数【困难】【双指针】</li><li>删除有序数组中的重复项【简单】【快慢指针】</li><li>和为K的子数组【中等】【哈希表】</li><li>nSum 问题【系列】【简单】【哈希表】</li><li>接雨水【困难】【暴力+备忘录优化】【面试真题】</li><li>跳跃游戏【系列】【中等】【贪心算法】</li></ul><h2 id="【面试真题】俄罗斯套娃信封问题【排序-最长上升子序列】"><a href="#【面试真题】俄罗斯套娃信封问题【排序-最长上升子序列】" class="headerlink" title="【面试真题】俄罗斯套娃信封问题【排序+最长上升子序列】"></a>【面试真题】俄罗斯套娃信封问题【排序+最长上升子序列】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354 俄罗斯套娃信封问题（困难）</a><sup>[12]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} envelopes * @return {number} */var maxEnvelopes = function (envelopes) {    if (envelopes.length === 1) return 1;    envelopes.sort((a, b) =&gt; {        if (a[0] !== b[0]) return a[0] - b[0];        else return b[1] - a[1];    });    let LISArr = [];    for (let [key, value] of envelopes) {        LISArr.push(value);    }    console.log(LISArr);    return LIS(LISArr);};function LIS(arr) {    let dp = [];    let maxAns = 0;    for (let i = 0; i &lt; arr.length; i++) {        dp[i] = 1;    }    for (let i = 1; i &lt; arr.length; i++) {        for (let j = i; j &gt;= 0; j--) {            if (arr[i] &gt; arr[j]) {                dp[i] = Math.max(dp[i], dp[j] + 1)            }            maxAns = Math.max(maxAns, dp[i]);        }    }    return maxAns;}</code></pre><h2 id="最长连续递增序列【快慢指针】"><a href="#最长连续递增序列【快慢指针】" class="headerlink" title="最长连续递增序列【快慢指针】"></a>最长连续递增序列【快慢指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674 最长连续递增序列（简单）</a><sup>[13]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var findLengthOfLCIS = function (nums) {    if (nums.length === 0) return 0;    const n = nums.length;    let left = 0, right = 1;    let globalMaxLen = 1, maxLen = 1;    while (right &lt; n) {        if (nums[right] &gt; nums[left]) maxLen++;        else {            maxLen = 1;        }        left++;        right++;        globalMaxLen = Math.max(globalMaxLen, maxLen);    }    return globalMaxLen;};</code></pre><h2 id="最长连续序列-【哈希表】"><a href="#最长连续序列-【哈希表】" class="headerlink" title="最长连续序列 【哈希表】"></a>最长连续序列 【哈希表】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128 最长连续序列（困难）</a><sup>[14]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var longestConsecutive = function (nums) {    if (nums.length === 0) return 0;    const set = new Set(nums);    const n = nums.length;    let globalLongest = 1;    for (let i = 0; i &lt; n; i++) {        if (!set.has(nums[i] - 1)) {            let longest = 1;            let currentNum = nums[i];            while (set.has(currentNum + 1)) {                currentNum += 1;                longest++;            }            globalLongest = Math.max(globalLongest, longest);        }    }    return globalLongest;};</code></pre><h2 id="【面试真题】盛最多水的容器【哈希表】"><a href="#【面试真题】盛最多水的容器【哈希表】" class="headerlink" title="【面试真题】盛最多水的容器【哈希表】"></a>【面试真题】盛最多水的容器【哈希表】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11 盛最多水的容器（中等）</a><sup>[15]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} height * @return {number} */var maxArea = function (height) {    let n = height.length;    let left = 0, right = n - 1;    let maxOpacity = 0;    while (left &lt; right) {        let res = Math.min(height[left], height[right]) * (right - left);        maxOpacity = Math.max(maxOpacity, res);        if (height[left] &lt; height[right]) left++        else right--;    }    return maxOpacity;};</code></pre><h2 id="寻找两个正序数组的中位数【双指针】"><a href="#寻找两个正序数组的中位数【双指针】" class="headerlink" title="寻找两个正序数组的中位数【双指针】"></a>寻找两个正序数组的中位数【双指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4 寻找两个正序数组的中位数（困难）</a><sup>[16]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */var findMedianSortedArrays = function (nums1, nums2) {    let m = nums1.length, n = nums2.length;    let i = 0, j = 0;    let newArr = [];    while (i &lt; m &amp;&amp; j &lt; n) {        if (nums1[i] &lt; nums2[j]) {            newArr.push(nums1[i++]);        } else {            newArr.push(nums2[j++]);        }    }    newArr = newArr.concat(i &lt; m ? nums1.slice(i) : nums2.slice(j));    const len = newArr.length;    console.log(newArr)    if (len % 2 === 0) {        return (newArr[len / 2] + newArr[len / 2 - 1]) / 2;    } else {        return newArr[Math.floor(len / 2)];    }};</code></pre><h2 id="删除有序数组中的重复项【快慢指针】"><a href="#删除有序数组中的重复项【快慢指针】" class="headerlink" title="删除有序数组中的重复项【快慢指针】"></a>删除有序数组中的重复项【快慢指针】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26 删除有序数组中的重复项（简单）</a><sup>[17]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var removeDuplicates = function (nums) {    if (nums.length &lt;= 1) return nums.length;    let lo = 0, hi = 0;    while (hi &lt; nums.length) {        while (nums[lo] === nums[hi] &amp;&amp; hi &lt; nums.length) hi++;        if (nums[lo] !== nums[hi] &amp;&amp; hi &lt; nums.length) {            lo++;            nums[lo] = nums[hi];        }        hi++;    }    return lo + 1;};</code></pre><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">695 岛屿的最大面积（中等）</a><sup>[18]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} grid * @return {number} */let maxX, maxY;let visited;let globalMaxArea;var maxAreaOfIsland = function (grid) {    visited = new Set();    maxX = grid.length;    maxY = grid[0].length;    globalMaxArea = 0;    for (let i = 0; i &lt; maxX; i++) {        for (let j = 0; j &lt; maxY; j++) {            if (grid[i][j] === 1) {                visited.add(`(${i}, ${j})`);                globalMaxArea = Math.max(globalMaxArea, dfs(grid, i, j));            }            visited.clear();        }    }    return globalMaxArea;};function dfs(grid, x, y) {    let res = 1;    for (let i = -1; i &lt;= 1; i++) {        for (let j = -1; j &lt;= 1; j++) {            if (Math.abs(i) === Math.abs(j)) continue;            const newX = x + i;            const newY = y + j;            if (newX &gt;= maxX || newX &lt; 0 || newY &gt;= maxY || newY &lt; 0) continue;            if (visited.has(`(${newX}, ${newY})`)) continue;            visited.add(`(${newX}, ${newY})`);            const areaCnt = grid[newX][newY]            if (areaCnt === 1) {                const cnt = dfs(grid, newX, newY);                res += cnt;            }        }    }    return res;}</code></pre><h2 id="和为K的子数组【哈希表】"><a href="#和为K的子数组【哈希表】" class="headerlink" title="和为K的子数组【哈希表】"></a>和为K的子数组【哈希表】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560 和为K的子数组（中等）</a><sup>[19]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @param {number} k * @return {number} */var subarraySum = function (nums, k) {    let cnt = 0;    let sum0_i = 0, sum0_j = 0;    let map = new Map();    map.set(0, 1);    for (let i = 0; i &lt;= nums.length; i++) {        sum0_i += nums[i];        sum0_j = sum0_i - k;        console.log('map', sum0_j, map.get(sum0_j))        if (map.has(sum0_j)) {            cnt += map.get(sum0_j);        }        let sumCnt = map.get(sum0_i) || 0;        map.set(sum0_i, sumCnt + 1);    }    return cnt;};</code></pre><h2 id="nSum问题【哈希表】【系列】"><a href="#nSum问题【哈希表】【系列】" class="headerlink" title="nSum问题【哈希表】【系列】"></a>nSum问题【哈希表】【系列】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1 两数之和（简单）</a><sup>[20]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167 两数之和 II - 输入有序数组（简单）</a><sup>[21]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15 三数之和（中等）</a><sup>[22]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18 四数之和（中等）</a><sup>[23]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题。</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @param {number} target * @return {number[]} */var twoSum = function (nums, target) {    let map2 = new Map();    for (let i = 0; i &lt; nums.length; i++) {        map2.set(nums[i], i);    }    for (let i = 0; i &lt; nums.length; i++) {        if (map2.has(target - nums[i]) &amp;&amp; map2.get(target - nums[i]) !== i) return [i, map2.get(target - nums[i])]    }};</code></pre><h2 id="接雨水【暴力-备忘录优化】"><a href="#接雨水【暴力-备忘录优化】" class="headerlink" title="接雨水【暴力+备忘录优化】"></a>接雨水【暴力+备忘录优化】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42 接雨水（困难）</a><sup>[24]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} height * @return {number} */var trap = function (height) {    let l_max = [], r_max = [];    let len = height.length;    let maxCapacity = 0;    for (let i = 0; i &lt; len; i++) {        l_max[i] = height[i];        r_max[i] = height[i];    }    for (let i = 1; i &lt; len; i++) {        l_max[i] = Math.max(l_max[i - 1], height[i]);    }    for (let j = len - 2; j &gt;= 0; j--) {        r_max[j] = Math.max(r_max[j + 1], height[j]);    }    for (let i = 0; i &lt; len; i++) {        maxCapacity += Math.min(l_max[i], r_max[i]) - height[i];    }    return maxCapacity;};</code></pre><h2 id="跳跃游戏【贪心算法】【系列】"><a href="#跳跃游戏【贪心算法】【系列】" class="headerlink" title="跳跃游戏【贪心算法】【系列】"></a>跳跃游戏【贪心算法】【系列】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55 跳跃游戏（中等）</a><sup>[25]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45 跳跃游戏 II（中等）</a><sup>[26]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题。</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {boolean} */var canJump = function(nums) {    let faster = 0;    for (let i = 0; i &lt; nums.length - 1; i++) {        faster = Math.max(faster, i + nums[i]);        if (faster &lt;= i) return false;    }    return faster &gt;= nums.length - 1;};</code></pre><h1 id="高频算法题系列：二叉树"><a href="#高频算法题系列：二叉树" class="headerlink" title="高频算法题系列：二叉树"></a>高频算法题系列：二叉树</h1><p>主要有以下几类高频考题：</p><ul><li>二叉树的最近公共祖先【简单】【二叉树】</li><li>二叉搜索树中的搜索【简单】【二叉树】</li><li>删除二叉搜索树中的节点【中等】【二叉树】</li><li>完全二叉树的节点个数【中等】【二叉树】</li><li>二叉树的锯齿形层序遍历【中等】【二叉树】</li></ul><h2 id="二叉树的最近公共祖先【二叉树】"><a href="#二叉树的最近公共祖先【二叉树】" class="headerlink" title="二叉树的最近公共祖先【二叉树】"></a>二叉树的最近公共祖先【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236 二叉树的最近公共祖先（简单）</a><sup>[27]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} */let visited;let parent;var lowestCommonAncestor = function (root, p, q) {  visited = new Set();  parent = new Map();  dfs(root);  while (p != null) {    visited.add(p.val);    p = parent.get(p.val);  }  while (q != null) {    if (visited.has(q.val)) {      return q;    }    q = parent.get(q.val);  }  return null;};function dfs(root) {  if (root.left != null) {    parent.set(root.left.val, root);    dfs(root.left);  }  if (root.right != null) {    parent.set(root.right.val, root);    dfs(root.right);  }}</code></pre><h2 id="二叉搜索树中的搜索【二叉树】"><a href="#二叉搜索树中的搜索【二叉树】" class="headerlink" title="二叉搜索树中的搜索【二叉树】"></a>二叉搜索树中的搜索【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700 二叉搜索树中的搜索（简单）</a><sup>[28]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {number} val * @return {TreeNode} */var searchBST = function (root, val) {    if (root == null) return null;    if (root.val === val) return root;    if (root.val &gt; val) {        return searchBST(root.left, val);    } else if (root.val &lt; val) {        return searchBST(root.right, val);    }};</code></pre><h2 id="删除二叉搜索树中的节点【二叉树】"><a href="#删除二叉搜索树中的节点【二叉树】" class="headerlink" title="删除二叉搜索树中的节点【二叉树】"></a>删除二叉搜索树中的节点【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450 删除二叉搜索树中的节点（中等）</a><sup>[29]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {number} key * @return {TreeNode} */var deleteNode = function (root, key) {    if (root == null) return null;    if (root.val === key) {        if (root.left == null &amp;&amp; root.right == null) return null;        if (root.left == null) return root.right;        if (root.right == null) return root.left;        if (root.left != null &amp;&amp; root.right != null) {            let target = getMinTreeMaxNode(root.left);            root.val = target.val;            root.left = deleteNode(root.left, target.val);        }    }    if (root.val &lt; key) {        root.right = deleteNode(root.right, key);    } else if (root.val &gt; key) {        root.left = deleteNode(root.left, key);    }    return root;};function getMinTreeMaxNode(root) {    if (root.right == null) return root;    return getMinTreeMaxNode(root.right);}</code></pre><h2 id="完全二叉树的节点个数【二叉树】"><a href="#完全二叉树的节点个数【二叉树】" class="headerlink" title="完全二叉树的节点个数【二叉树】"></a>完全二叉树的节点个数【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222 完全二叉树的节点个数（中等）</a><sup>[30]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */var countNodes = function (root) {    if (root == null) return 0;    let l = root, r = root;    let lh = 0, rh = 0;    while (l != null) {        l = l.left;        lh++;    }    while (r != null) {        r = r.right;        rh++;    }    if (lh === rh) {        return Math.pow(2, lh) - 1;    }    return 1 + countNodes(root.left) + countNodes(root.right);};</code></pre><h2 id="二叉树的锯齿形层序遍历【二叉树】"><a href="#二叉树的锯齿形层序遍历【二叉树】" class="headerlink" title="二叉树的锯齿形层序遍历【二叉树】"></a>二叉树的锯齿形层序遍历【二叉树】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103 二叉树的锯齿形层序遍历（中等）</a><sup>[31]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[][]} */let res;var zigzagLevelOrder = function (root) {    if (root == null) return [];    res = [];    BFS(root, true);    return res;};function BFS(root, inOrder) {    let arr = [];    let resItem = [];    let node;    let stack1 = new Stack();    let stack2 = new Stack();    // 判断交换时机    let flag;    stack1.push(root);    res.push([root.val]);    inOrder = !inOrder;    while (!stack1.isEmpty() || !stack2.isEmpty()) {        if (stack1.isEmpty()) {            flag = 'stack1';        } else if (stack2.isEmpty()) {            flag = 'stack2';        }        // 决定取那个栈里面的元素        if (flag === 'stack2' &amp;&amp; !stack1.isEmpty()) node = stack1.pop();        else if (flag === 'stack1' &amp;&amp; !stack2.isEmpty()) node = stack2.pop();        if (inOrder) {            if (node.left) {                if (flag === 'stack1') {                    stack1.push(node.left);                } else {                    stack2.push(node.left);                }                resItem.push(node.left.val);            }            if (node.right) {                if (flag === 'stack1') {                    stack1.push(node.right);                } else {                    stack2.push(node.right);                }                resItem.push(node.right.val);            }        } else {            if (node.right) {                if (flag === 'stack1') {                    stack1.push(node.right);                } else {                    stack2.push(node.right);                }                resItem.push(node.right.val);            }            if (node.left) {                if (flag === 'stack1') {                    stack1.push(node.left);                } else {                    stack2.push(node.left);                }                resItem.push(node.left.val);            }        }        // 判断下次翻转的时机        if ((flag === 'stack2' &amp;&amp; stack1.isEmpty()) || (flag === 'stack1' &amp;&amp; stack2.isEmpty())) {            inOrder = !inOrder;            // 需要翻转了，就加一轮值            if (resItem.length &gt; 0) {                res.push(resItem);            }            resItem = [];        }    }}class Stack {    constructor() {        this.count = 0;        this.items = [];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return undefined;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    size() {        return this.count;    }    isEmpty() {        return this.size() === 0;    }}</code></pre><h1 id="高频算法题系列：排序算法【🔥】"><a href="#高频算法题系列：排序算法【🔥】" class="headerlink" title="高频算法题系列：排序算法【🔥】"></a>高频算法题系列：排序算法【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>用最少数量的箭引爆气球【中等】【排序】</li><li>合并区间【中等】【排序算法+区间问题】【面试真题】</li></ul><h2 id="用最少数量的箭引爆气球【排序算法】"><a href="#用最少数量的箭引爆气球【排序算法】" class="headerlink" title="用最少数量的箭引爆气球【排序算法】"></a>用最少数量的箭引爆气球【排序算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452 用最少数量的箭引爆气球（中等）</a><sup>[32]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} points * @return {number} */var findMinArrowShots = function (points) {    if (points.length === 0) return 0;    points.sort((a, b) =&gt; a[1] - b[1]);    let cnt = 1;    let resArr = [points[0]];    let curr, last;    for (let i = 1; i &lt; points.length; i++) {        curr = points[i];        last = resArr[resArr.length - 1];        if (curr[0] &gt; last[1]) {            resArr.push(curr);            cnt++;        }    }    return cnt;};</code></pre><h2 id="合并区间【排序算法-区间问题】"><a href="#合并区间【排序算法-区间问题】" class="headerlink" title="合并区间【排序算法+区间问题】"></a>合并区间【排序算法+区间问题】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56 合并区间（中等）</a><sup>[33]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} intervals * @return {number[][]} */var merge = function (intervals) {    if (intervals.length === 0) return [];    intervals.sort((a, b) =&gt; a[0] - b[0]);    let mergeArr = [intervals[0]];    let last, curr;    for (let j = 1; j &lt; intervals.length; j++) {        last = mergeArr[mergeArr.length - 1];        curr = intervals[j];        if (last[1] &gt;= curr[0]) {            last[1] = Math.max(curr[1], last[1]);        } else {            mergeArr.push(curr);        }    }    return mergeArr;};</code></pre><h1 id="高频算法题系列：二分查找"><a href="#高频算法题系列：二分查找" class="headerlink" title="高频算法题系列：二分查找"></a>高频算法题系列：二分查找</h1><p>主要有以下几类高频考题：</p><ul><li>寻找两个正序数组的中位数【困难】【二分查找】</li><li>判断子序列【简单】【二分查找】</li><li>在排序数组中查找元素的第一个和最后一个位置【中等】【二分查找】</li></ul><h2 id="寻找两个正序数组的中位数【二分查找】"><a href="#寻找两个正序数组的中位数【二分查找】" class="headerlink" title="寻找两个正序数组的中位数【二分查找】"></a>寻找两个正序数组的中位数【二分查找】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4 寻找两个正序数组的中位数（困难）</a><sup>[34]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */var findMedianSortedArrays = function (nums1, nums2) {    let m = nums1.length, n = nums2.length;    let i = 0, j = 0;    let newArr = [];    while (i &lt; m &amp;&amp; j &lt; n) {        if (nums1[i] &lt; nums2[j]) {            newArr.push(nums1[i++]);        } else {            newArr.push(nums2[j++]);        }    }    newArr = newArr.concat(i &lt; m ? nums1.slice(i) : nums2.slice(j));    const len = newArr.length;    console.log(newArr)    if (len % 2 === 0) {        return (newArr[len / 2] + newArr[len / 2 - 1]) / 2;    } else {        return newArr[Math.floor(len / 2)];    }};</code></pre><h2 id="判断子序列【二分查找】"><a href="#判断子序列【二分查找】" class="headerlink" title="判断子序列【二分查找】"></a>判断子序列【二分查找】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392 判断子序列（简单）</a><sup>[35]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @param {string} t * @return {boolean} */var isSubsequence = function (s, t) {    let hash = {};    for (let i = 0; i &lt; t.length; i++) {        if (!hash[t[i]]) hash[t[i]] = [];        hash[t[i]].push(i);    }    let lastMaxIndex = 0;    for (let i = 0; i &lt; s.length; i++) {        if (hash[s[i]]) {            const index = binarySearch(hash[s[i]], lastMaxIndex);            console.log('index', index, hash[s[i]]);            if (index === -1) return false;            lastMaxIndex = hash[s[i]][index] + 1;        } else return false;    }    return true;};function binarySearch(array, targetIndex) {    let left = 0, right = array.length;    while (left &lt; right) {        let mid = left + Math.floor((right - left) / 2);        if (array[mid] &gt;= targetIndex) {            right = mid;        } else if (array[mid] &lt; targetIndex) {            left = mid + 1;        }    }    if (left &gt;= array.length || array[left] &lt; targetIndex) return -1;    return left;}</code></pre><h2 id="在排序数组中查找元素的第一个和最后一个位置【二分搜索】"><a href="#在排序数组中查找元素的第一个和最后一个位置【二分搜索】" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置【二分搜索】"></a>在排序数组中查找元素的第一个和最后一个位置【二分搜索】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34 在排序数组中查找元素的第一个和最后一个位置（中等）</a><sup>[36]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @param {number} target * @return {number[]} */var searchRange = function (nums, target) {    const left = leftBound(nums, target);    const right = rightBound(nums, target);    return [left, right];};function leftBound(nums, target) {    let left = 0;    let right = nums.length - 1;    while (left &lt;= right) {        let mid = Math.floor(left + (right - left) / 2);        if (nums[mid] === target) {            right = mid - 1;        } else if (nums[mid] &lt; target) {            left = mid + 1;        } else if (nums[mid] &gt; target) {            right = mid - 1;        }    }    if (left &gt;= nums.length || nums[left] !== target) {        return -1;    }    return left;}function rightBound(nums, target) {    let left = 0;    let right = nums.length - 1;    while (left &lt;= right) {        let mid = Math.floor(left + (right - left) / 2);        if (nums[mid] === target) {            left = mid + 1;        } else if (nums[mid] &lt; target) {            left = mid + 1;        } else if (nums[mid] &gt; target) {            right = mid - 1;        }    }    if (right &lt; 0 || nums[right] !== target) {        return -1;    }    return right;}</code></pre><h1 id="高频算法题系列：动态规划【🔥】"><a href="#高频算法题系列：动态规划【🔥】" class="headerlink" title="高频算法题系列：动态规划【🔥】"></a>高频算法题系列：动态规划【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>最长递增子序列【中等】【动态规划】</li><li>零钱兑换【中等】【动态规划】【面试真题】</li><li>最长公共子序列 【中等】【动态规划】【面试真题】</li><li>编辑距离 【困难】【动态规划】</li><li>最长回文子序列【中等】【动态规划】【面试真题】</li><li>最大子序和【简单】【动态规划】【面试真题】</li><li>买卖股票的最佳时机系列【系列】【动态规划】【面试真题】</li></ul><h2 id="最长递增子序列【动态规划】"><a href="#最长递增子序列【动态规划】" class="headerlink" title="最长递增子序列【动态规划】"></a>最长递增子序列【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300 最长递增子序列（中等）</a><sup>[37]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var lengthOfLIS = function (nums) {    let maxLen = 0, n = nums.length;    let dp = [];    for (let i = 0; i &lt; n; i++) {        dp[i] = 1;    }    for (let i = 0; i &lt; n; i++) {        for (let j = 0; j &lt; i; j++) {            if (nums[i] &gt; nums[j]) {                dp[i] = Math.max(dp[i], dp[j] + 1);            }        }        maxLen = Math.max(maxLen, dp[i]);    }    return maxLen;};</code></pre><h2 id="【面试真题】-零钱兑换【动态规划】"><a href="#【面试真题】-零钱兑换【动态规划】" class="headerlink" title="【面试真题】 零钱兑换【动态规划】"></a>【面试真题】 零钱兑换【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322 零钱兑换（中等）</a><sup>[38]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} coins * @param {number} amount * @return {number} */var coinChange = function (coins, amount) {    if (amount === 0) return 0;    let dp = [];    for (let i = 0; i &lt;= amount; i++) {        dp[i] = amount + 1;    }    dp[0] = 0;    for (let i = 0; i &lt;= amount; i++) {        for (let j = 0; j &lt; coins.length; j++) {            if (i &gt;= coins[j]) {                dp[i] = Math.min(dp[i - coins[j]] + 1, dp[i])            }        }    }    return dp[amount] === amount + 1 ? -1 : dp[amount];};</code></pre><h2 id="【面试真题】-最长公共子序列【动态规划】"><a href="#【面试真题】-最长公共子序列【动态规划】" class="headerlink" title="【面试真题】 最长公共子序列【动态规划】"></a>【面试真题】 最长公共子序列【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143 最长公共子序列（中等）</a><sup>[39]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} text1 * @param {string} text2 * @return {number} */var longestCommonSubsequence = function (text1, text2) {    let n1 = text1.length, n2 = text2.length;    let dp = [];    for (let i = -1; i &lt; n1; i++) {        dp[i] = [];        for (let j = -1; j &lt; n2; j++) {            dp[i][j] = 0;        }    }    for (let i = 0; i &lt; n1; i++) {        for (let j = 0; j &lt; n2; j++) {            if (text1[i] === text2[j]) {                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);            } else {                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])            }        }    }    return dp[n1 - 1][n2 - 1];};</code></pre><h2 id="编辑距离【动态规划】"><a href="#编辑距离【动态规划】" class="headerlink" title="编辑距离【动态规划】"></a>编辑距离【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72 编辑距离（困难）</a><sup>[40]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} word1 * @param {string} word2 * @return {number} */var minDistance = function (word1, word2) {    let len1 = word1.length, len2 = word2.length;    let dp = [];    for (let i = 0; i &lt;= len1; i++) {        dp[i] = [];        for (let j = 0; j &lt;= len2; j++) {            dp[i][j] = 0;            if (i === 0) {                dp[i][j] = j;            }            if (j === 0) {                dp[i][j] = i;            }        }    }    for (let i = 1; i &lt;= len1; i++) {        for (let j = 1; j &lt;= len2; j++) {            if (word1[i - 1] === word2[j - 1]) {                dp[i][j] = dp[i - 1][j - 1];            } else {                dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1);            }        }    }    return dp[len1][len2];};</code></pre><h2 id="【面试真题】最长回文子序列【动态规划】"><a href="#【面试真题】最长回文子序列【动态规划】" class="headerlink" title="【面试真题】最长回文子序列【动态规划】"></a>【面试真题】最长回文子序列【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516 最长回文子序列（中等）</a><sup>[41]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {number} */var longestPalindromeSubseq = function (s) {    let dp = [];    for (let i = 0; i &lt; s.length; i++) {        dp[i] = [];        for (let j = 0; j &lt; s.length; j++) {            dp[i][j] = 0;        }        dp[i][i] = 1;    }    for (let i = s.length - 1; i &gt;= 0; i--) {        for (let j = i + 1; j &lt; s.length; j++) {            if (s[i] === s[j]) {                dp[i][j] = dp[i + 1][j - 1] + 2;            } else {                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);            }        }    }    return dp[0][s.length - 1];};</code></pre><h2 id="【面试真题】最大子序和【动态规划】"><a href="#【面试真题】最大子序和【动态规划】" class="headerlink" title="【面试真题】最大子序和【动态规划】"></a>【面试真题】最大子序和【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53 最大子序和（简单）</a><sup>[42]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number} */var maxSubArray = function (nums) {    let maxSum = -Infinity;    let dp = [], n = nums.length;    for (let i = -1; i &lt; n; i++) {        dp[i] = 0;    }    for (let i = 0; i &lt; n; i++) {        dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);        maxSum = Math.max(maxSum, dp[i]);    }    return maxSum;};</code></pre><h2 id="【面试真题】买卖股票的最佳时机【动态规划】"><a href="#【面试真题】买卖股票的最佳时机【动态规划】" class="headerlink" title="【面试真题】买卖股票的最佳时机【动态规划】"></a>【面试真题】买卖股票的最佳时机【动态规划】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121 买卖股票的最佳时机（简单）</a><sup>[43]</sup>【面试真题】</p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122 买卖股票的最佳时机 II（简单）</a><sup>[44]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123 买卖股票的最佳时机 III（困难）</a><sup>[45]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188 买卖股票的最佳时机IV（困难）</a><sup>[46]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309 买卖股票的最佳时机含冷冻期（中等）</a><sup>[47]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714 买卖股票的最佳时机含手续费（中等）</a><sup>[48]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板，也是一面常考真题，笔者在面试字节跳动时就遇到过。</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} prices * @return {number} */var maxProfit = function (prices) {    let dp = [];    for (let i = -1; i &lt; prices.length; i++) {        dp[i] = []        for (let j = 0; j &lt;= 1; j++) {            dp[i][j] = [];            dp[i][j][0] = 0;            dp[i][j][1] = 0;            if (i === -1) {                dp[i][j][1] = -Infinity;            }            if (j === 0) {                dp[i][j][1] = -Infinity;            }            if (j === -1) {                dp[i][j][1] = -Infinity;            }        }    }    for (let i = 0; i &lt; prices.length; i++) {        for (let j = 1; j &lt;= 1; j++) {            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);        }    }    return dp[prices.length - 1][1][0];};</code></pre><h1 id="高频算法题系列：BFS"><a href="#高频算法题系列：BFS" class="headerlink" title="高频算法题系列：BFS"></a>高频算法题系列：BFS</h1><p>主要有以下几类高频考题：</p><ul><li>打开转盘锁【中等】【BFS】</li><li>二叉树的最小深度【简单】【BFS】</li></ul><h2 id="打开转盘锁【BFS】"><a href="#打开转盘锁【BFS】" class="headerlink" title="打开转盘锁【BFS】"></a>打开转盘锁【BFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">752 打开转盘锁（中等）</a><sup>[49]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string[]} deadends * @param {string} target * @return {number} */var openLock = function (deadends, target) {    let queue = new Queue();    let visited = new Set();    let step = 0;    queue.push('0000');    visited.add('0000');    while (!queue.isEmpty()) {        let size = queue.size();        for (let i = 0; i &lt; size; i++) {            let str = queue.pop();            if (deadends.includes(str)) continue;            if (target === str) {                return step;            }            for (let j = 0; j &lt; 4; j++) {                let plusStr = plusOne(str, j);                let minusStr = minusOne(str, j);                if (!visited.has(plusStr)) {                    queue.push(plusStr);                    visited.add(plusStr)                }                if (!visited.has(minusStr)) {                    queue.push(minusStr);                    visited.add(minusStr)                }            }        }        step++;    }    return -1;};function plusOne(str, index) {    let strArr = str.split('');    if (strArr[index] === '9') {        strArr[index] = '0'    } else {        strArr[index] = (Number(strArr[index]) + 1).toString()    }    return strArr.join('');}function minusOne(str, index) {    let strArr = str.split('');    if (strArr[index] === '0') {        strArr[index] = '9'    } else {        strArr[index] = (Number(strArr[index]) - 1).toString()    }    return strArr.join('');}class Queue {    constructor() {        this.items = [];        this.count = 0;        this.lowerCount = 0;    }    push(elem) {        this.items[this.count++] = elem;    }    pop() {        if (this.isEmpty()) {            return;        }        const elem = this.items[this.lowerCount];        delete this.items[this.lowerCount];        this.lowerCount++;        return elem;    }    isEmpty() {        if (this.size() === 0) return true;        return false;    }    size() {        return this.count - this.lowerCount;    }}</code></pre><h2 id="二叉树的最小深度【BFS】"><a href="#二叉树的最小深度【BFS】" class="headerlink" title="二叉树的最小深度【BFS】"></a>二叉树的最小深度【BFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111 二叉树的最小深度（简单）</a><sup>[50]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */var minDepth = function (root) {    if (root == null) return 0;    let depth = 1;    let queue = new Queue();    queue.push(root);    while (!queue.isEmpty()) {        let size = queue.size();        for (let i = 0; i &lt; size; i++) {            const node = queue.pop();            if (node.left == null &amp;&amp; node.right == null) return depth;            if (node.left) {                queue.push(node.left);            }            if (node.right) {                queue.push(node.right);            }        }        depth++;    }    return depth;};class Queue {    constructor() {        this.items = [];        this.count = 0;        this.lowerCount = 0;    }    push(elem) {        this.items[this.count++] = elem;    }    pop() {        if (this.isEmpty()) {            return;        }        const elem = this.items[this.lowerCount];        delete this.items[this.lowerCount];        this.lowerCount++;        return elem;    }    isEmpty() {        if (this.size() === 0) return true;        return false;    }    size() {        return this.count - this.lowerCount;    }}</code></pre><h1 id="高频算法题系列：栈【🔥】"><a href="#高频算法题系列：栈【🔥】" class="headerlink" title="高频算法题系列：栈【🔥】"></a>高频算法题系列：栈【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>最小栈【简单】【栈】</li><li>有效的括号【中等】【栈】【面试真题】</li><li>简化路径【中等】【栈】</li><li>下一个更大元素 【系列】【栈】</li></ul><h2 id="最小栈【栈】"><a href="#最小栈【栈】" class="headerlink" title="最小栈【栈】"></a>最小栈【栈】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/min-stack/submissions/" target="_blank" rel="noopener">155 最小栈（简单）</a><sup>[51]</sup></p><p>题解</p><pre><code class="javascript">/** * initialize your data structure here. */var MinStack = function () {    this.stack = [];    this.minArr = [];    this.count = 0;    this.min = Number.MAX_SAFE_INTEGER;};/** * @param {number} x * @return {void} */MinStack.prototype.push = function (x) {    this.min = Math.min(this.min, x);    this.minArr[this.count] = this.min;    this.stack[this.count] = x;    this.count++;};/** * @return {void} */MinStack.prototype.pop = function () {    const element = this.stack[this.count - 1];    if (this.count - 2 &gt;= 0) this.min = this.minArr[this.count - 2];    else this.min = Number.MAX_SAFE_INTEGER;    delete this.stack[this.count - 1];    delete this.minArr[this.count - 1];    this.count--;    return element;};/** * @return {number} */MinStack.prototype.top = function () {    if (this.count &gt;= 1) {        return this.stack[this.count - 1];    }    return null;};/** * @return {number} */MinStack.prototype.getMin = function () {    const element = this.minArr[this.count - 1];    return element;};/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */</code></pre><h2 id="【系列】下一个更大元素-【栈】"><a href="#【系列】下一个更大元素-【栈】" class="headerlink" title="【系列】下一个更大元素 【栈】"></a>【系列】下一个更大元素 【栈】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496 下一个更大元素 I（简单）</a><sup>[52]</sup></p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503 下一个更大元素 II（中等）</a><sup>[53]</sup></p><p>受限于篇幅，这里只给出第一道题的代码模板</p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number[]} */var nextGreaterElements = function (nums) {    let ans = [];    let stack = new Stack();    const n = nums.length;    for (let i = 2 * n - 1; i &gt;= 0; i--) {        while (!stack.isEmpty() &amp;&amp; stack.top() &lt;= nums[i % n]) {            stack.pop();        }        ans[i % n] = stack.isEmpty() ? -1 : stack.top();        stack.push(nums[i % n]);    }    return ans;};class Stack {    constructor() {        this.count = 0;        this.items = [];    }    top() {        if (this.isEmpty()) return undefined;        return this.items[this.count - 1];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return undefined;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    isEmpty() {        return this.size() === 0;    }    size() {        return this.count;    }}</code></pre><p>##【面试真题】有效的括号【栈】</p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20 有效的括号（中等）</a><sup>[54]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {boolean} */var isValid = function (s) {          if (s.length === 0) {            return true;          }          if (s.length % 2 !== 0) {            return false;          }          let map = {            ')': '(',            ']': '[',            '}': '{',          };          let left = ['(', '[', '{'];          let right = [')', ']', '}'];          let stack = new Stack();          for (let i = 0; i &lt; s.length; i++) {            if (!right.includes(s[i])) {              stack.push(s[i]);            } else {              const matchStr = map[s[i]];              while (!stack.isEmpty()) {                const element = stack.pop();                if (left.includes(element) &amp;&amp; matchStr !== element) return false;                if (element === matchStr) break;              }            }          }          return stack.isEmpty();        };class Stack {  constructor() {    this.count = 0;    this.items = [];  }  push(element) {    this.items[this.count] = element;    this.count++;  }  pop() {    if (this.isEmpty()) return undefined;    const element = this.items[this.count - 1];    delete this.items[this.count - 1];    this.count--;    return element;  }  isEmpty() {    return this.size() === 0;  }  size() {    return this.count;  }}</code></pre><h2 id="简化路径【栈】"><a href="#简化路径【栈】" class="headerlink" title="简化路径【栈】"></a>简化路径【栈】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71 简化路径（中等）</a><sup>[55]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} path * @return {string} */var simplifyPath = function (path) {    let newPath = path.split('/');    newPath = newPath.filter(item =&gt; item !== "");    const stack = new Stack();    for (let s of newPath) {        if (s === '..') stack.pop();        else if (s !== '.') stack.push(s);    }    if (stack.isEmpty()) return '/';    let str = '';    while (!stack.isEmpty()) {        const element = stack.pop();        str = '/' + element + str;    }    return str;};function handleBack(stack, tag, num) {    if (!stack.isEmpty()) return num;    const element = stack.pop();    if (element === '..') return handleBack(stack, tag, num + 1);    else {        stack.push(element);        return num;    }}class Stack {    constructor() {        this.count = 0;        this.items = [];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return undefined;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    size() {        return this.count;    }    isEmpty() {        return this.size() === 0;    }}</code></pre><h1 id="高频算法题系列：DFS【🔥】"><a href="#高频算法题系列：DFS【🔥】" class="headerlink" title="高频算法题系列：DFS【🔥】"></a>高频算法题系列：DFS【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>岛屿的最大面积【中等】【DFS】</li><li>相同的树【简单】【DFS】</li></ul><h2 id="岛屿的最大面积【DFS】"><a href="#岛屿的最大面积【DFS】" class="headerlink" title="岛屿的最大面积【DFS】"></a>岛屿的最大面积【DFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">695 岛屿的最大面积（中等）</a><sup>[56]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[][]} grid * @return {number} */let maxX, maxY;let visited;let globalMaxArea;var maxAreaOfIsland = function (grid) {    visited = new Set();    maxX = grid.length;    maxY = grid[0].length;    globalMaxArea = 0;    for (let i = 0; i &lt; maxX; i++) {        for (let j = 0; j &lt; maxY; j++) {            if (grid[i][j] === 1) {                visited.add(`(${i}, ${j})`);                globalMaxArea = Math.max(globalMaxArea, dfs(grid, i, j));            }            visited.clear();        }    }    return globalMaxArea;};function dfs(grid, x, y) {    let res = 1;    for (let i = -1; i &lt;= 1; i++) {        for (let j = -1; j &lt;= 1; j++) {            if (Math.abs(i) === Math.abs(j)) continue;            const newX = x + i;            const newY = y + j;            if (newX &gt;= maxX || newX &lt; 0 || newY &gt;= maxY || newY &lt; 0) continue;            if (visited.has(`(${newX}, ${newY})`)) continue;            visited.add(`(${newX}, ${newY})`);            const areaCnt = grid[newX][newY]            if (areaCnt === 1) {                const cnt = dfs(grid, newX, newY);                res += cnt;            }        }    }    return res;}</code></pre><h2 id="相同的树【DFS】"><a href="#相同的树【DFS】" class="headerlink" title="相同的树【DFS】"></a>相同的树【DFS】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100 相同的树（简单）</a><sup>[57]</sup></p><p>题解</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */var isSameTree = function (p, q) {    if (p == null &amp;&amp; q == null) return true;    if (p == null || q == null) return false;    if (p.val !== q.val) return false;    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);};</code></pre><h1 id="高频算法题系列：回溯算法【🔥】"><a href="#高频算法题系列：回溯算法【🔥】" class="headerlink" title="高频算法题系列：回溯算法【🔥】"></a>高频算法题系列：回溯算法【🔥】</h1><p>主要有以下几类高频考题：</p><ul><li>N皇后【困难】【回溯算法】【面试真题】</li><li>全排列【中等】【回溯算法】</li><li>括号生成【中等】【回溯算法】</li><li>复原 IP 地址【中等】【回溯算法】</li><li>子集 【简单】【回溯算法】</li></ul><h2 id="【面试真题】N皇后【回溯算法】"><a href="#【面试真题】N皇后【回溯算法】" class="headerlink" title="【面试真题】N皇后【回溯算法】"></a>【面试真题】N皇后【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51 N皇后（困难）</a><sup>[58]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number} n * @return {string[][]} */let result = [];var solveNQueens = function (n) {    result = [];    let board = [];    for (let i = 0; i &lt; n; i++) {        board[i] = [];        for (let j = 0; j &lt; n; j++) {            board[i][j] = '.'        }    }    backtrack(0, board, n);    return result;};function deepClone(board) {    let res = [];    for (let i = 0; i &lt; board.length; i++) {        res.push(board[i].join(''));    }    return res;}function backtrack(row, board, n) {    if (row === n) {        result.push(deepClone(board));        return;    }    for (let j = 0; j &lt; n; j++) {        if (checkInValid(board, row, j, n)) continue;        board[row][j] = 'Q';        backtrack(row + 1, board, n);        board[row][j] = '.';    }}function checkInValid(board, row, column, n) {    // 行    for (let i = 0; i &lt; n; i++) {        if (board[i][column] === 'Q') return true;    }    for (let i = row - 1, j = column + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {        if (board[i][j] === 'Q') return true;    }    for (let i = row - 1, j = column - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {        if (board[i][j] === 'Q') return true;    }    return false;}</code></pre><h2 id="全排列【回溯算法】"><a href="#全排列【回溯算法】" class="headerlink" title="全排列【回溯算法】"></a>全排列【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46 全排列（中等）</a><sup>[59]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number[][]} */let results = [];var permute = function (nums) {    results = [];    backtrack(nums, []);    return results;};function backtrack(nums, track) {    if (nums.length === track.length) {        results.push(track.slice());        return;    }    for (let i = 0; i &lt; nums.length; i++) {        if (track.includes(nums[i])) continue;        track.push(nums[i]);        backtrack(nums, track);        track.pop();    }}</code></pre><h2 id="括号生成【回溯算法】"><a href="#括号生成【回溯算法】" class="headerlink" title="括号生成【回溯算法】"></a>括号生成【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22 括号生成（中等）</a><sup>[60]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number} n * @return {string[]} */var generateParenthesis = function (n) {    let validRes = [];    backtrack(n * 2, validRes, '');    return validRes;};function backtrack(len, validRes, bracket) {    if (bracket.length === len) {        if (isValidCombination(bracket)) {            validRes.push(bracket);        }        return;    }    for (let str of ['(', ')']) {        bracket += str;        backtrack(len, validRes, bracket);        bracket = bracket.slice(0, bracket.length - 1);    }}function isValidCombination(bracket) {    let stack = new Stack();    for (let i = 0; i &lt; bracket.length; i++) {        const str = bracket[i];        if (str === '(') {            stack.push(str);        } else if (str === ')') {            const top = stack.pop();            if (top !== '(') return false;        }    }    return stack.isEmpty();}class Stack {    constructor() {        this.count = 0;        this.items = [];    }    push(element) {        this.items[this.count] = element;        this.count++;    }    pop() {        if (this.isEmpty()) return;        const element = this.items[this.count - 1];        delete this.items[this.count - 1];        this.count--;        return element;    }    size() {        return this.count;    }    isEmpty() {        return this.size() === 0;    }}</code></pre><h2 id="复原-IP-地址【回溯算法】"><a href="#复原-IP-地址【回溯算法】" class="headerlink" title="复原 IP 地址【回溯算法】"></a>复原 IP 地址【回溯算法】</h2><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93 复原 IP 地址（中等）</a><sup>[61]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {string} s * @return {string[]} */var restoreIpAddresses = function (s) {    if (s.length &gt; 12) return [];    let res = [];    const track = [];    backtrack(s, track, res);    return res;};function backtrack(s, track, res) {    if (track.length === 4 &amp;&amp; s.length === 0) {        res.push(track.join('.'));        return;    }    let len = s.length &gt;= 3 ? 3 : s.length;    for (let i = 0; i &lt; len; i++) {        const c = s.slice(0, i + 1);        if (parseInt(c) &gt; 255) continue;        if (i &gt;= 1 &amp;&amp; parseInt(c) &lt; parseInt((1 + '0'.repeat(i)))) continue;        track.push(c);        backtrack(s.slice(i + 1), track, res);        track.pop();    }}</code></pre><p>##　子集【回溯算法】</p><p>👉 【LeetCode 直通车】：<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78 子集（中等）</a><sup>[62]</sup></p><p>题解</p><pre><code class="javascript">/** * @param {number[]} nums * @return {number[][]} */var subsets = function (nums) {    if (nums.length === 0) return [[]];    let resArr = [];    backtrack(nums, 0, [], resArr);    return resArr;};function backtrack(nums, index, subArr, resArr) {    if (Array.isArray(subArr)) {        resArr.push(subArr.slice());    }    if (index === nums.length) {        return;    }    for (let i = index; i &lt; nums.length; i++) {        subArr.push(nums[i]);        backtrack(nums, i + 1, subArr, resArr);        subArr.pop(nums[i]);    }}</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<br>【LeetCode 直通车】：234 回文链表（简单）: <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p><p>[2]<br>【LeetCode 直通车】：206 反转链表（简单）: <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>[3]<br>【LeetCode 直通车】：23 合并K个升序链表（困难）: <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p><p>[4]<br>【LeetCode 直通车】：25 K 个一组翻转链表（困难）: <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p><p>[5]<br>【LeetCode 直通车】：141 环形链表（简单）: <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p>[6]<br>【LeetCode 直通车】：148 排序链表（中等）: <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/</a></p><p>[7]<br>【LeetCode 直通车】：160 相交链表（简单）: <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><p>[8]<br>【LeetCode 直通车】：5 最长回文子串（中等）: <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>[9]<br>【LeetCode 直通车】：14 最长公共前缀（简单）: <a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p><p>[10]<br>【LeetCode 直通车】：3 无重复字符的最长子串（中等）: <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>[11]<br>【LeetCode 直通车】：76 最小覆盖子串（困难）: <a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-window-substring/</a></p><p>[12]<br>【LeetCode 直通车】：354 俄罗斯套娃信封问题（困难）: <a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/russian-doll-envelopes/</a></p><p>[13]<br>【LeetCode 直通车】：674 最长连续递增序列（简单）: <a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/</a></p><p>[14]<br>【LeetCode 直通车】：128 最长连续序列（困难）: <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence/</a></p><p>[15]<br>【LeetCode 直通车】：11 盛最多水的容器（中等）: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>[16]<br>【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）: <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><p>[17]<br>【LeetCode 直通车】：26 删除有序数组中的重复项（简单）: <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><p>[18]<br>【LeetCode 直通车】：695 岛屿的最大面积（中等）: <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island/</a></p><p>[19]<br>【LeetCode 直通车】：560 和为K的子数组（中等）: <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p><p>[20]<br>【LeetCode 直通车】：1 两数之和（简单）: <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p><p>[21]<br>【LeetCode 直通车】：167 两数之和 II - 输入有序数组（简单）: <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p><p>[22]<br>【LeetCode 直通车】：15 三数之和（中等）: <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p><p>[23]<br>【LeetCode 直通车】：18 四数之和（中等）: <a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum/</a></p><p>[24]<br>【LeetCode 直通车】：42 接雨水（困难）: <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water/</a></p><p>[25]<br>【LeetCode 直通车】：55 跳跃游戏（中等）: <a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game/</a></p><p>[26]<br>【LeetCode 直通车】：45 跳跃游戏 II（中等）: <a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game-ii/</a></p><p>[27]<br>【LeetCode 直通车】：236 二叉树的最近公共祖先（简单）: <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><p>[28]<br>【LeetCode 直通车】：700 二叉搜索树中的搜索（简单）: <a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/</a></p><p>[29]<br>【LeetCode 直通车】：450 删除二叉搜索树中的节点（中等）: <a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-bst/</a></p><p>[30]<br>【LeetCode 直通车】：222 完全二叉树的节点个数（中等）: <a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></p><p>[31]<br>【LeetCode 直通车】：103 二叉树的锯齿形层序遍历（中等）: <a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/</a></p><p>[32]<br>【LeetCode 直通车】：452 用最少数量的箭引爆气球（中等）: <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><p>[33]<br>【LeetCode 直通车】：56 合并区间（中等）: <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-intervals/</a></p><p>[34]<br>【LeetCode 直通车】：4 寻找两个正序数组的中位数（困难）: <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p><p>[35]<br>【LeetCode 直通车】：392 判断子序列（简单）: <a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/is-subsequence/</a></p><p>[36]<br>【LeetCode 直通车】：34 在排序数组中查找元素的第一个和最后一个位置（中等）: <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><p>[37]<br>【LeetCode 直通车】：300 最长递增子序列（中等）: <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><p>[38]<br>【LeetCode 直通车】：322 零钱兑换（中等）: <a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p><p>[39]<br>【LeetCode 直通车】：1143 最长公共子序列（中等）: <a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p><p>[40]<br>【LeetCode 直通车】：72 编辑距离（困难）: <a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/</a></p><p>[41]<br>【LeetCode 直通车】：516 最长回文子序列（中等）: <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-subsequence/</a></p><p>[42]<br>【LeetCode 直通车】：53 最大子序和（简单）: <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p>[43]<br>【LeetCode 直通车】：121 买卖股票的最佳时机（简单）: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>[44]<br>【LeetCode 直通车】：122 买卖股票的最佳时机 II（简单）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>[45]<br>【LeetCode 直通车】：123 买卖股票的最佳时机 III（困难）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>[46]<br>【LeetCode 直通车】：188 买卖股票的最佳时机IV（困难）: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>[47]<br>【LeetCode 直通车】：309 买卖股票的最佳时机含冷冻期（中等）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p>[48]<br>【LeetCode 直通车】：714 买卖股票的最佳时机含手续费（中等）: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><p>[49]<br>【LeetCode 直通车】：752 打开转盘锁（中等）: <a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/open-the-lock/</a></p><p>[50]<br>【LeetCode 直通车】：111 二叉树的最小深度（简单）: <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><p>[51]<br>【LeetCode 直通车】：155 最小栈（简单）: <a href="https://leetcode-cn.com/problems/min-stack/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack/submissions/</a></p><p>[52]<br>【LeetCode 直通车】：496 下一个更大元素 I（简单）: <a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-i/</a></p><p>[53]<br>【LeetCode 直通车】：503 下一个更大元素 II（中等）: <a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-ii/</a></p><p>[54]<br>【LeetCode 直通车】：20 有效的括号（中等）: <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a></p><p>[55]<br>【LeetCode 直通车】：71 简化路径（中等）: <a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/simplify-path/</a></p><p>[56]<br>【LeetCode 直通车】：695 岛屿的最大面积（中等）: <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island/</a></p><p>[57]<br>【LeetCode 直通车】：100 相同的树（简单）: <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p><p>[58]<br>【LeetCode 直通车】：51 N皇后（困难）: <a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p><p>[59]<br>【LeetCode 直通车】：46 全排列（中等）: <a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p><p>[60]<br>【LeetCode 直通车】：22 括号生成（中等）: <a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/</a></p><p>[61]<br>【LeetCode 直通车】：93 复原 IP 地址（中等）: <a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/restore-ip-addresses/</a></p><p>[62]<br>【LeetCode 直通车】：78 子集（中等）: <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p>]]></content>
    
    
    <summary type="html">现在大厂面试中，算法题几乎为必考项，且近几年频现 LeetCode 真题，此篇为拿到字节、腾讯、京东 Offer 的笔者本人在准备面试过程中亲自刷过以及遇到过高频算法题。文章内容会分模块整理，对于笔者在面试过程中遇到的真题，会给予着重 【🔥】标出。</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>202104赛季晋级赛第一关-答案</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Trace-Battle-For-Promotion-202104-1-Ans/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Trace-Battle-For-Promotion-202104-1-Ans/</id>
    <published>2021-05-01T12:00:00.000Z</published>
    <updated>2021-05-02T09:44:03.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>中国香港港铁东铁线</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>网络迷踪由于线索取景真实，所以解题思路并不唯一，但答案唯一。本题解析仅为其中一种方法。</p><p>本关的歧义主要在于轨道交通系统名称，港铁是由九广铁路与香港地铁合并而成，随后注册名称叫做港铁。示例中的澳门轻轨是一个意思。</p><div class="text-center"><img src="/assets/images/crimaster/2021/05/20210501-ans-1.png" alt="港铁" class="post-image inline" style="width:30%"><img src="/assets/images/crimaster/2021/05/20210501-ans-2.png" alt="澳门轻轨" class="post-image inline" style="width:30%"></div><p>单看视频可能没有什么特定的头绪。不妨筛选出有用的线索。</p><p>仔细聆听声音，可以在视频末端聆听到一则语音播报:</p><video controls="" class="post-video half"><source src="/assets/videos/crimaster/2021/05/20210501-1.mp4" type="video/mp4"></video><p>利用音频翻译搜寻可以得出，此为广东话:下一站。车行走缓慢均匀且在路轨上行驶，说明即将抵达站台，由此可以大致确定为使用广东话为播报的某地铁内所拍摄。</p><p>语音播报为广东话，而使用广东话为语音播报的城市有:中国广东省，中国香港，中国澳门。</p><p>中国广东省车内语音播报提示顺序为先普通话后广东话(语)，视频中先是粵语，所以排除中国广东省</p><p>中国澳门轻铁以及中国香港港铁均是使用广东话(粵语)为主语的城市，列车语言播报顺序为:先粤语，后普通话，再英语。</p><p>我们需要进行进一步排除，当进行谷歌搜索了解港铁与澳门轻铁车语音播报内容时发现:中国香港的港铁播报方式为:“下一站x”，而中国澳门的轻铁播报方式为:“即将到达x”。视频内播报为:“下一站”，由此我们仅从视频中的一句播报，便可锁定该列车为中国香港港</p><p>铁: HK MTR</p><p>根据视频里的风景可以推断出这是在地上的线路。利用谷歌实景地图翻阅香港各大站可以筛选出地上站台有:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-3.png" alt="" class="post-image"><p>线路站点</p><table><thead><tr><th>线路</th><th>站点</th></tr></thead><tbody><tr><td>东铁线</td><td>全线</td></tr><tr><td>西铁线</td><td>屯门、兆康、天水围、郎屏、元朗、锦上路</td></tr><tr><td>观塘线</td><td>彩虹、九龙湾、牛头角、观塘、蓝田</td></tr><tr><td>荃湾线</td><td>荃湾、葵兴、葵芳、荔景</td></tr><tr><td>迪士尼线</td><td>欣澳、迪士尼</td></tr><tr><td>东涌线</td><td>荔景、欣澳、东涌</td></tr><tr><td>机场快线</td><td>荔景、机场、欣澳</td></tr><tr><td>南港岛线</td><td>海洋公园、黄竹坑、利东、海怡丰岛</td></tr><tr><td>马鞍山线</td><td>全线</td></tr></tbody></table><p>符合条件的站台太多，这样一一排査太费时间，我们需要再缩小范围。</p><p>从视频里我们可以发现这样一景</p><img src="/assets/images/crimaster/2021/05/20210501-ans-4.png" alt="" class="post-image"><p>一排排房子。我们可以借此确定列车方位。香港位于中国，太阳日出东方，日落西方，视频中右侧可看到房屋的阳光照射角度，用太阳方位推断列车自西向东行驶。</p><p>香港是沿海城市，视频里的走向没有经过海，且一般铁路设计不会靠着海行驶，中间会隔着马路。所以可以确定这段路程非沿海所行。结合以上两点，我们可以排除许多车站，只剩下:</p><div class="text-center"><img src="/assets/images/crimaster/2021/05/20210501-ans-5.png" alt="" style="height: 55px" class="post-image inline"><img src="/assets/images/crimaster/2021/05/20210501-ans-6.png" alt="" style="height: 55px" class="post-image inline"><img src="/assets/images/crimaster/2021/05/20210501-ans-7.png" alt="" style="height: 55px" class="post-image inline"></div><p>这里再次涉及到香港车内播报的一个习俗:除两头终点站外，车内语音播报会在快到下一站时才会播报。而观塘线的彩虹站至九龙湾站以及南港岛线的黄竹坑至海洋公园站快到站台都已经分别为北南走向及南北走向。所以排除。因此也可以排除东铁线的罗湖/落马洲站至上水站以及大学至火炭站。</p><p>推理至此，符合条件的仅剩下东铁线，此时答案已经明确，当然如果我们足够耐心，甚至可以进一步推测出该列车下一站的站点。</p><p>至此，为推测列车下一站站点，我们可以锁定到:上水至粉岭站，粉岭至太和站，太和至大埔墟站，大埔墟至大学站这些路线进行排查。</p><p>路程较远我们依旧无法很好的锁定。视频里又可以为我们提供信息。视频先后为我们提供了:</p><p>公交车:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-8.png" alt="" class="post-image half"><p>高速公路:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-9.png" alt="" class="post-image half"><p>高压线缆:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-10.png" alt="" class="post-image half"><p>房屋:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-11.png" alt="" class="post-image half"><p>小马路:</p><img src="/assets/images/crimaster/2021/05/20210501-ans-12.png" alt="" class="post-image half"><p>由此可以推断后来的房屋与铁路成直线。高压线缆，与铁路交汇。高速公路可能开始呈一直线，后来分岔。以及沿途涉及公交路线。这给我们进行实景搜索提供很多信息。</p><p>只要足够耐心，最后经过谷歌地球实景，我们可以在通往大埔墟的线段里发现这一风景。</p><p>本次网络迷踪的挑战可以让我们知道，一句简单的语音播报也能蕴含许多信息，类似于此类信息的还有车牌号，电话号等具有区域性及规律性的讯息，这些都是让我们突破惯性思维，得到真相的关键。通过一句语音播报，一段风景视频，利用互联网各类工具及知识，便可查找出视频拍摄者的具体位置，即便在这过程中些许枯燥，但每一次新的突破口涌入脑中，都会是一次思维风暴，这便是网络迷踪中逻辑及推理的魅力!</p>]]></content>
    
    
    <summary type="html">202104赛季晋级赛第一关答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="网络迷踪" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/"/>
    
    
    <category term="网络迷踪-解答" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>202104赛季晋级赛第一关</title>
    <link href="http://yoursite.com/2021/05/Crimaster-Trace-Battle-For-Promotion-202104-1/"/>
    <id>http://yoursite.com/2021/05/Crimaster-Trace-Battle-For-Promotion-202104-1/</id>
    <published>2021-05-01T00:00:00.000Z</published>
    <updated>2021-05-02T09:44:03.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这是一段于北京时间2021年4月11日15:28分在 Instagram上传的视频，视频发布者声明这是一段在列车上拍摄的视频，而此次你需要挑战的是，如何在这一段视频，推理出视频发布者乘坐的列车是什么城市的哪条线路?</p><video controls="" class="post-video half"><source src="/assets/videos/crimaster/2021/05/20210501-1.mp4" type="video/mp4"></video><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入视频中所在地点及搭载的轨道交通系统名称和线路</p>]]></content>
    
    
    <summary type="html">这是一段于北京时间2021年4月11日15:28分在 Instagram上传的视频，视频发布者声明这是一段在列车上拍摄的视频，而此次你需要挑战的是，如何在这一段视频，推理出视频发布者乘坐的列车是什么城市的哪条线路?</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="网络迷踪" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/"/>
    
    
    <category term="网络迷踪" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%BF%B7%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>意外之谜-答案</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Delegate-Unexpected-Mystery-Ans/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Delegate-Unexpected-Mystery-Ans/</id>
    <published>2021-04-28T12:00:00.000Z</published>
    <updated>2021-05-02T09:31:57.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>SHELF</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>观察发现是上下左右的字符，在一张表格里，从任意初始位置开始，按着题目上的箭头每次走一格，如果是黑色的方向那就给这个格子涂黑绿色就涂绿，最后会发现绿色格子象形得到答案。</p><img src="/assets/images/crimaster/2021/04/20210428-ans-1.png" alt="" class="post-image">]]></content>
    
    
    <summary type="html">20210428期侦探委托《意外之谜》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托-解答" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>意外之谜</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Delegate-Unexpected-Mystery/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Delegate-Unexpected-Mystery/</id>
    <published>2021-04-28T00:00:00.000Z</published>
    <updated>2021-05-02T09:29:38.132Z</updated>
    
    <content type="html"><![CDATA[<p><font style="color:#D9730D">今天是CRIMASTER四月赛季最后一天了，这也是晋级赛前最后一道题，晚间将暂时关闭竞技赛场，等待5.1巅峰对决晋级赛的开启!希望大家都会取得一个好成绩，今天可以陆续更新版本啦，各应用商店更新审核时间不同，请耐心等待!加油!</font></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>我叫柳菲，是一名古玩字画收藏家。</p><p>就在刚才，我收到了朋友发的消息:“菲姐菲姐!快点来卧龙观邸一趟，听说有关于《骷髅幻戏图》的消息。</p><p>”我对这幅画很感兴趣，于是立即驱车到达。只是…这守门大爷给我这张纸是为何?看画还要解谜题?</p><img src="/assets/images/crimaster/2021/04/20210428-1.png" alt="" class="post-image"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>图片代表的意思 英文单词</p>]]></content>
    
    
    <summary type="html">我叫柳菲，是一名古玩字画收藏家。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来到我的世界-答案</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Decipher-Welcome-To-My-World-Ans/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Decipher-Welcome-To-My-World-Ans/</id>
    <published>2021-04-25T12:00:00.000Z</published>
    <updated>2021-05-02T09:57:29.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>金沙县</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我们像那跨越七海的风一般，在碧蓝的未来描绘我们的梦想，穿越了无数片海域和星河。到人生的每个阶段蓦然回首，还能是否想起那年少时的热枕。我偶尔还能想起，山脉间那跨越七海的风，少年在地图上勾画的那个午后。</p><p>我国领土的四端为:<br>最东端在黑龙江和乌苏里江的主航道中心线的相交处(135°2’30”E);<br>最西端在帕米尔高原附近(73°29’59.79”E);<br>最南端在立地暗沙(3°31’00”N，东经112°17’09” E)，为中国南海南沙群岛区域的一座暗沙，是实际上的中国领土的最南端;<br>最北端在漠河以北黑龙江主航道的中心线上(53°33’N，124°20’E)  </p><p>1、我们按照拼图形式得到:</p><img src="/assets/images/crimaster/2021/04/20210425-ans-1.png" alt="图片" class="post-image half"><p>2、根据符号X的位置带入图片得到数据表格</p><img src="/assets/images/crimaster/2021/04/20210425-ans-2.png" alt="图片" class="post-image half"><p>我国古代纪年法的其中一种为干支纪年法，近世也常用干支纪年表示重要历史事件，如:“戊戌变法”“辛亥革命”等。</p><p>按照提示得到年份的天干地支以及顺序:</p><p>圆圈：</p><p>1804(甲子年)</p><p>X</p><p>1829(己丑年)</p><p>1855(乙卯年)</p><p>1905(乙巳年)</p><p>X</p><p>1937(丁丑年)</p><p>2037(丁巳年)</p><p>方块:</p><p>1841(辛丑年)</p><p>1894(甲午年)</p><p>1939(己卯年)</p><p>1940(庚辰年)</p><p>1965(乙已年)</p><p>2004(甲申年)</p><p>由“天圆地方”的提示将圆圈所对应的天干提取方块对应的地支提取得到：</p><p>圆圈：甲X己乙乙X丁丁</p><p>方块:丑午卯辰已申</p><p>提示X=0，得到数字</p><p>方块 274569</p><p>圆圈 10622044</p><p>1、地点在中国，根据中国经纬度范围划分数字得到：</p><p>27.4569 N</p><p>106.22044 E</p><p>2、打开地图，输入坐标，得到答案金沙县。</p><img src="/assets/images/crimaster/2021/04/20210425-ans-3.png" alt="图片" class="post-image half no-limit-height"><img src="/assets/images/crimaster/2021/04/20210425-ans-4.png" alt="图片" class="post-image">]]></content>
    
    
    <summary type="html">20210425期极速破译《欢迎来到我的世界》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="极速破译" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E6%9E%81%E9%80%9F%E7%A0%B4%E8%AF%91/"/>
    
    
    <category term="极速破译-解答" scheme="http://yoursite.com/tags/%E6%9E%81%E9%80%9F%E7%A0%B4%E8%AF%91-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来到我的世界</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Decipher-Welcome-To-My-World/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Decipher-Welcome-To-My-World/</id>
    <published>2021-04-25T00:00:00.000Z</published>
    <updated>2021-05-02T09:51:46.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>“亲爱的侦探，人们常说，对着大山呐喊，大山对面的人就会听到你的声音，可是当你真正呐喊后畅快过后，仿佛更加深了一种失意，再美好的风景都不如回家的路。偶尔听听耳边的风，跨越了祖国的大江南北，渡过了多少江河，将故乡的气息传递到这。这是我生长的地方，欢迎来到我的世界。”</p><img src="/assets/images/crimaster/2021/04/20210425-1.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/04/20210425-2.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/04/20210425-3.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/04/20210425-4.png" alt="图片" class="post-image half"><img src="/assets/images/crimaster/2021/04/20210425-5.png" alt="图片" class="post-image half"><p><font color="#e03e3e">提示1:X=0<br>提示2:以古人纪年之法寻由古至今、天圆地方之数</font></p><p>拼合图片对应表格找寻线索，遵循本初子午线的规则对应我国经纬度范围内寻找一处确切的地点，即为答案。聪明的侦探，请解开谜题填入相应的一处地名。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>请输入一处地点名称 <font color="#e03e3e">例如:凤凰县</font></p>]]></content>
    
    
    <summary type="html">亲爱的侦探，人们常说，对着大山呐喊，大山对面的人就会听到你的声音，可是当你真正呐喊后畅快过后，仿佛更加深了一种失意，再美好的风景都不如回家的路。偶尔听听耳边的风，跨越了祖国的大江南北，渡过了多少江河，将故乡的气息传递到这。这是我生长的地方，欢迎来到我的世界。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="极速破译" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E6%9E%81%E9%80%9F%E7%A0%B4%E8%AF%91/"/>
    
    
    <category term="极速破译" scheme="http://yoursite.com/tags/%E6%9E%81%E9%80%9F%E7%A0%B4%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>荷兰公寓杀人案-答案</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Case-Apartment-Homicide-In-The-Netherlands-Ans/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Case-Apartment-Homicide-In-The-Netherlands-Ans/</id>
    <published>2021-04-24T12:00:00.000Z</published>
    <updated>2021-05-02T11:04:15.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><ol><li>埃里克在该公寓租房更可能的原因是?<br>A.埃里克正在与雷合作<br><font color="#56c596">B.埃里克要观察雷</font><br>C.埃里克不想住分配公寓<br>D.埃里克要调查分尸案</li></ol><ol start="2"><li>雷是被谁杀死的?<br>A.温特<br>B.丹<br>C.埃里克<br><font color="#56c596">D.博斯</font></li></ol><ol start="3"><li>是谁将丹锁在公寓一内?<br>A.雷<br>B.温特<br><font color="#56c596">C.埃里克</font><br>D.博斯</li></ol><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>埃里克作为大贩毒团伙多年的下手，他靠关系和博斯去了同一所监狱。博斯的哥哥皮特也在这所监狱中。他们三人很快洽谈起来——从该死的侦探和便利店的老板，谈到埃里克和博斯是如何手忙脚乱地往下水道倾倒毒品时忘了自己身上有枪可以反抗。</p><p>皮特表示自己因为开枪袭警而被判处了无期徒刑，而自己唯一的愿望就是希望弟弟斯能够在出狱之后向雷复仇。</p><p>博斯答应了。</p><p>时间慢慢爬过。雷在这段时间里过着穷困潦倒且堕落的日子，他等待着在博斯出狱后将其手刃。雷在丹的公寓楼里租房。丹的长期租金异常便宜——因为很久之前这里发生过碎尸案，几乎没有长期租客。丹作为当时碎尸案的目击证人，从垃圾袋中见证了那残忍的真相，精神上出了问题(家族精神疾病触发)。</p><p>从那之后，丹就对租户的垃圾袋特别不放心，总是要亲自翻看租户的垃圾，直到确认里面没有尸块为止。为了防止发生过凶案的公寓无法租出，丹拆下了所有的公寓门牌号，借此掩盖案现场的号码牌以使得不明真相的租户能继续租用公寓。</p><p>雷对此事并不知情也不在意。</p><p>2021年的4月，博斯和埃里克陆续出狱。雷打通警监，得到了埃里克出狱后被安排的住址。雷在埃里克的住址门口留了一封装有博斯与埃里克毒品交易的照片复印件和自己的电话联系方式的信。</p><p>这张照片复印件足以将埃里克重新定罪。</p><p>埃里克看见照片后立马拨向雷在信上留下的电话号码。电话里，雷希望埃里克可以接近博斯并且杀掉他，否则就向警方公布照片让其再进一次监狱。埃里克口头答应了雷，但却对此事有别的想法。</p><p>在埃里克看来，有可能拍照并且利用自己来杀掉博斯的人，应该是当时店长阿尔贝的亲人。于是埃里克于2021年4月13日找到隔壁店主罗根打听店长阿尔贝的人际关系，接着就联系到了后来退伍的军人温特。</p><p>温特明显不是联系埃里克的人，他对埃里克的存在完全不知情。埃里克通过说出催命电话这个细节贏得了温特和罗根的信任。</p><p>罗根于是给埃里克播放了当年案件最关键的证据——监控录像。监控上的人虽然模糊不清，但埃里克一眼认出画面中逃跑的人是博斯。录像里还有想要追上博斯的雷，只不过画面也是同样的模糊不清。埃里克虽知道杀人犯博斯的身份和行踪，但是他并未透露给温特，而仅是向温特透露了雷的情况，并暗示雷很可能在追查博斯。</p><p>2021年4月14日，丹通过雷扔在垃圾袋里的电话卡，得到了图片和短信内容。</p><p>丹一直依靠药物维持精神，他想通过出卖雷的住址等信息，来从这个贩毒的联系人那里赚一笔药费。丹联系到了埃里克，无意中透露了雷的身份。双方随后做了一笔交易——用雷的住址及个人信息来交药物和钱。</p><p>交易达成后，雷的住址被暴露在埃里克的面前。因雷拥有照片的复印件，故埃里克决定销毀掉该照片的原件及其它的信息和证据，届时了结一众人的夙愿。</p><p>埃里克用假身份住进与雷对门的公寓二，伺机观察雷的生活作息，了解他的习惯，从其房间内十分凌乱而防盗门的门镜里外却都被擦拭干净而推测其经常通过门镜进行观察。</p><p>温特多次的追问埃里克有关雷的更多事情，且有怀疑他的迹象，埃里克向温特透露了雷的住址所在地。听到这个消息的温特表示自己想与雷见面，以便了解父亲死亡案件的进展。埃里克也将雷的地址告知了博斯，通过几日的观察，埃里克发现雷的生活规律，觉得这是个机会，博斯想要杀人，而自己则可以顺势将雷手里的证据销毀。2021年4月23日早晨10点，雷出门，并在等待电梯时被埋伏已久的埃里克用电击枪击晕。埃里克把雷拖到了自己租的二号房间，所以房间门ロ较干净，且雷的衣服和后脑勺有灰尘，然后搜出雷身上的一号房间钥匙，打开雷的房门开始销毁证据。</p><p>10点09分，温特进入楼内并来到了公寓一前。此时埃里克还在房间内。温特敲了公寓一的门，屋内的埃里克担心暴露，并未回应温特。温特误以为雷不在家中，于是拨打了雷的电话(这个电话号码是丹留给埃里克，随后被埃里克告诉了温特)。电话铃从公寓二内雷的口袋里响了起来。站在公寓一外的温特听见铃声觉得纳闷，以为自己敲错了房门。于是温特转而敲响了公寓二的门，但是公寓二内也没有人回应。</p><p>由于没有门牌号的缘故，温特便打算找物业询问情况。温特从楼道广告得知房东丹平时住在顶楼后，便通过电梯上楼寻找房东丹了解住户雷的情况。</p><p>温特进入电梯并按下了10楼的按钮。</p><p>此时，埃里克处理完证据，钥匙遗留在了桌子上，回到自己的公寓二，并把雷搬回了公寓一。埃里克没有关上公寓一的门，而是留了道门缝以待博斯的到来。</p><p>随后埃里克径直回到了自己的公寓二。</p><p>10点25分，博斯来到雷半掩的门前。此时的雷已经半醒，他在迷糊之中看见了博斯。博斯瞬间用携带的粗尼龙绳从雷身后勒住他的脖子。</p><p>雷反应过来的时候已经晚了。挣扎了许久后，强撑着意识用右手抽出腰间藏有的防身匕首朝背后的博斯身上刺去。博斯虽然受伤，但是他没有松手，在雷失去意识后他依旧没有停止勒绞，直至雷死去。而房东那边听完温特的陈述后决定着备用钥匙与温特一同下楼查看住户雷的情况。此时公寓一内，博斯在确认雷死亡之后，捂着受伤的部位逃出了公寓一。由于首仍插在博斯的伤口上，因此走廊上仅滴落少量血滴。</p><p>因为害怕案发现场被人过早发现而导致自己无法顺利脱身，博斯离开前关上了雷的房门。博斯走向电梯，正好在走廊转角撞见赶下来的丹和温特。衣物带血的博斯使丹的情绪变得激动起来。而温特则认为五楼两户居民中一户为雷，推断此人受伤很可能与雷有关，且通过自己参军的敏锐洞察力判断出博斯就是监控中那个枪杀父亲并逃窜的凶手。</p><p>博斯谎称有人要杀害自己，凶手被他打晕，寻求救命。温特让丹留在原地看守防止手逃离，自己则找借口说要护送伤者到一楼。丹慌乱之中听取了温特的意见，在公寓一门口将门死死抵住。温特帮博斯打开了电梯的大门，博斯因失血过多靠着电梯壁坐在地。温特不打算帮助杀父凶手博斯，他趁博斯不注意，拔出了留在博斯体内的首，让博斯失血过多在电梯内死去。博斯死之后，温特拨打了急救电话并离开建筑物前往街角等待救护车的到来。</p><p>此时公寓二内的埃里克通过门镜看见丹抵着公寓的门。于是埃里克故意开门训斥丹在偷窥租户。丹回头辩解，并向埃里克说明情况。埃里克建议应该先进屋制服凶手再报警。</p><p>于是丹用备用钥匙打开了公寓一的房门。丹和埃里克进入公寓一，看到了雷死不瞑目的尸体，丹并没有注意到此刻身后的埃里克掏出了电击枪。埃里克从丹背后用电击枪将其击晕，拿走了丹的备用钥匙串，随后在公寓一门外用备用钥匙将门反锁，然后带着电击枪和备用钥匙通过楼梯跑到顶楼丹的住房寻找丹用来与自己交易的照片与电话卡。</p><p>在找到证据并将其销毀后，埃里克企图乘坐电梯离开。电梯门开后，博斯的尸体赫然倒在电梯里。埃里克灵机一动，将房东的备用钥匙串消除指纹并藏入了博斯的口袋，然后以最快的速度从楼梯离开建筑物。他并没有注意到沉睡的丹身上始终带着一张足以定罪的照片复印件…</p><p>走廊血迹的分析。</p><p>血迹未端的朝向即为伤者的移动方向。故本案中的伤者是从西向东地在走廊移动的。</p><img src="/assets/images/crimaster/2021/04/20210424-ans-1.png" alt="图片" class="post-image half"><p>雷是怎么死的?电击伤为什么与丹相同?可不可能是雷死后被人为伪造出的勒痕?会不会博斯当时没把人杀死，埃里克后来补刀?</p><p>①雷是生前被埃里克用电击枪击晕，后在苏醒时被博斯用绳索从身后勒住脖子发生机械性窒息后死亡的。因为雷的脖颈处有挠抓痕迹，故其被袭击时是有一定行动能力的，但在首插入后未被拔出多次反抗说明雷当时已经用尽全身力气，行动能力较弱了，博斯此时受伤，定不会给雷有活过来害自己的机会，且在博斯逃出后雷并没有追击，也没有拨打报警电话，说明雷当时起码是处于昏迷状态，而尸检中有线索雷的脖颈处仅一圈勒无二次被勒痕迹。</p><p>②颈后为电击伤，并非雷的致死原因，其与丹的电击伤相同是因为两人受到的袭击都来自于埃里克。</p><p>③鉴别生前索沟或死后索沟，除生前索沟出血外，还可取索沟部皮肤作组织学、组织化学检查，以及作组织胺和5-羟色胺的生物化学测定，生前索沟含量明显增高，死后索沟的含量不增局。</p><p>④榑斯想要的是帮自己的黑帮兄弟复仇，一定会要雷偿命的。此外，如果埃里克想要雷死，在使用电击枪的时候就可以动手了。且埃里克如果杀害雷，动机是有证据在其手上，那么丹也知晓其事情，理应将二人同时杀害，且埃里克逃走时以为证据已被销毀，杀害雷对他无益。该部分详见案件还原。</p><p>尘封案件一与本案有联系吗?</p><p>分析有无联系的绝佳途径就是寻找两起案件的相似之处。我们分析后发现尘封案件一与本案最大的关联可能就在房东丹身上。</p><p>在此之前我们先把目光放在这幢公寓本身，这幢公寓目前由房东丹掌管。根据群众的说辞，公寓各方面都很好，但是租金却异常低廉，这现象显然不太符合现实。</p><p>根据丹的线索可以发现，其父亲因精神分裂症恶化被送往疗养院是在2015年11月，而分尸案发生的日期也是在该月。丹的父亲的入院无疑给丹造成了经济压力。而且我们知道，如果一处小区或住宅发生了影响恶劣的凶案，那么它的信誉度和口碑就会在周边地区降低，久而久之客人便不愿意租住。此处，便是由于凶案的影响，公寓五楼的客房在很长时间内都无人租住，这使得丹承担了经济损失。</p><p>①所以为了消除案发生地501号房对业务的影响，丹索性拆掉了门牌号。如此一来租户便难以分清传言的真伪。</p><p>②同时，凶案的影响使得房东丹精神失常，从而形成了喜欢检查他人垃圾袋的癖好，还给房东丹带来了恶劣的精神分裂症。</p><p>相比于尘案二，尘案一提供的线索并不多。故并案调查的主要方向应当在线索丰富的尘案二上面。</p><p>科普时间：</p><p>一、自1976年起，荷兰政府就把毒品分类为硬毒品和软毒品。对海洛因、可卡因这些严重危害公众身体健康的硬毒品实行严厉打击。而像“大麻”这种所谓的“软毒品”，则允许公开买卖。荷兰此举当然不是在鼓励或支持毒品合法，其主要目的在于将大麻与非法渠道隔离，从而减少人们接触硬毒品的机会。值得注意的是，目前荷兰硬毒品的成比例是欧盟平均水平的3/5;而其因静脉注射感染艾滋的人数比例为10％，低于欧盟平均水平40％。</p><p>二、遗传因素在精神分裂症的发病中起重要作用。研究显示，一级亲属中同患本病的危险率约为4％-14％，约为一般人群的10倍。若双亲均患精神分裂症，其危险率可高达40％。在患者的二级亲属中，患病的危险率约高于一般人口的3倍。国外研究显示(1974)，精神分裂症单卵孪生子的同病率较双卵孪生子高。单卵孪生子的同病率6％-73％;双卵孪生子的同病率2.1％-12.3％。研究显示，精神分裂症具有一定的遗传因素，且血缘关系越近，危险率越高;遗传因素的影响较环境及其他因素大。截止目前，精神分裂症的基因定位研究尚无定论，精神分裂症可能是多基因遗传，由若干基因的叠加作用所致。</p><p>温馨提示：</p><p>生活有诸多不易，但我们干万不能让自己对生活的美好初衷，随着时间的流逝而日衰老直到熄灭。谨记自己内心的温存，去感受生活的美好。笔者愿用雷蒙德·钱德勒《漫长的告别》书中的一句经典人物台词来做本案的结尾“你知道，故事的结尾并不重要，生活唯一确保我们的就是死亡。所以我们最好不要让那结尾，夺走了故事的光芒。”</p><p>另，本文在创作过程中，可能受到国内外多部优秀悬疑推理或文学经典作品的启发，在这里特别向约翰・迪克森・卡尔《三口棺材》、紫金陈《长夜难明》、伊恩・麦克尤恩《阿姆斯特丹》等大师与作品致敬!</p>]]></content>
    
    
    <summary type="html">20210424期疑案追凶《荷兰公寓杀人案》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="疑案追凶" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E7%96%91%E6%A1%88%E8%BF%BD%E5%87%B6/"/>
    
    
    <category term="疑案追凶-解答" scheme="http://yoursite.com/tags/%E7%96%91%E6%A1%88%E8%BF%BD%E5%87%B6-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>荷兰公寓杀人案</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Case-Apartment-Homicide-In-The-Netherlands/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Case-Apartment-Homicide-In-The-Netherlands/</id>
    <published>2021-04-24T00:00:00.000Z</published>
    <updated>2021-05-02T11:06:02.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="案件介绍"><a href="#案件介绍" class="headerlink" title="案件介绍"></a>案件介绍</h1><p>2021年4月23日 荷兰 阿姆斯特丹警方先后接到两通报警电话——第一通报警电话为急救队员拨打，时间为上午10:55，其称接到一名男性拨打的急救电话后赶到城西公寓，但赶到时救助对象已死亡；第二通报警电话时间为上午11:35，一名男性称自己被袭击，醒来后在一间公寓内，房间从外用钥匙被反锁无法打开，其身旁有一具尸体。警方迅速到场展开调查，两起案件事发地点为同一建筑物内。警方将与此案相关嫌疑人初步锁定在案发时间段出入该栋公寓楼的人员中。案情紧急，警方现将线索公开，希望全球侦探可以协助调查。</p><p>楼层结构详情见下图，图中按照上北下南的地图方位展示。</p><img src="/assets/images/crimaster/2021/04/20210424-1.png" alt="图片" class="post-image half"><h1 id="现场侦测"><a href="#现场侦测" class="headerlink" title="现场侦测"></a>现场侦测</h1><p>事件发生于城西一栋十层套楼内，内部设有一部电梯及一处楼梯，建筑出口处设有监控，每层仅有两间公寓，公寓都安有防盗门窗。防盗门上带有门镜，五楼的防盗门没有被人为撬锁的痕迹。公寓租金低廉，租户较少。各层公寓本应挂有门牌号的地方空空如也。</p><p>五楼走廊发现多处滴落状血迹，由数量不一的环形血迹构成，其末端由单一的、呈长椭圆形的血迹构成，该末端朝向东方向且与走廊墙面平行。</p><p>案发当日的大门监控内容如下:</p><p>2021年4月23日</p><ul><li>10点09分，温特进入建筑。</li><li>10点20分，博斯进入建筑。</li><li>10点46分，温特离开建筑。</li><li>10点50分，埃里克离开建筑。</li><li>10点53分，急救人员与温特进入建筑。</li><li>11点05分，警方介入。</li></ul><h1 id="尘封档案"><a href="#尘封档案" class="headerlink" title="尘封档案"></a>尘封档案</h1><ol><li>案件一(2015/11/20)<br>一名单身女租户艾玛在城西公寓五楼501室被肢解后在十五个黑色垃圾袋中。报案人为丹，兼尸体第一发现者。公寓内作案痕迹损坏严重，财物被洗劫一空。死者被发现时已死亡4天，身体器官未有遗失。因线索缺失，凶手至今尚未被抓获，此案仍在侦破中。</li></ol><ol start="2"><li>案件二(2015/10/22)<br>亚历山大广场附近的一处便利店内发生抢劫杀人案件，报案人为罗根，兼尸体第一发现者。现场的柜台现金及部分商品遭到洗劫。死者为便利店主阿尔贝，头部一处中弹。店内监控显示案发当晚凶手趁店主在柜台熟睡时行窃，期间店主突然醒来，随后双方发生冲突。凶手开枪杀人并席卷财物后逃逸。因凶手戴有头套及手套，故相关线索缺失。此案仍在侦破中。</li></ol><ol start="3"><li>并案调查<br>警方怀疑以上两起旧案件与4月23日的案件之间可能存在某种联系，故将部分线索给出，希望有助于案件的尽快侦破。</li></ol><ol start="4"><li>群众证词<br>我已经退租半个多月了，那房子确实不错，环境安静，租金也便宜。但是我不喜欢那个房东，他好变态啊！这人嘴上说着帮我们倒垃圾，实则…我有次跟着想看他做些什么把戏，结果他背地里把别家的垃圾带回去翻找、拍照！他做这种事还不止一次两次！</li></ol><h1 id="博斯-死者1"><a href="#博斯-死者1" class="headerlink" title="博斯(死者1)"></a>博斯(死者1)</h1><ol><li>死者信息<br>博斯，男，37岁。曾因涉嫌吸毒以及非法持有枪支被捕，两个月前出狱，现在某便利店做职员。</li></ol><ol start="2"><li>尸检报告<br>尸体右季肋区见一盲管刺创(刺入口唯一，但体内有多处刺创管，距离为4-7cm不等，切角一锐一钝)；伤及多处内脏，肝脏割裂伤尤为明显；血检无明显异常。推测致死原因为失血过多，已大致确定其死亡时间在10:20—11:00内。</li></ol><ol start="3"><li>案发现场<br>死者被发现侧躺于建筑物电梯内一尸体旁有一把带血的匕首(握把发现雷、博斯和温特的指纹)，电梯内部地板被血液浸染，电梯墙壁存在大量喷溅血迹。急救人员称进到楼内时电梯并不在一楼，按下电梯按键后显示电梯从十楼开始下降。</li></ol><ol start="4"><li>钥匙串<br>尸体口袋里发现一串钥匙，包含五楼一号房间的一把钥匙、二号房间的两把钥匙以及其他的一些公寓钥匙。钥匙串上未提取到有效指纹。</li></ol><ol start="5"><li>通话记录<ul><li>2021年4月22日00:20，呼入  埃里克  37分钟</li><li>2021年4月23日10:18，呼出  埃里克  未接</li></ul></li></ol><ol start="6"><li>犯罪记录<br>经查博斯有违法犯罪记录，违法犯罪记录如下:<ul><li>2013年5月29日至2016年7月8日因涉嫌参与黑社会性质犯罪活动被通缉。</li><li>2016年7月8日因涉嫌吸毒及违法持有枪械被捕进入戒毒所强制戒毒，后转入荷兰芬赫伊曾监狱服役，2021年2月22日刑满释放。</li></ul></li></ol><ol start="7"><li>深入调查<br>得知在2013年5月被捕的一名黑社会成员皮特与博斯系表兄弟关系，前者因涉嫌走私、贩毒、谋杀、袭警等多项罪名被判终生监禁，现在荷兰芬赫伊曾监狱服役。</li></ol><h1 id="雷-死者2"><a href="#雷-死者2" class="headerlink" title="雷(死者2)"></a>雷(死者2)</h1><ol><li>死者信息<br>   雷，男，45岁，前私家侦探，现无固定职业，曾帮助警方侦破过多起案件，警方内部对其评价大都极高。</li></ol><ol start="2"><li>尸检报告<br>颈部仅一道水平环形闭锁状索沟，无二次被勒痕迹；颈后皮肤发灼烧样红肿，周围肌肉僵直，皮肤发黄；面部皮肤和眼结合膜点状出血；口唇、指甲紫绀；存在肝肾淤血；脖颈处有抓痕；对索沟部皮肤作生物化学测定得5-羟色胺含量较一般值高。推测死者的死亡时间在10:10—10:50之间。</li></ol><ol start="3"><li>租房记录<br>记录显示雷于2016年11月2日独自租住了该建筑五楼的公寓一，并已提供居民ID卡及手机号码。</li></ol><ol start="4"><li>死亡现场<br>死者被发现时趴伏于公寓一内，脖子上围绕有一圈尼龙绳(与死者脖子上的勒痕吻合)。房间茶几，上摆着一个半满的烟灰缸、一瓶快喝光的酒，室内存在打斗痕迹。死者的后脑勺及后<br>   背衣物表面发现有少量灰尘粘附。死者右袖口、手掌及身旁的毛绒地毯上发现少量血迹，鉴定结果显示该血迹系博斯所有。</li></ol><ol start="5"><li>工作经历<br>2013年5月雷与警方合作办案时受伤，并因擅自开枪被吊销侦探执照，此后销声匿迹，工作不明。</li></ol><ol start="6"><li>健康证明<br>警方查得雷的WHO-ICF残疾和健康评定表记录——腿部枪伤痊愈不佳产生后遗症，移动及弯腰不便。</li></ol><ol start="7"><li>电脑文件<br>位于卧室中的电脑被人为损坏，针对其中的云端文件备份还在调查中，暂无进展。公寓内共发现两部手机，一部为侦探身上正常使用的手机，另一部手机上未发现电话卡。</li></ol><ol start="8"><li>通话记录<br>2021年4月23日10:15未知号码(经查为温特)呼入3次未接。</li></ol><ol start="9"><li>钥匙<br>公寓一的电脑桌上发现该公寓的钥匙，其表面发现雷以及埃里克的指纹。</li></ol><ol start="10"><li><p>侦探日记<br>在卧室抽屉内发现一本日记便签本。摘录部分内容如下： </p><ul><li><p>日记1：<br>备注：搜集证据，不忘此刻。<br>——02/08/2015</p></li><li><p>日记2：<br>便利店失窃，那通电话我不该打的。那枪好像打在了我的良心上。腿伤，该死。这东西让我想起过去，那时我还有正经工作。真希望我是某本小说或是某部电影里的主角，对待罪犯手到擒来。对，查下去，叫他明白什么是铁拳。<br>——24/10/2015</p></li><li><p>日记3：<br>房东是个热心肠，他喜欢帮忙扔垃圾。可给我省去不少麻烦。身体落下残疾确实令人难受，不过好处是我的垃圾不劳我亲自扔了。<br>——04/11/2016</p></li><li><p>日记4：<br>酒精其实和毒品一个样，都爱把人拉进阴沟里。不过人也古怪，自己甘愿被操纵。可我不能如此下去，我必须得迅速振作。悔恨与歉意在劝我迷途知返——我尽量不让它们占尽上风并告诉它们这份坚持不懈源自何方。<br>——22/04/2021</p></li></ul></li></ol><h1 id="丹-房东"><a href="#丹-房东" class="headerlink" title="丹(房东)"></a>丹(房东)</h1><ol><li>嫌疑人信息<br>丹，男，51岁，175cm，已婚。经调查丹的父亲因精神分裂症恶化，于2015年11月送入本地一家疗养院，母亲去世。妻子带女儿回了外婆家。</li></ol><ol start="2"><li>口供<br><strong>丹</strong>：我醒来就看见他倒在地上我没有杀人，不是我！<br><strong>警官</strong>：丹先生请你冷静一下，你确定死者当时已经死亡了吗？<br><strong>丹</strong>：是的，他死了。<br><strong>警官</strong>：因为你有重大的作案嫌疑，现在你可以陈述自己当天的行踪，我们经过后续调查再进一步判断案情走向。<br><strong>丹</strong>：我醒来，就看见雷躺在那。我不是凶手，我一直都不是手！很……我的头很痛！<br><strong>警官(对医务人员)</strong>：门外提着医疗箱的几位，请进来一下。丹先生的情绪很不稳定!</li></ol><ol start="3"><li>房间情况<br>其居住在该建筑第10楼，房屋内有多处翻找痕迹，未发现有贵重物品丢失。房间内的烟灰缸内有多个烟蒂以及多堆烟灰，烟灰中发现燃尽的PET材料、烧焦的纸张碎屑和一张烧焦的电话卡。</li></ol><ol start="4"><li>手机信息<br>裤袋中发现一部手机——相册中有许多不同垃圾袋内物品的近距离拍照，其中一张相片拍摄了一个电话卡。通话记录显示此手机于2021年4月23日11:35分拨打了报警电话。</li></ol><ol start="5"><li>手机录音<br>在房东的手机里面找到了一段通话录音，于2021年4月14日13:35分录制。电话另一端的声音经过处理，内容如下：<br><strong>另一头</strong>：还有什么别的事情?你之前说的内容已经他妈的够疯狂了！<br><strong>房东</strong>：这是我捡到的电话卡。<br>…(杂音，30秒后声音再次出现)<br><strong>房东</strong>：我知道雷的住址。<br><strong>另一头</strong>：雷，是他真不明白到底发生了什么，连我都要被扯进来。你还知道什么？把雷的住址告诉我！<br><strong>房东</strong>：其他的我不清楚。不过我想要一些奥氮平。<br><strong>另一头</strong>：奥氮平…好吧，我去帮你弄点。你要让我寄到哪里？<br><strong>房东</strong>：你就帮我寄到…等一下，你先弄到药再说。<br><strong>另一头</strong>：你先说个地方吧，等你拿到了药，再聊其他也不迟。</li></ol><ol start="6"><li>复印件<br>丹的裤袋里装有一张从楼顶向下拍摄的小巷子照片，巷子中的两人(分析得出是埃里克和博斯)正把袋装的白色粉末与钱递给对方照片右下方的拍摄时间显示是2016年7月8日下午16：05。</li></ol><ol start="7"><li>健康状况<br>颈后皮肤发现有一处灼烧样红肿，周围肌肉僵直，皮肤发黄。丹目前的精神状态并不好，但具有一定的逻辑思维能力，经过医生确认可以协助警方进行调查。</li></ol><h1 id="埃里克-毒贩"><a href="#埃里克-毒贩" class="headerlink" title="埃里克(毒贩)"></a>埃里克(毒贩)</h1><ol><li>嫌疑人信息<br>埃里克，男，38岁，183cm，离异子女抚养权归女方所有。其与父母家人关系均不和，故现已无联系。</li></ol><ol start="2"><li>口供<br><strong>警方</strong>：因为你有重大的作案嫌疑，现在你需要陈述自己当天的行踪，我们经过后续调查再进一步判断案情走向。<br><strong>埃里克</strong>：我当天一直在房间里睡觉，后来被外面打斗的声音吵醒，我比较担心牵扯到我，一直待在房间里没敢出声。后来好像没了声音，我开了门缝发现外面有血迹，想着还是离开比较安全，就从楼梯跑出去了。<br><strong>警方</strong>：你听到打斗声音是几点？<br><strong>埃里克</strong>：十点半左右吧。<br><strong>警方</strong>：你的陈述已经记录在案，这意味着它们将具有法律效益，你还有什么要补充的吗？<br><strong>埃里克</strong>：没有了。</li></ol><ol start="3"><li>房间情况<br>室内脏乱不堪，防盗门的门镜里外被擦拭干净。进门一侧的地面较为光洁，其余的衣柜、餐桌和地面都积满灰尘，房间角落堆满了食品包装袋屋内多处发现埃里克的指纹。</li></ol><ol start="4"><li>毛发<br>进门一侧地面发现少量的毛发，DNA鉴定结果显示其中一部分的毛发系雷所有。</li></ol><ol start="5"><li>犯罪记录<br>经查埃里克有违法犯罪记录，违法犯罪记录如下：<ul><li>2016年7月8日因涉嫌吸毒及违法持有枪械被捕进入荷兰芬赫伊曾监狱服役，2021年4月9日刑满释放。</li><li>根据关押埃里克的荷兰芬赫伊曾监狱看守表示，其在监狱内喜欢拉帮结派，且此前关押在该监狱的黑社会人员皮特与博斯有密切接触。</li></ul></li></ol><ol start="6"><li>手机信息<br>手机中大部分信息有被批量删除迹象，正在恢复中。</li></ol><ol start="7"><li>租房记录<br>记录显示埃里克提供了虚假的居民ID卡，于2021年4月16日租住了该建筑五楼的公寓二。</li></ol><h1 id="温特-军人"><a href="#温特-军人" class="headerlink" title="温特(军人)"></a>温特(军人)</h1><ol><li>嫌疑人信息<br>温特，男，28岁，190cm，未婚。母亲早逝，由父亲带大。早年参军服役，现为自由职业者。</li></ol><ol start="2"><li>口供<br><strong>警方</strong>：我们怀疑你涉嫌杀人，接下来的问题你要如实回答，这关系到最终的调查结果。请问你昨天上午十点左右在什么地方？<br><strong>温特</strong>：雷先生是不是已经死了?我认为是……<br><strong>警方</strong>：我们只需要你陈述事实，别的东西你无权知道。<br><strong>温特</strong>：好的警官。我昨天十点左右想去找雷先生，但是敲门没人，打电话却可以在隔壁房间内听到铃声。我随即敲了隔壁的门，但是还是没有回应。然后我就上楼去找房东，不过耽误了挺长时间。后面跟房东去五楼查看，在走廊转角处发现了一个满身是血的家伙。房东好像怕血，为了救人，我跟着这个家伙下了楼。结果我在打急救电话的时候，他就断了气。就这些了。<br><strong>警方</strong>：你说你想找雷先生，但最后你却没有去找他。对此你有什么想说的？<br><strong>温特</strong>：呵，不是你们的速度快，把我马上带走了么。<br><strong>警方</strong>：你的陈述已经记录在案，这意味它们将具有法律效益，你还有什么要补充的吗？<br><strong>温特</strong>：没有了。</li></ol><ol start="3"><li>监控录像<br>在其家中发现储存有监控录像的载体，监控中显示一名男子带着头套(外貌与博斯相似)进入便利店，一段时间后该男子匆匆离开。随后一名衣着严密的男子(外貌与雷相似)从监控视野外冲向便利店。之后隔壁店主罗根进入便利店，经过约半小时后警方到来。监控显示的时间为22/10/2015 13:04-13:15。</li></ol><ol start="4"><li>血迹<br>温特的裤子上部、双手袖口及胸前白色衣物上沾有少量博斯的血液。</li></ol><ol start="5"><li>通话记录<ul><li>13/04/2021，10:40，呼入  埃里克  10分钟</li><li>22/04/2021，22:30，呼入  埃里克  12分钟</li><li>23/04/2021，10:15，呼出三次  雷  未接</li><li>23/04/2021，10:42，呼出  急救电话  3分钟</li></ul></li></ol><ol start="6"><li><p>书信<br>在温特家中发现的书信。信纸泛黄，摘录如下:</p><p>亲爱的温特:<br>最近好吗，小温特？我听退伍的朋友说，部队的生活很不错，当然前提是你没有被指派到前线上。你在部队，孤身一人，请一定把自己照顾好。<br>你一定很奇怪为什么是我来给你写信吧，唉，真不知道承受的痛苦还要有多少，才能够赎回我们的罪过。温特你的父亲，昨天被枪杀了。我当时就在自己的店里，我看见凶手拿着枪从现场冲出来…原谅我温特，我没有那种勇气上去追凶，只能报警。警察花了挺久才到店里，他们只是拍了一些照片。我告诉警察我有录像，但是他们完全不在乎。警察走之后，我叫了殡仪馆的人。两天后我会为你父亲举办葬礼。如果你能(被划掉的文字)，我们也会念你的名字……<br>我欠你父亲很多人情。但是现在我只能以最痛苦的方式偿还。但请你不要担心这边的事情。我会处理好切，录像也会保存。你孤身一人在外，请一定要多保重啊!<br>   罗根<br>   22/10/2015</p></li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>埃里克在该公寓租房更可能的原因是?<br>A.埃里克正在与雷合作<br>B.埃里克要观察雷<br>C.埃里克不想住分配公寓<br>D.埃里克要调查分尸案</li></ol><ol start="2"><li>雷是被谁杀死的?<br>A.温特<br>B.丹<br>C.埃里克<br>D.博斯</li></ol><ol start="3"><li>是谁将丹锁在公寓一内?<br>A.雷<br>B.温特<br>C.埃里克<br>D.博斯</li></ol>]]></content>
    
    
    <summary type="html">2021年4月23日 荷兰 阿姆斯特丹警方先后接到两通报警电话——第一通报警电话为急救队员拨打，时间为上午10:55，其称接到一名男性拨打的急救电话后赶到城西公寓，但赶到时救助对象已死亡；第二通报警电话时间为上午11:35，一名男性称自己被袭击，醒来后在一间公寓内，房间从外用钥匙被反锁无法打开，其身旁有一具尸体。警方迅速到场展开调查，两起案件事发地点为同一建筑物内。警方将与此案相关嫌疑人初步锁定在案发时间段出入该栋公寓楼的人员中。案情紧急，警方现将线索公开，希望全球侦探可以协助调查。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="疑案追凶" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E7%96%91%E6%A1%88%E8%BF%BD%E5%87%B6/"/>
    
    
    <category term="疑案追凶" scheme="http://yoursite.com/tags/%E7%96%91%E6%A1%88%E8%BF%BD%E5%87%B6/"/>
    
  </entry>
  
  <entry>
    <title>神秘交易-答案</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Delegate-Mysterious-Deal-Ans/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Delegate-Mysterious-Deal-Ans/</id>
    <published>2021-04-23T12:00:00.000Z</published>
    <updated>2021-05-02T09:22:12.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>南京市</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>男子乘坐的航班为深圳航班，且为国內航班(本题为贴合现实类题目，航班到达时间需要以实际到达时间为准)该男子13:30到达，从机场取行李以及出站按较快20分钟算加上车程25分钟，对于在12:45之前实际到达广州的深圳航空且行李转盘为20的航班进行查询，査询方式可以如下(广州白云机场官网)</p><p><a href="https://www.gbiac.net/byairport-web/flight/list?depOrArr=2&amp;type=1&amp;terminal=T1&amp;day=-1" target="_blank" rel="noopener">https://www.gbiac.net/byairport-web/flight/list?depOrArr=2&amp;type=1&amp;terminal=T1&amp;day=-1</a></p><img src="/assets/images/crimaster/2021/04/20210423-ans-1.png" alt="" class="post-image half no-limit-height"><p>通过行李转盘为20，初步确定了部分航班，通过具体的航班号进行查询，可下载非常准等APP查询实际到达时间以及登机口</p><img src="/assets/images/crimaster/2021/04/20210423-ans-2.png" alt="" class="post-image half no-limit-height"><p>通过登机口为13，所以最终锁定为南京，且南京当日温度为:最高21度，最低17度。天气为:雷阵雨转阴。</p><p>广州4月22日温度:最高31度，最低21度。天气:多云转晴。下午13:00时气温30度左右。该男子手中带着用塑料袋包裹的雨伞，塑料袋上有些许雾气，皮鞋表面有少量泥点，而广州无雨，推测其来时地区下过雨。</p><p>该男子手中帯着一件长袖西服外套，推测其来时地区温度可能没有广州温度高。</p><p>12:34实际到达，拿取行李并走到上车处加上25分钟的车程，13:30到达地点也符合。最终确定地点为南京市。</p>]]></content>
    
    
    <summary type="html">20210423期侦探委托《神秘交易》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托-解答" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>神秘交易</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Delegate-Mysterious-Deal/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Delegate-Mysterious-Deal/</id>
    <published>2021-04-23T00:00:00.000Z</published>
    <updated>2021-05-02T09:17:15.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>我是一名侦探，因接到了一位雇主的委托任务，得知<font color="#e03e3e">2021年4月22日</font>下午在广州市XX大厦有一场交易活动，该活动的交易人员身份不明，仅有一张照片，我需要前往该地点秘密调查出其身份及来处，以获得这场秘密交易的更多信息。</p><p>我早早在大厦旁找了一个适合观察的位置，<font color="#e03e3e">下午13:30时</font>，一辆出租车停靠在了大厦门前，目标男子从车内下来。</p><p>通过望远镜观察，男子手持一张深圳航空的机票和一把被塑料袋包裏的折叠雨伞，机票的其余重要信息被他的手部遮挡住，只在其手指缝隙中可看到登机口处数字为<font color="#e03e3e">13</font>，男子身穿白色短袖T恤、白灰色西服长裤、黑色皮鞋，手中拿着一件长袖西服外套，下车后从车后备箱拿下来一个行李箱走入了大厦。</p><p>该男子身高目测约188cm，年龄三十左右，身材偏瘦。塑料袋上有些许雾气，皮鞋表面有少量泥点，行李箱上贴有一个广州机场的行李贴，隐约可看到行李转盘号为<font color="#e03e3e">20</font>。</p><p>男子进入大厦后我立刻通过出租车车牌号联系到了司机并获取到了一些信息，得知该男子不会粤语，并未与司机在车上有过多交流，从机场到这里车程约<font color="#e03e3e">25分钟</font>左右，路上车良好，到达目的地共计<font color="#e03e3e">45元</font>车费。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>男子是从哪个城市来的？<font color="#e03e3e">例如:北京市</font></p>]]></content>
    
    
    <summary type="html">我是一名侦探，因接到了一位雇主的委托任务，得知4月22日下午在广州市XX大厦有一场交易活动，该活动的交易人员身份不明，仅有一张照片，我需要前往该地点秘密调查出其身份及来处，以获得这场秘密交易的更多信息。</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>观察推理入门篇—YK手稿-答案</title>
    <link href="http://yoursite.com/2021/04/Crimaster-Delegate-YK-Observation-Intro-Ans/"/>
    <id>http://yoursite.com/2021/04/Crimaster-Delegate-YK-Observation-Intro-Ans/</id>
    <published>2021-04-21T12:00:00.000Z</published>
    <updated>2021-05-02T09:12:11.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><ol><li>人物A的职业更可能是以下中哪一个?<br><font color="#56c596">A.教师</font><br>B.外科医生<br>C.钢琴家<br>D.歌唱家</li></ol><ol start="2"><li>人物的职业更可能是以下中哪一个?<br>A.竖琴演奏者<br><font color="#56c596">B.小提琴演奏者</font><br>C.大提琴演奏者<br>D.二胡演奏者</li></ol><ol start="3"><li>人物C的职业更可能是以下中哪一个?<br>A.瓦匠<br>B.木匠<br><font color="#56c596">C.电焊工</font><br>D.油漆工</li></ol><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一题：A，教师</p><p>双手纤细表明并不从事体力劳动，右手食指中指关节突起，小鱼际处沾有笔墨说明经常持笔写字，随身携带本子说明有记笔记的习惯，臀骨相对宽大表明有久坐的习惯。服用薄荷含片，有过轻咳可能是常年教学吸入过多粉尘以及常年讲课导致肺部以及喉咙患有疾病。由此选项中的教师更可能是该男子的职业。<br>外科医生可能手指食指会有一条细线勒出的倾斜痕迹。钢琴家的指腹较常人通常更厚。演唱家大多需长时间站立。</p><p>第二题：B，小提琴演奏者</p><p>手提包中露出曲谱部分，推测该女子可能从事或爱好演奏等与音乐相关的事物。该女子指甲较短，左手食指、中指以及无名指指腹有茧，大中小提琴、二胡等乐器的演奏会有此特征，颈椎处贴有棕色膏药，下巴左侧有茧，选项中的小提琴在练习时会需要脖子向左侧倾斜，长期练习后在与琴身接触的位置往往会有红肿甚至起茧等现象。<br>竖琴需双手弹奏，不符合单手出茧的细节。</p><p>第三题：C，电焊工</p><p>该男子左右手臂较发达，手掌心有厚实茧子，手背及脸部有多处凹陷的疤痕。眼部有较多红血丝，皮肤干裂粗糙颜色黝黑。行为:多次揉搓眼部，多次重咳。<br>电焊工在工作时需要穿戴防护服饰，但在炎热的夏日厚实的衣物会使炎热相当难耐，长期工作的人员在防护不当时容易被烫伤留下疤痕。且电弧光辐射会对眼睛以及裸露的皮肤有严重损伤，引起电光性眼炎等。在熔化焊条和焊件的同时会产生大量的烟尘，极容易吸入肺中，长期吸入则会造成肺组织纤维性病变等。所以相对其他选项更可能是电焊工。</p><p>我迫不及待的想证明自己的猜想，于是把书丢在了人物A的脚下，捡书时刻意碰了碰他。随后我自来熟的向他介绍了我自己，他未在意，倒是示意让我把书递给他看看。我把书给了他，漫不经心似的问道他叫什么，从事什么。男子回答道：“我是个推理小说家，笔名AID”。</p>]]></content>
    
    
    <summary type="html">20210421期侦探委托《观察推理入门篇—YK手稿》答案与解析</summary>
    
    
    
    <category term="犯罪大师" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/"/>
    
    <category term="侦探委托" scheme="http://yoursite.com/categories/%E7%8A%AF%E7%BD%AA%E5%A4%A7%E5%B8%88/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98/"/>
    
    
    <category term="侦探委托-解答" scheme="http://yoursite.com/tags/%E4%BE%A6%E6%8E%A2%E5%A7%94%E6%89%98-%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
</feed>
